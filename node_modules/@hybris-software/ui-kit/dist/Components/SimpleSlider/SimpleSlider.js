"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;
require("core-js/modules/es.array.sort.js");
require("core-js/modules/web.dom-collections.iterator.js");
require("core-js/modules/es.promise.js");
require("core-js/modules/es.parse-int.js");
require("core-js/modules/es.regexp.exec.js");
require("core-js/modules/es.string.replace.js");
require("core-js/modules/es.regexp.to-string.js");
var _react = _interopRequireWildcard(require("react"));
var _SimpleSliderModule = _interopRequireDefault(require("./SimpleSlider.module.css"));
var _ThemeContext = _interopRequireDefault(require("../../Contexts/ThemeContext"));
function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
function _getRequireWildcardCache(nodeInterop) { if (typeof WeakMap !== "function") return null; var cacheBabelInterop = new WeakMap(); var cacheNodeInterop = new WeakMap(); return (_getRequireWildcardCache = function _getRequireWildcardCache(nodeInterop) { return nodeInterop ? cacheNodeInterop : cacheBabelInterop; })(nodeInterop); }
function _interopRequireWildcard(obj, nodeInterop) { if (!nodeInterop && obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== "object" && typeof obj !== "function") { return { default: obj }; } var cache = _getRequireWildcardCache(nodeInterop); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }
// Styles

// Contexts

function getSlidePerView(breakPoints, slidePerView) {
  if (breakPoints == null) {
    return slidePerView;
  } else {
    const sortedBreakpoints = Object.keys(breakPoints).sort((a, b) => a - b);
    for (const breakPoint of sortedBreakpoints) {
      if (window.innerWidth < breakPoint) {
        return breakPoints[breakPoint].slidesPerView;
      }
    }
    return breakPoints[sortedBreakpoints[sortedBreakpoints.length - 1]].slidesPerView || 1;
  }
}
function increaseIndex(index, setIndex, children, elementPerView) {
  if (index < children.length - elementPerView) {
    setIndex(index + 1);
  } else {
    setIndex(0);
  }
}
function decreaseIndex(index, setIndex, children, elementPerView) {
  if (index > 0) {
    setIndex(index - 1);
  } else {
    setIndex(children.length - elementPerView);
  }
}
function isMobile() {
  return typeof window.orientation !== "undefined" || navigator.userAgent.indexOf("IEMobile") !== -1;
}
function isSafariDesktop() {
  const ua = navigator.userAgent.toLowerCase();
  if (ua.indexOf("safari") != -1) {
    if (ua.indexOf("chrome") > -1) {
      return false;
    } else {
      if (isMobile()) {
        return false;
      } else {
        return true;
      }
    }
  }
}

/**
 * @param {string} animation - Animation type
 * @param {number} animationDuration - Animation duration
 * @param {boolean} disableDrag - Disable drag
 * @param {boolean} autoPlay - Enable autoplay
 * @param {number} autoPlayTransitionSpeed - Autoplay transition speed
 * @param {number} autoPlaySpeed - Autoplay speed
 * @param {Object} breakPoints - Breakpoints
 * @param {string} buttonClass - Class name for the buttons
 * @param {JSX.Element} children - Children
 * @param {number} dragSlideRatio - Drag slide ratio
 * @param {number} gap - Gap between elements
 * @param {string} nextChild - Next child
 * @param {boolean} paginationButtons - Enable pagination buttons
 * @param {string} paginationClass - Class name for the pagination buttons
 * @param {string} prevChild - Previous child
 * @param {number} slidePerView - Number of elements per view
 */

const SimpleSlider = _ref => {
  let {
    animation = "ease",
    animationDuration = 200,
    disableDrag = false,
    autoPlay = false,
    autoPlayTransitionSpeed = 1000,
    autoPlaySpeed = 2000,
    breakPoints = null,
    buttonClass = _SimpleSliderModule.default.buttons,
    children = [],
    dragSlideRatio = 0.02,
    gap = 40,
    nextChild = "Next",
    paginationButtons = true,
    paginationClass = _SimpleSliderModule.default.paginationButtons,
    prevChild = "Prev",
    slidePerView = 3
  } = _ref;
  const [index, setIndex] = (0, _react.useState)(0);
  const [containerWidth, setContainerWidth] = (0, _react.useState)(null);
  const [elWidth, setElWidth] = (0, _react.useState)(null);
  const [elTranslate, setElTranslate] = (0, _react.useState)(null);
  const [isDown, setIsDown] = (0, _react.useState)(false);
  const [offSet, setOffSet] = (0, _react.useState)(0);
  const [dragMovement, setDragMovement] = (0, _react.useState)(0);
  const [disableAnimation, setDisableAnimation] = (0, _react.useState)(false);
  const [transitionSpeed, setTransitionSpeed] = (0, _react.useState)(0);
  const childrenList = _react.Children.toArray(children);

  // Context Variables
  const themeContext = (0, _react.useContext)(_ThemeContext.default);
  const windowSize = themeContext.windowSize;
  const elementPerView = getSlidePerView(breakPoints, slidePerView);
  const computedDisabledDrag = disableDrag || isSafariDesktop();
  const sliderContainerRef = (0, _react.useRef)(null);

  // Drag Functions
  function dragRepositioning() {
    setIsDown(false);
    const sliderContainer = sliderContainerRef.current;
    sliderContainer.style.marginLeft = "".concat(-index * (elTranslate / containerWidth * 100), "%");
  }
  function onDragDesktop(e) {
    const sliderContainer = sliderContainerRef.current;
    if (isDown && !disableAnimation) {
      sliderContainer.style.marginLeft = "".concat(e.clientX - offSet - index * elTranslate, "px");
      if (index < childrenList.length - elementPerView) {
        if (offSet - e.clientX > dragMovement) {
          increaseIndex(index, setIndex, childrenList, elementPerView);
          setIsDown(false);
        }
      }
      if (index > 0) {
        if (offSet - e.clientX < -dragMovement) {
          decreaseIndex(index, setIndex, childrenList, elementPerView);
          setIsDown(false);
        }
      }
    }
  }
  function onDragMobile(e) {
    const sliderContainer = sliderContainerRef.current;
    if (isDown && !disableAnimation) {
      setDisableAnimation(true);
      sliderContainer.style.marginLeft = "".concat(e.touches[0].clientX - offSet - index * elTranslate, "px");
      if (index < childrenList.length - elementPerView) {
        if (offSet - e.touches[0].clientX > dragMovement) {
          increaseIndex(index, setIndex, childrenList, elementPerView);
          setIsDown(false);
        }
        setTimeout(() => {
          setDisableAnimation(false);
        }, transitionSpeed);
      }
      if (index > 0) {
        if (offSet - e.touches[0].clientX < -dragMovement) {
          decreaseIndex(index, setIndex, childrenList, elementPerView);
          setIsDown(false);
        }
        setTimeout(() => {
          setDisableAnimation(false);
        }, transitionSpeed);
      }
    }
  }
  (0, _react.useEffect)(() => {
    setTransitionSpeed(autoPlay || computedDisabledDrag ? autoPlayTransitionSpeed : animationDuration);
    if (windowSize.width) {
      const element = sliderContainerRef.current;
      const elementStyle = getComputedStyle(element);
      const containerMargin = parseInt(elementStyle.marginLeft);
      const containerW = parseInt(elementStyle.width.toString().replace("px", "")) + containerMargin;
      const elementW = (containerW - gap * (elementPerView - 1)) / elementPerView;
      setContainerWidth(containerW);
      setElWidth(elementW);
      setElTranslate(elementW + gap);
      setDragMovement(elementW * dragSlideRatio);
    }
  }, [windowSize]);
  (0, _react.useEffect)(() => {
    if (autoPlay || computedDisabledDrag) {
      const interval = setInterval(() => {
        increaseIndex(index, setIndex, childrenList, elementPerView);
      }, autoPlaySpeed);
      return () => clearInterval(interval);
    }
  }, [index, elementPerView]);
  return /*#__PURE__*/_react.default.createElement("div", {
    className: _SimpleSliderModule.default.slideshow
  }, /*#__PURE__*/_react.default.createElement("div", {
    ref: sliderContainerRef
    // Desktop
    ,
    onMouseDown: e => {
      if (!computedDisabledDrag) {
        setIsDown(true);
        setOffSet(e.clientX);
      }
    },
    onMouseMove: e => {
      if (!computedDisabledDrag) {
        onDragDesktop(e);
      }
    },
    onMouseUp: dragRepositioning
    // Mobile
    ,
    onTouchStart: e => {
      if (!computedDisabledDrag) {
        setIsDown(true);
        setOffSet(e.touches[0].clientX);
      }
    },
    onTouchMove: e => {
      if (!computedDisabledDrag) {
        onDragMobile(e);
      }
    },
    onTouchEnd: () => {
      if (!computedDisabledDrag) {
        dragRepositioning();
      }
    }
    // Check
    ,
    onMouseLeave: () => {
      if (!computedDisabledDrag) {
        dragRepositioning();
      }
    },
    className: _SimpleSliderModule.default.slideshowSlider,
    style: {
      cursor: disableDrag ? "unset" : isDown ? "grabbing" : "grab",
      transition: "all ".concat(transitionSpeed, "ms ").concat(animation),
      marginLeft: "".concat(-index * (elTranslate / containerWidth * 100), "%")
    }
  }, elWidth && containerWidth && elTranslate && childrenList.map((child, index) => /*#__PURE__*/_react.default.createElement(Slide, {
    key: index,
    width: elWidth,
    marginRight: gap
  }, child))), paginationButtons && /*#__PURE__*/_react.default.createElement(PaginationButtons, {
    index: index,
    setIndex: setIndex,
    children: childrenList,
    paginationClass: paginationClass,
    buttonClass: buttonClass,
    prevChild: prevChild,
    nextChild: nextChild,
    elementPerView: getSlidePerView(breakPoints, slidePerView)
  }));
};
var _default = SimpleSlider;
exports.default = _default;
const Slide = _ref2 => {
  let {
    children,
    width,
    marginRight
  } = _ref2;
  return /*#__PURE__*/_react.default.createElement("div", {
    style: {
      width: width,
      marginRight: marginRight
    },
    className: _SimpleSliderModule.default.slide
  }, children);
};
const PaginationButtons = _ref3 => {
  let {
    index,
    setIndex,
    children,
    paginationClass,
    buttonClass,
    prevChild,
    nextChild,
    elementPerView
  } = _ref3;
  return /*#__PURE__*/_react.default.createElement("div", {
    className: paginationClass
  }, /*#__PURE__*/_react.default.createElement("div", {
    className: buttonClass,
    onClick: () => {
      decreaseIndex(index, setIndex, children, elementPerView);
    }
  }, prevChild), /*#__PURE__*/_react.default.createElement("div", {
    className: buttonClass,
    onClick: () => {
      increaseIndex(index, setIndex, children, elementPerView);
    }
  }, nextChild));
};