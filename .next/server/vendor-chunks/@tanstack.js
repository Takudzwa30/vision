"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/@tanstack";
exports.ids = ["vendor-chunks/@tanstack"];
exports.modules = {

/***/ "(ssr)/./node_modules/@tanstack/match-sorter-utils/build/lib/index.mjs":
/*!***********************************************************************!*\
  !*** ./node_modules/@tanstack/match-sorter-utils/build/lib/index.mjs ***!
  \***********************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   compareItems: () => (/* binding */ compareItems),\n/* harmony export */   rankItem: () => (/* binding */ rankItem),\n/* harmony export */   rankings: () => (/* binding */ rankings)\n/* harmony export */ });\n/**\n * match-sorter-utils\n *\n * Copyright (c) TanStack\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE.md file in the root directory of this source tree.\n *\n * @license MIT\n */ const characterMap = {\n    À: \"A\",\n    Á: \"A\",\n    Â: \"A\",\n    Ã: \"A\",\n    Ä: \"A\",\n    Å: \"A\",\n    Ấ: \"A\",\n    Ắ: \"A\",\n    Ẳ: \"A\",\n    Ẵ: \"A\",\n    Ặ: \"A\",\n    Æ: \"AE\",\n    Ầ: \"A\",\n    Ằ: \"A\",\n    Ȃ: \"A\",\n    Ç: \"C\",\n    Ḉ: \"C\",\n    È: \"E\",\n    É: \"E\",\n    Ê: \"E\",\n    Ë: \"E\",\n    Ế: \"E\",\n    Ḗ: \"E\",\n    Ề: \"E\",\n    Ḕ: \"E\",\n    Ḝ: \"E\",\n    Ȇ: \"E\",\n    Ì: \"I\",\n    Í: \"I\",\n    Î: \"I\",\n    Ï: \"I\",\n    Ḯ: \"I\",\n    Ȋ: \"I\",\n    Ð: \"D\",\n    Ñ: \"N\",\n    Ò: \"O\",\n    Ó: \"O\",\n    Ô: \"O\",\n    Õ: \"O\",\n    Ö: \"O\",\n    Ø: \"O\",\n    Ố: \"O\",\n    Ṍ: \"O\",\n    Ṓ: \"O\",\n    Ȏ: \"O\",\n    Ù: \"U\",\n    Ú: \"U\",\n    Û: \"U\",\n    Ü: \"U\",\n    Ý: \"Y\",\n    à: \"a\",\n    á: \"a\",\n    â: \"a\",\n    ã: \"a\",\n    ä: \"a\",\n    å: \"a\",\n    ấ: \"a\",\n    ắ: \"a\",\n    ẳ: \"a\",\n    ẵ: \"a\",\n    ặ: \"a\",\n    æ: \"ae\",\n    ầ: \"a\",\n    ằ: \"a\",\n    ȃ: \"a\",\n    ç: \"c\",\n    ḉ: \"c\",\n    è: \"e\",\n    é: \"e\",\n    ê: \"e\",\n    ë: \"e\",\n    ế: \"e\",\n    ḗ: \"e\",\n    ề: \"e\",\n    ḕ: \"e\",\n    ḝ: \"e\",\n    ȇ: \"e\",\n    ì: \"i\",\n    í: \"i\",\n    î: \"i\",\n    ï: \"i\",\n    ḯ: \"i\",\n    ȋ: \"i\",\n    ð: \"d\",\n    ñ: \"n\",\n    ò: \"o\",\n    ó: \"o\",\n    ô: \"o\",\n    õ: \"o\",\n    ö: \"o\",\n    ø: \"o\",\n    ố: \"o\",\n    ṍ: \"o\",\n    ṓ: \"o\",\n    ȏ: \"o\",\n    ù: \"u\",\n    ú: \"u\",\n    û: \"u\",\n    ü: \"u\",\n    ý: \"y\",\n    ÿ: \"y\",\n    Ā: \"A\",\n    ā: \"a\",\n    Ă: \"A\",\n    ă: \"a\",\n    Ą: \"A\",\n    ą: \"a\",\n    Ć: \"C\",\n    ć: \"c\",\n    Ĉ: \"C\",\n    ĉ: \"c\",\n    Ċ: \"C\",\n    ċ: \"c\",\n    Č: \"C\",\n    č: \"c\",\n    C̆: \"C\",\n    c̆: \"c\",\n    Ď: \"D\",\n    ď: \"d\",\n    Đ: \"D\",\n    đ: \"d\",\n    Ē: \"E\",\n    ē: \"e\",\n    Ĕ: \"E\",\n    ĕ: \"e\",\n    Ė: \"E\",\n    ė: \"e\",\n    Ę: \"E\",\n    ę: \"e\",\n    Ě: \"E\",\n    ě: \"e\",\n    Ĝ: \"G\",\n    Ǵ: \"G\",\n    ĝ: \"g\",\n    ǵ: \"g\",\n    Ğ: \"G\",\n    ğ: \"g\",\n    Ġ: \"G\",\n    ġ: \"g\",\n    Ģ: \"G\",\n    ģ: \"g\",\n    Ĥ: \"H\",\n    ĥ: \"h\",\n    Ħ: \"H\",\n    ħ: \"h\",\n    Ḫ: \"H\",\n    ḫ: \"h\",\n    Ĩ: \"I\",\n    ĩ: \"i\",\n    Ī: \"I\",\n    ī: \"i\",\n    Ĭ: \"I\",\n    ĭ: \"i\",\n    Į: \"I\",\n    į: \"i\",\n    İ: \"I\",\n    ı: \"i\",\n    Ĳ: \"IJ\",\n    ĳ: \"ij\",\n    Ĵ: \"J\",\n    ĵ: \"j\",\n    Ķ: \"K\",\n    ķ: \"k\",\n    Ḱ: \"K\",\n    ḱ: \"k\",\n    K̆: \"K\",\n    k̆: \"k\",\n    Ĺ: \"L\",\n    ĺ: \"l\",\n    Ļ: \"L\",\n    ļ: \"l\",\n    Ľ: \"L\",\n    ľ: \"l\",\n    Ŀ: \"L\",\n    ŀ: \"l\",\n    Ł: \"l\",\n    ł: \"l\",\n    Ḿ: \"M\",\n    ḿ: \"m\",\n    M̆: \"M\",\n    m̆: \"m\",\n    Ń: \"N\",\n    ń: \"n\",\n    Ņ: \"N\",\n    ņ: \"n\",\n    Ň: \"N\",\n    ň: \"n\",\n    ŉ: \"n\",\n    N̆: \"N\",\n    n̆: \"n\",\n    Ō: \"O\",\n    ō: \"o\",\n    Ŏ: \"O\",\n    ŏ: \"o\",\n    Ő: \"O\",\n    ő: \"o\",\n    Œ: \"OE\",\n    œ: \"oe\",\n    P̆: \"P\",\n    p̆: \"p\",\n    Ŕ: \"R\",\n    ŕ: \"r\",\n    Ŗ: \"R\",\n    ŗ: \"r\",\n    Ř: \"R\",\n    ř: \"r\",\n    R̆: \"R\",\n    r̆: \"r\",\n    Ȓ: \"R\",\n    ȓ: \"r\",\n    Ś: \"S\",\n    ś: \"s\",\n    Ŝ: \"S\",\n    ŝ: \"s\",\n    Ş: \"S\",\n    Ș: \"S\",\n    ș: \"s\",\n    ş: \"s\",\n    Š: \"S\",\n    š: \"s\",\n    Ţ: \"T\",\n    ţ: \"t\",\n    ț: \"t\",\n    Ț: \"T\",\n    Ť: \"T\",\n    ť: \"t\",\n    Ŧ: \"T\",\n    ŧ: \"t\",\n    T̆: \"T\",\n    t̆: \"t\",\n    Ũ: \"U\",\n    ũ: \"u\",\n    Ū: \"U\",\n    ū: \"u\",\n    Ŭ: \"U\",\n    ŭ: \"u\",\n    Ů: \"U\",\n    ů: \"u\",\n    Ű: \"U\",\n    ű: \"u\",\n    Ų: \"U\",\n    ų: \"u\",\n    Ȗ: \"U\",\n    ȗ: \"u\",\n    V̆: \"V\",\n    v̆: \"v\",\n    Ŵ: \"W\",\n    ŵ: \"w\",\n    Ẃ: \"W\",\n    ẃ: \"w\",\n    X̆: \"X\",\n    x̆: \"x\",\n    Ŷ: \"Y\",\n    ŷ: \"y\",\n    Ÿ: \"Y\",\n    Y̆: \"Y\",\n    y̆: \"y\",\n    Ź: \"Z\",\n    ź: \"z\",\n    Ż: \"Z\",\n    ż: \"z\",\n    Ž: \"Z\",\n    ž: \"z\",\n    ſ: \"s\",\n    ƒ: \"f\",\n    Ơ: \"O\",\n    ơ: \"o\",\n    Ư: \"U\",\n    ư: \"u\",\n    Ǎ: \"A\",\n    ǎ: \"a\",\n    Ǐ: \"I\",\n    ǐ: \"i\",\n    Ǒ: \"O\",\n    ǒ: \"o\",\n    Ǔ: \"U\",\n    ǔ: \"u\",\n    Ǖ: \"U\",\n    ǖ: \"u\",\n    Ǘ: \"U\",\n    ǘ: \"u\",\n    Ǚ: \"U\",\n    ǚ: \"u\",\n    Ǜ: \"U\",\n    ǜ: \"u\",\n    Ứ: \"U\",\n    ứ: \"u\",\n    Ṹ: \"U\",\n    ṹ: \"u\",\n    Ǻ: \"A\",\n    ǻ: \"a\",\n    Ǽ: \"AE\",\n    ǽ: \"ae\",\n    Ǿ: \"O\",\n    ǿ: \"o\",\n    Þ: \"TH\",\n    þ: \"th\",\n    Ṕ: \"P\",\n    ṕ: \"p\",\n    Ṥ: \"S\",\n    ṥ: \"s\",\n    X́: \"X\",\n    x́: \"x\",\n    Ѓ: \"Г\",\n    ѓ: \"г\",\n    Ќ: \"К\",\n    ќ: \"к\",\n    A̋: \"A\",\n    a̋: \"a\",\n    E̋: \"E\",\n    e̋: \"e\",\n    I̋: \"I\",\n    i̋: \"i\",\n    Ǹ: \"N\",\n    ǹ: \"n\",\n    Ồ: \"O\",\n    ồ: \"o\",\n    Ṑ: \"O\",\n    ṑ: \"o\",\n    Ừ: \"U\",\n    ừ: \"u\",\n    Ẁ: \"W\",\n    ẁ: \"w\",\n    Ỳ: \"Y\",\n    ỳ: \"y\",\n    Ȁ: \"A\",\n    ȁ: \"a\",\n    Ȅ: \"E\",\n    ȅ: \"e\",\n    Ȉ: \"I\",\n    ȉ: \"i\",\n    Ȍ: \"O\",\n    ȍ: \"o\",\n    Ȑ: \"R\",\n    ȑ: \"r\",\n    Ȕ: \"U\",\n    ȕ: \"u\",\n    B̌: \"B\",\n    b̌: \"b\",\n    Č̣: \"C\",\n    č̣: \"c\",\n    Ê̌: \"E\",\n    ê̌: \"e\",\n    F̌: \"F\",\n    f̌: \"f\",\n    Ǧ: \"G\",\n    ǧ: \"g\",\n    Ȟ: \"H\",\n    ȟ: \"h\",\n    J̌: \"J\",\n    ǰ: \"j\",\n    Ǩ: \"K\",\n    ǩ: \"k\",\n    M̌: \"M\",\n    m̌: \"m\",\n    P̌: \"P\",\n    p̌: \"p\",\n    Q̌: \"Q\",\n    q̌: \"q\",\n    Ř̩: \"R\",\n    ř̩: \"r\",\n    Ṧ: \"S\",\n    ṧ: \"s\",\n    V̌: \"V\",\n    v̌: \"v\",\n    W̌: \"W\",\n    w̌: \"w\",\n    X̌: \"X\",\n    x̌: \"x\",\n    Y̌: \"Y\",\n    y̌: \"y\",\n    A̧: \"A\",\n    a̧: \"a\",\n    B̧: \"B\",\n    b̧: \"b\",\n    Ḑ: \"D\",\n    ḑ: \"d\",\n    Ȩ: \"E\",\n    ȩ: \"e\",\n    Ɛ̧: \"E\",\n    ɛ̧: \"e\",\n    Ḩ: \"H\",\n    ḩ: \"h\",\n    I̧: \"I\",\n    i̧: \"i\",\n    Ɨ̧: \"I\",\n    ɨ̧: \"i\",\n    M̧: \"M\",\n    m̧: \"m\",\n    O̧: \"O\",\n    o̧: \"o\",\n    Q̧: \"Q\",\n    q̧: \"q\",\n    U̧: \"U\",\n    u̧: \"u\",\n    X̧: \"X\",\n    x̧: \"x\",\n    Z̧: \"Z\",\n    z̧: \"z\"\n};\nconst chars = Object.keys(characterMap).join(\"|\");\nconst allAccents = new RegExp(chars, \"g\");\nfunction removeAccents(str) {\n    return str.replace(allAccents, (match)=>{\n        return characterMap[match];\n    });\n}\n/**\n * @name match-sorter\n * @license MIT license.\n * @copyright (c) 2099 Kent C. Dodds\n * @author Kent C. Dodds <me@kentcdodds.com> (https://kentcdodds.com)\n */ const rankings = {\n    CASE_SENSITIVE_EQUAL: 7,\n    EQUAL: 6,\n    STARTS_WITH: 5,\n    WORD_STARTS_WITH: 4,\n    CONTAINS: 3,\n    ACRONYM: 2,\n    MATCHES: 1,\n    NO_MATCH: 0\n};\n/**\n * Gets the highest ranking for value for the given item based on its values for the given keys\n * @param {*} item - the item to rank\n * @param {Array} keys - the keys to get values from the item for the ranking\n * @param {String} value - the value to rank against\n * @param {Object} options - options to control the ranking\n * @return {{rank: Number, accessorIndex: Number, accessorThreshold: Number}} - the highest ranking\n */ function rankItem(item, value, options) {\n    var _options$threshold;\n    options = options || {};\n    options.threshold = (_options$threshold = options.threshold) != null ? _options$threshold : rankings.MATCHES;\n    if (!options.accessors) {\n        // if keys is not specified, then we assume the item given is ready to be matched\n        const rank = getMatchRanking(item, value, options);\n        return {\n            // ends up being duplicate of 'item' in matches but consistent\n            rankedValue: item,\n            rank,\n            accessorIndex: -1,\n            accessorThreshold: options.threshold,\n            passed: rank >= options.threshold\n        };\n    }\n    const valuesToRank = getAllValuesToRank(item, options.accessors);\n    const rankingInfo = {\n        rankedValue: item,\n        rank: rankings.NO_MATCH,\n        accessorIndex: -1,\n        accessorThreshold: options.threshold,\n        passed: false\n    };\n    for(let i = 0; i < valuesToRank.length; i++){\n        const rankValue = valuesToRank[i];\n        let newRank = getMatchRanking(rankValue.itemValue, value, options);\n        const { minRanking, maxRanking, threshold = options.threshold } = rankValue.attributes;\n        if (newRank < minRanking && newRank >= rankings.MATCHES) {\n            newRank = minRanking;\n        } else if (newRank > maxRanking) {\n            newRank = maxRanking;\n        }\n        newRank = Math.min(newRank, maxRanking);\n        if (newRank >= threshold && newRank > rankingInfo.rank) {\n            rankingInfo.rank = newRank;\n            rankingInfo.passed = true;\n            rankingInfo.accessorIndex = i;\n            rankingInfo.accessorThreshold = threshold;\n            rankingInfo.rankedValue = rankValue.itemValue;\n        }\n    }\n    return rankingInfo;\n}\n/**\n * Gives a rankings score based on how well the two strings match.\n * @param {String} testString - the string to test against\n * @param {String} stringToRank - the string to rank\n * @param {Object} options - options for the match (like keepDiacritics for comparison)\n * @returns {Number} the ranking for how well stringToRank matches testString\n */ function getMatchRanking(testString, stringToRank, options) {\n    testString = prepareValueForComparison(testString, options);\n    stringToRank = prepareValueForComparison(stringToRank, options);\n    // too long\n    if (stringToRank.length > testString.length) {\n        return rankings.NO_MATCH;\n    }\n    // case sensitive equals\n    if (testString === stringToRank) {\n        return rankings.CASE_SENSITIVE_EQUAL;\n    }\n    // Lower casing before further comparison\n    testString = testString.toLowerCase();\n    stringToRank = stringToRank.toLowerCase();\n    // case insensitive equals\n    if (testString === stringToRank) {\n        return rankings.EQUAL;\n    }\n    // starts with\n    if (testString.startsWith(stringToRank)) {\n        return rankings.STARTS_WITH;\n    }\n    // word starts with\n    if (testString.includes(` ${stringToRank}`)) {\n        return rankings.WORD_STARTS_WITH;\n    }\n    // contains\n    if (testString.includes(stringToRank)) {\n        return rankings.CONTAINS;\n    } else if (stringToRank.length === 1) {\n        // If the only character in the given stringToRank\n        //   isn't even contained in the testString, then\n        //   it's definitely not a match.\n        return rankings.NO_MATCH;\n    }\n    // acronym\n    if (getAcronym(testString).includes(stringToRank)) {\n        return rankings.ACRONYM;\n    }\n    // will return a number between rankings.MATCHES and\n    // rankings.MATCHES + 1 depending  on how close of a match it is.\n    return getClosenessRanking(testString, stringToRank);\n}\n/**\n * Generates an acronym for a string.\n *\n * @param {String} string the string for which to produce the acronym\n * @returns {String} the acronym\n */ function getAcronym(string) {\n    let acronym = \"\";\n    const wordsInString = string.split(\" \");\n    wordsInString.forEach((wordInString)=>{\n        const splitByHyphenWords = wordInString.split(\"-\");\n        splitByHyphenWords.forEach((splitByHyphenWord)=>{\n            acronym += splitByHyphenWord.substr(0, 1);\n        });\n    });\n    return acronym;\n}\n/**\n * Returns a score based on how spread apart the\n * characters from the stringToRank are within the testString.\n * A number close to rankings.MATCHES represents a loose match. A number close\n * to rankings.MATCHES + 1 represents a tighter match.\n * @param {String} testString - the string to test against\n * @param {String} stringToRank - the string to rank\n * @returns {Number} the number between rankings.MATCHES and\n * rankings.MATCHES + 1 for how well stringToRank matches testString\n */ function getClosenessRanking(testString, stringToRank) {\n    let matchingInOrderCharCount = 0;\n    let charNumber = 0;\n    function findMatchingCharacter(matchChar, string, index) {\n        for(let j = index, J = string.length; j < J; j++){\n            const stringChar = string[j];\n            if (stringChar === matchChar) {\n                matchingInOrderCharCount += 1;\n                return j + 1;\n            }\n        }\n        return -1;\n    }\n    function getRanking(spread) {\n        const spreadPercentage = 1 / spread;\n        const inOrderPercentage = matchingInOrderCharCount / stringToRank.length;\n        const ranking = rankings.MATCHES + inOrderPercentage * spreadPercentage;\n        return ranking;\n    }\n    const firstIndex = findMatchingCharacter(stringToRank[0], testString, 0);\n    if (firstIndex < 0) {\n        return rankings.NO_MATCH;\n    }\n    charNumber = firstIndex;\n    for(let i = 1, I = stringToRank.length; i < I; i++){\n        const matchChar = stringToRank[i];\n        charNumber = findMatchingCharacter(matchChar, testString, charNumber);\n        const found = charNumber > -1;\n        if (!found) {\n            return rankings.NO_MATCH;\n        }\n    }\n    const spread = charNumber - firstIndex;\n    return getRanking(spread);\n}\n/**\n * Sorts items that have a rank, index, and accessorIndex\n * @param {Object} a - the first item to sort\n * @param {Object} b - the second item to sort\n * @return {Number} -1 if a should come first, 1 if b should come first, 0 if equal\n */ function compareItems(a, b) {\n    return a.rank === b.rank ? 0 : a.rank > b.rank ? -1 : 1;\n}\n/**\n * Prepares value for comparison by stringifying it, removing diacritics (if specified)\n * @param {String} value - the value to clean\n * @param {Object} options - {keepDiacritics: whether to remove diacritics}\n * @return {String} the prepared value\n */ function prepareValueForComparison(value, _ref) {\n    let { keepDiacritics } = _ref;\n    // value might not actually be a string at this point (we don't get to choose)\n    // so part of preparing the value for comparison is ensure that it is a string\n    value = `${value}`; // toString\n    if (!keepDiacritics) {\n        value = removeAccents(value);\n    }\n    return value;\n}\n/**\n * Gets value for key in item at arbitrarily nested keypath\n * @param {Object} item - the item\n * @param {Object|Function} key - the potentially nested keypath or property callback\n * @return {Array} - an array containing the value(s) at the nested keypath\n */ function getItemValues(item, accessor) {\n    let accessorFn = accessor;\n    if (typeof accessor === \"object\") {\n        accessorFn = accessor.accessor;\n    }\n    const value = accessorFn(item);\n    // because `value` can also be undefined\n    if (value == null) {\n        return [];\n    }\n    if (Array.isArray(value)) {\n        return value;\n    }\n    return [\n        String(value)\n    ];\n}\n/**\n * Gets all the values for the given keys in the given item and returns an array of those values\n * @param item - the item from which the values will be retrieved\n * @param keys - the keys to use to retrieve the values\n * @return objects with {itemValue, attributes}\n */ function getAllValuesToRank(item, accessors) {\n    const allValues = [];\n    for(let j = 0, J = accessors.length; j < J; j++){\n        const accessor = accessors[j];\n        const attributes = getAccessorAttributes(accessor);\n        const itemValues = getItemValues(item, accessor);\n        for(let i = 0, I = itemValues.length; i < I; i++){\n            allValues.push({\n                itemValue: itemValues[i],\n                attributes\n            });\n        }\n    }\n    return allValues;\n}\nconst defaultKeyAttributes = {\n    maxRanking: Infinity,\n    minRanking: -Infinity\n};\n/**\n * Gets all the attributes for the given accessor\n * @param accessor - the accessor from which the attributes will be retrieved\n * @return object containing the accessor's attributes\n */ function getAccessorAttributes(accessor) {\n    if (typeof accessor === \"function\") {\n        return defaultKeyAttributes;\n    }\n    return {\n        ...defaultKeyAttributes,\n        ...accessor\n    };\n}\n //# sourceMappingURL=index.mjs.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQHRhbnN0YWNrL21hdGNoLXNvcnRlci11dGlscy9idWlsZC9saWIvaW5kZXgubWpzIiwibWFwcGluZ3MiOiI7Ozs7OztBQUFBOzs7Ozs7Ozs7Q0FTQyxHQUNELE1BQU1BLGVBQWU7SUFDbkJDLEdBQUc7SUFDSEMsR0FBRztJQUNIQyxHQUFHO0lBQ0hDLEdBQUc7SUFDSEMsR0FBRztJQUNIQyxHQUFHO0lBQ0hDLEdBQUc7SUFDSEMsR0FBRztJQUNIQyxHQUFHO0lBQ0hDLEdBQUc7SUFDSEMsR0FBRztJQUNIQyxHQUFHO0lBQ0hDLEdBQUc7SUFDSEMsR0FBRztJQUNIQyxHQUFHO0lBQ0hDLEdBQUc7SUFDSEMsR0FBRztJQUNIQyxHQUFHO0lBQ0hDLEdBQUc7SUFDSEMsR0FBRztJQUNIQyxHQUFHO0lBQ0hDLEdBQUc7SUFDSEMsR0FBRztJQUNIQyxHQUFHO0lBQ0hDLEdBQUc7SUFDSEMsR0FBRztJQUNIQyxHQUFHO0lBQ0hDLEdBQUc7SUFDSEMsR0FBRztJQUNIQyxHQUFHO0lBQ0hDLEdBQUc7SUFDSEMsR0FBRztJQUNIQyxHQUFHO0lBQ0hDLEdBQUc7SUFDSEMsR0FBRztJQUNIQyxHQUFHO0lBQ0hDLEdBQUc7SUFDSEMsR0FBRztJQUNIQyxHQUFHO0lBQ0hDLEdBQUc7SUFDSEMsR0FBRztJQUNIQyxHQUFHO0lBQ0hDLEdBQUc7SUFDSEMsR0FBRztJQUNIQyxHQUFHO0lBQ0hDLEdBQUc7SUFDSEMsR0FBRztJQUNIQyxHQUFHO0lBQ0hDLEdBQUc7SUFDSEMsR0FBRztJQUNIQyxHQUFHO0lBQ0hDLEdBQUc7SUFDSEMsR0FBRztJQUNIQyxHQUFHO0lBQ0hDLEdBQUc7SUFDSEMsR0FBRztJQUNIQyxHQUFHO0lBQ0hDLEdBQUc7SUFDSEMsR0FBRztJQUNIQyxHQUFHO0lBQ0hDLEdBQUc7SUFDSEMsR0FBRztJQUNIQyxHQUFHO0lBQ0hDLEdBQUc7SUFDSEMsR0FBRztJQUNIQyxHQUFHO0lBQ0hDLEdBQUc7SUFDSEMsR0FBRztJQUNIQyxHQUFHO0lBQ0hDLEdBQUc7SUFDSEMsR0FBRztJQUNIQyxHQUFHO0lBQ0hDLEdBQUc7SUFDSEMsR0FBRztJQUNIQyxHQUFHO0lBQ0hDLEdBQUc7SUFDSEMsR0FBRztJQUNIQyxHQUFHO0lBQ0hDLEdBQUc7SUFDSEMsR0FBRztJQUNIQyxHQUFHO0lBQ0hDLEdBQUc7SUFDSEMsR0FBRztJQUNIQyxHQUFHO0lBQ0hDLEdBQUc7SUFDSEMsR0FBRztJQUNIQyxHQUFHO0lBQ0hDLEdBQUc7SUFDSEMsR0FBRztJQUNIQyxHQUFHO0lBQ0hDLEdBQUc7SUFDSEMsR0FBRztJQUNIQyxHQUFHO0lBQ0hDLEdBQUc7SUFDSEMsR0FBRztJQUNIQyxHQUFHO0lBQ0hDLEdBQUc7SUFDSEMsR0FBRztJQUNIQyxHQUFHO0lBQ0hDLEdBQUc7SUFDSEMsR0FBRztJQUNIQyxHQUFHO0lBQ0hDLEdBQUc7SUFDSEMsR0FBRztJQUNIQyxHQUFHO0lBQ0hDLEdBQUc7SUFDSEMsR0FBRztJQUNIQyxHQUFHO0lBQ0hDLEdBQUc7SUFDSEMsR0FBRztJQUNIQyxHQUFHO0lBQ0hDLEdBQUc7SUFDSEMsR0FBRztJQUNIQyxHQUFHO0lBQ0hDLEdBQUc7SUFDSEMsSUFBSTtJQUNKQyxJQUFJO0lBQ0pDLEdBQUc7SUFDSEMsR0FBRztJQUNIQyxHQUFHO0lBQ0hDLEdBQUc7SUFDSEMsR0FBRztJQUNIQyxHQUFHO0lBQ0hDLEdBQUc7SUFDSEMsR0FBRztJQUNIQyxHQUFHO0lBQ0hDLEdBQUc7SUFDSEMsR0FBRztJQUNIQyxHQUFHO0lBQ0hDLEdBQUc7SUFDSEMsR0FBRztJQUNIQyxHQUFHO0lBQ0hDLEdBQUc7SUFDSEMsR0FBRztJQUNIQyxHQUFHO0lBQ0hDLEdBQUc7SUFDSEMsR0FBRztJQUNIQyxHQUFHO0lBQ0hDLEdBQUc7SUFDSEMsR0FBRztJQUNIQyxHQUFHO0lBQ0hDLEdBQUc7SUFDSEMsR0FBRztJQUNIQyxHQUFHO0lBQ0hDLEdBQUc7SUFDSEMsR0FBRztJQUNIQyxHQUFHO0lBQ0hDLEdBQUc7SUFDSEMsR0FBRztJQUNIQyxHQUFHO0lBQ0hDLEdBQUc7SUFDSEMsR0FBRztJQUNIQyxHQUFHO0lBQ0hDLEdBQUc7SUFDSEMsR0FBRztJQUNIQyxHQUFHO0lBQ0hDLEdBQUc7SUFDSEMsR0FBRztJQUNIQyxHQUFHO0lBQ0hDLEdBQUc7SUFDSEMsR0FBRztJQUNIQyxHQUFHO0lBQ0hDLEdBQUc7SUFDSEMsR0FBRztJQUNIQyxHQUFHO0lBQ0hDLElBQUk7SUFDSkMsSUFBSTtJQUNKQyxHQUFHO0lBQ0hDLEdBQUc7SUFDSEMsR0FBRztJQUNIQyxHQUFHO0lBQ0hDLEdBQUc7SUFDSEMsR0FBRztJQUNIQyxHQUFHO0lBQ0hDLEdBQUc7SUFDSEMsR0FBRztJQUNIQyxHQUFHO0lBQ0hDLEdBQUc7SUFDSEMsR0FBRztJQUNIQyxJQUFJO0lBQ0pDLElBQUk7SUFDSkMsR0FBRztJQUNIQyxHQUFHO0lBQ0hDLEdBQUc7SUFDSEMsR0FBRztJQUNIQyxHQUFHO0lBQ0hDLEdBQUc7SUFDSEMsR0FBRztJQUNIQyxJQUFJO0lBQ0pDLElBQUk7SUFDSkMsR0FBRztJQUNIQyxHQUFHO0lBQ0hDLEdBQUc7SUFDSEMsR0FBRztJQUNIQyxHQUFHO0lBQ0hDLEdBQUc7SUFDSEMsR0FBRztJQUNIQyxHQUFHO0lBQ0hDLElBQUk7SUFDSkMsSUFBSTtJQUNKQyxHQUFHO0lBQ0hDLEdBQUc7SUFDSEMsR0FBRztJQUNIQyxHQUFHO0lBQ0hDLEdBQUc7SUFDSEMsR0FBRztJQUNIQyxJQUFJO0lBQ0pDLElBQUk7SUFDSkMsR0FBRztJQUNIQyxHQUFHO0lBQ0hDLEdBQUc7SUFDSEMsR0FBRztJQUNIQyxHQUFHO0lBQ0hDLEdBQUc7SUFDSEMsR0FBRztJQUNIQyxHQUFHO0lBQ0hDLEdBQUc7SUFDSEMsR0FBRztJQUNIQyxHQUFHO0lBQ0hDLEdBQUc7SUFDSEMsR0FBRztJQUNIQyxHQUFHO0lBQ0hDLEdBQUc7SUFDSEMsR0FBRztJQUNIQyxHQUFHO0lBQ0hDLEdBQUc7SUFDSEMsR0FBRztJQUNIQyxHQUFHO0lBQ0hDLElBQUk7SUFDSkMsSUFBSTtJQUNKQyxHQUFHO0lBQ0hDLEdBQUc7SUFDSEMsR0FBRztJQUNIQyxHQUFHO0lBQ0hDLEdBQUc7SUFDSEMsR0FBRztJQUNIQyxHQUFHO0lBQ0hDLEdBQUc7SUFDSEMsR0FBRztJQUNIQyxHQUFHO0lBQ0hDLEdBQUc7SUFDSEMsR0FBRztJQUNIQyxHQUFHO0lBQ0hDLEdBQUc7SUFDSEMsSUFBSTtJQUNKQyxJQUFJO0lBQ0pDLEdBQUc7SUFDSEMsR0FBRztJQUNIQyxHQUFHO0lBQ0hDLEdBQUc7SUFDSEMsSUFBSTtJQUNKQyxJQUFJO0lBQ0pDLEdBQUc7SUFDSEMsR0FBRztJQUNIQyxHQUFHO0lBQ0hDLElBQUk7SUFDSkMsSUFBSTtJQUNKQyxHQUFHO0lBQ0hDLEdBQUc7SUFDSEMsR0FBRztJQUNIQyxHQUFHO0lBQ0hDLEdBQUc7SUFDSEMsR0FBRztJQUNIQyxHQUFHO0lBQ0hDLEdBQUc7SUFDSEMsR0FBRztJQUNIQyxHQUFHO0lBQ0hDLEdBQUc7SUFDSEMsR0FBRztJQUNIQyxHQUFHO0lBQ0hDLEdBQUc7SUFDSEMsR0FBRztJQUNIQyxHQUFHO0lBQ0hDLEdBQUc7SUFDSEMsR0FBRztJQUNIQyxHQUFHO0lBQ0hDLEdBQUc7SUFDSEMsR0FBRztJQUNIQyxHQUFHO0lBQ0hDLEdBQUc7SUFDSEMsR0FBRztJQUNIQyxHQUFHO0lBQ0hDLEdBQUc7SUFDSEMsR0FBRztJQUNIQyxHQUFHO0lBQ0hDLEdBQUc7SUFDSEMsR0FBRztJQUNIQyxHQUFHO0lBQ0hDLEdBQUc7SUFDSEMsR0FBRztJQUNIQyxHQUFHO0lBQ0hDLEdBQUc7SUFDSEMsR0FBRztJQUNIQyxHQUFHO0lBQ0hDLEdBQUc7SUFDSEMsR0FBRztJQUNIQyxHQUFHO0lBQ0hDLEdBQUc7SUFDSEMsR0FBRztJQUNIQyxHQUFHO0lBQ0hDLEdBQUc7SUFDSEMsSUFBSTtJQUNKQyxJQUFJO0lBQ0pDLEdBQUc7SUFDSEMsR0FBRztJQUNIQyxHQUFHO0lBQ0hDLEdBQUc7SUFDSEMsSUFBSTtJQUNKQyxJQUFJO0lBQ0pDLElBQUk7SUFDSkMsSUFBSTtJQUNKQyxJQUFJO0lBQ0pDLElBQUk7SUFDSkMsR0FBRztJQUNIQyxHQUFHO0lBQ0hDLEdBQUc7SUFDSEMsR0FBRztJQUNIQyxHQUFHO0lBQ0hDLEdBQUc7SUFDSEMsR0FBRztJQUNIQyxHQUFHO0lBQ0hDLEdBQUc7SUFDSEMsR0FBRztJQUNIQyxHQUFHO0lBQ0hDLEdBQUc7SUFDSEMsR0FBRztJQUNIQyxHQUFHO0lBQ0hDLEdBQUc7SUFDSEMsR0FBRztJQUNIQyxHQUFHO0lBQ0hDLEdBQUc7SUFDSEMsR0FBRztJQUNIQyxHQUFHO0lBQ0hDLEdBQUc7SUFDSEMsR0FBRztJQUNIQyxHQUFHO0lBQ0hDLEdBQUc7SUFDSEMsSUFBSTtJQUNKQyxJQUFJO0lBQ0pDLElBQUk7SUFDSkMsSUFBSTtJQUNKQyxJQUFJO0lBQ0pDLElBQUk7SUFDSkMsSUFBSTtJQUNKQyxJQUFJO0lBQ0pDLEdBQUc7SUFDSEMsR0FBRztJQUNIQyxHQUFHO0lBQ0hDLEdBQUc7SUFDSEMsSUFBSTtJQUNKQyxHQUFHO0lBQ0hDLEdBQUc7SUFDSEMsR0FBRztJQUNIQyxJQUFJO0lBQ0pDLElBQUk7SUFDSkMsSUFBSTtJQUNKQyxJQUFJO0lBQ0pDLElBQUk7SUFDSkMsSUFBSTtJQUNKQyxJQUFJO0lBQ0pDLElBQUk7SUFDSkMsR0FBRztJQUNIQyxHQUFHO0lBQ0hDLElBQUk7SUFDSkMsSUFBSTtJQUNKQyxJQUFJO0lBQ0pDLElBQUk7SUFDSkMsSUFBSTtJQUNKQyxJQUFJO0lBQ0pDLElBQUk7SUFDSkMsSUFBSTtJQUNKQyxJQUFJO0lBQ0pDLElBQUk7SUFDSkMsSUFBSTtJQUNKQyxJQUFJO0lBQ0pDLEdBQUc7SUFDSEMsR0FBRztJQUNIQyxHQUFHO0lBQ0hDLEdBQUc7SUFDSEMsSUFBSTtJQUNKQyxJQUFJO0lBQ0pDLEdBQUc7SUFDSEMsR0FBRztJQUNIQyxJQUFJO0lBQ0pDLElBQUk7SUFDSkMsSUFBSTtJQUNKQyxJQUFJO0lBQ0pDLElBQUk7SUFDSkMsSUFBSTtJQUNKQyxJQUFJO0lBQ0pDLElBQUk7SUFDSkMsSUFBSTtJQUNKQyxJQUFJO0lBQ0pDLElBQUk7SUFDSkMsSUFBSTtJQUNKQyxJQUFJ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QUFVLENBQUN4RCxFQUFFO2dCQUN4Qk87WUFDRjtRQUNGO0lBQ0Y7SUFDQSxPQUFPK0M7QUFDVDtBQUNBLE1BQU1JLHVCQUF1QjtJQUMzQnBELFlBQVlxRDtJQUNadEQsWUFBWSxDQUFDc0Q7QUFDZjtBQUNBOzs7O0NBSUMsR0FDRCxTQUFTSixzQkFBc0JOLFFBQVE7SUFDckMsSUFBSSxPQUFPQSxhQUFhLFlBQVk7UUFDbEMsT0FBT1M7SUFDVDtJQUNBLE9BQU87UUFDTCxHQUFHQSxvQkFBb0I7UUFDdkIsR0FBR1QsUUFBUTtJQUNiO0FBQ0Y7QUFFNEMsQ0FDNUMsa0NBQWtDIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vdmlzaW9uLy4vbm9kZV9tb2R1bGVzL0B0YW5zdGFjay9tYXRjaC1zb3J0ZXItdXRpbHMvYnVpbGQvbGliL2luZGV4Lm1qcz9iMmJkIl0sInNvdXJjZXNDb250ZW50IjpbIi8qKlxuICogbWF0Y2gtc29ydGVyLXV0aWxzXG4gKlxuICogQ29weXJpZ2h0IChjKSBUYW5TdGFja1xuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIE1JVCBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRS5tZCBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLlxuICpcbiAqIEBsaWNlbnNlIE1JVFxuICovXG5jb25zdCBjaGFyYWN0ZXJNYXAgPSB7XG4gIMOAOiAnQScsXG4gIMOBOiAnQScsXG4gIMOCOiAnQScsXG4gIMODOiAnQScsXG4gIMOEOiAnQScsXG4gIMOFOiAnQScsXG4gIOG6pDogJ0EnLFxuICDhuq46ICdBJyxcbiAg4bqyOiAnQScsXG4gIOG6tDogJ0EnLFxuICDhurY6ICdBJyxcbiAgw4Y6ICdBRScsXG4gIOG6pjogJ0EnLFxuICDhurA6ICdBJyxcbiAgyII6ICdBJyxcbiAgw4c6ICdDJyxcbiAg4biIOiAnQycsXG4gIMOIOiAnRScsXG4gIMOJOiAnRScsXG4gIMOKOiAnRScsXG4gIMOLOiAnRScsXG4gIOG6vjogJ0UnLFxuICDhuJY6ICdFJyxcbiAg4buAOiAnRScsXG4gIOG4lDogJ0UnLFxuICDhuJw6ICdFJyxcbiAgyIY6ICdFJyxcbiAgw4w6ICdJJyxcbiAgw406ICdJJyxcbiAgw446ICdJJyxcbiAgw486ICdJJyxcbiAg4biuOiAnSScsXG4gIMiKOiAnSScsXG4gIMOQOiAnRCcsXG4gIMOROiAnTicsXG4gIMOSOiAnTycsXG4gIMOTOiAnTycsXG4gIMOUOiAnTycsXG4gIMOVOiAnTycsXG4gIMOWOiAnTycsXG4gIMOYOiAnTycsXG4gIOG7kDogJ08nLFxuICDhuYw6ICdPJyxcbiAg4bmSOiAnTycsXG4gIMiOOiAnTycsXG4gIMOZOiAnVScsXG4gIMOaOiAnVScsXG4gIMObOiAnVScsXG4gIMOcOiAnVScsXG4gIMOdOiAnWScsXG4gIMOgOiAnYScsXG4gIMOhOiAnYScsXG4gIMOiOiAnYScsXG4gIMOjOiAnYScsXG4gIMOkOiAnYScsXG4gIMOlOiAnYScsXG4gIOG6pTogJ2EnLFxuICDhuq86ICdhJyxcbiAg4bqzOiAnYScsXG4gIOG6tTogJ2EnLFxuICDhurc6ICdhJyxcbiAgw6Y6ICdhZScsXG4gIOG6pzogJ2EnLFxuICDhurE6ICdhJyxcbiAgyIM6ICdhJyxcbiAgw6c6ICdjJyxcbiAg4biJOiAnYycsXG4gIMOoOiAnZScsXG4gIMOpOiAnZScsXG4gIMOqOiAnZScsXG4gIMOrOiAnZScsXG4gIOG6vzogJ2UnLFxuICDhuJc6ICdlJyxcbiAg4buBOiAnZScsXG4gIOG4lTogJ2UnLFxuICDhuJ06ICdlJyxcbiAgyIc6ICdlJyxcbiAgw6w6ICdpJyxcbiAgw606ICdpJyxcbiAgw646ICdpJyxcbiAgw686ICdpJyxcbiAg4bivOiAnaScsXG4gIMiLOiAnaScsXG4gIMOwOiAnZCcsXG4gIMOxOiAnbicsXG4gIMOyOiAnbycsXG4gIMOzOiAnbycsXG4gIMO0OiAnbycsXG4gIMO1OiAnbycsXG4gIMO2OiAnbycsXG4gIMO4OiAnbycsXG4gIOG7kTogJ28nLFxuICDhuY06ICdvJyxcbiAg4bmTOiAnbycsXG4gIMiPOiAnbycsXG4gIMO5OiAndScsXG4gIMO6OiAndScsXG4gIMO7OiAndScsXG4gIMO8OiAndScsXG4gIMO9OiAneScsXG4gIMO/OiAneScsXG4gIMSAOiAnQScsXG4gIMSBOiAnYScsXG4gIMSCOiAnQScsXG4gIMSDOiAnYScsXG4gIMSEOiAnQScsXG4gIMSFOiAnYScsXG4gIMSGOiAnQycsXG4gIMSHOiAnYycsXG4gIMSIOiAnQycsXG4gIMSJOiAnYycsXG4gIMSKOiAnQycsXG4gIMSLOiAnYycsXG4gIMSMOiAnQycsXG4gIMSNOiAnYycsXG4gIEPMhjogJ0MnLFxuICBjzIY6ICdjJyxcbiAgxI46ICdEJyxcbiAgxI86ICdkJyxcbiAgxJA6ICdEJyxcbiAgxJE6ICdkJyxcbiAgxJI6ICdFJyxcbiAgxJM6ICdlJyxcbiAgxJQ6ICdFJyxcbiAgxJU6ICdlJyxcbiAgxJY6ICdFJyxcbiAgxJc6ICdlJyxcbiAgxJg6ICdFJyxcbiAgxJk6ICdlJyxcbiAgxJo6ICdFJyxcbiAgxJs6ICdlJyxcbiAgxJw6ICdHJyxcbiAgx7Q6ICdHJyxcbiAgxJ06ICdnJyxcbiAgx7U6ICdnJyxcbiAgxJ46ICdHJyxcbiAgxJ86ICdnJyxcbiAgxKA6ICdHJyxcbiAgxKE6ICdnJyxcbiAgxKI6ICdHJyxcbiAgxKM6ICdnJyxcbiAgxKQ6ICdIJyxcbiAgxKU6ICdoJyxcbiAgxKY6ICdIJyxcbiAgxKc6ICdoJyxcbiAg4biqOiAnSCcsXG4gIOG4qzogJ2gnLFxuICDEqDogJ0knLFxuICDEqTogJ2knLFxuICDEqjogJ0knLFxuICDEqzogJ2knLFxuICDErDogJ0knLFxuICDErTogJ2knLFxuICDErjogJ0knLFxuICDErzogJ2knLFxuICDEsDogJ0knLFxuICDEsTogJ2knLFxuICDEsjogJ0lKJyxcbiAgxLM6ICdpaicsXG4gIMS0OiAnSicsXG4gIMS1OiAnaicsXG4gIMS2OiAnSycsXG4gIMS3OiAnaycsXG4gIOG4sDogJ0snLFxuICDhuLE6ICdrJyxcbiAgS8yGOiAnSycsXG4gIGvMhjogJ2snLFxuICDEuTogJ0wnLFxuICDEujogJ2wnLFxuICDEuzogJ0wnLFxuICDEvDogJ2wnLFxuICDEvTogJ0wnLFxuICDEvjogJ2wnLFxuICDEvzogJ0wnLFxuICDFgDogJ2wnLFxuICDFgTogJ2wnLFxuICDFgjogJ2wnLFxuICDhuL46ICdNJyxcbiAg4bi/OiAnbScsXG4gIE3MhjogJ00nLFxuICBtzIY6ICdtJyxcbiAgxYM6ICdOJyxcbiAgxYQ6ICduJyxcbiAgxYU6ICdOJyxcbiAgxYY6ICduJyxcbiAgxYc6ICdOJyxcbiAgxYg6ICduJyxcbiAgxYk6ICduJyxcbiAgTsyGOiAnTicsXG4gIG7MhjogJ24nLFxuICDFjDogJ08nLFxuICDFjTogJ28nLFxuICDFjjogJ08nLFxuICDFjzogJ28nLFxuICDFkDogJ08nLFxuICDFkTogJ28nLFxuICDFkjogJ09FJyxcbiAgxZM6ICdvZScsXG4gIFDMhjogJ1AnLFxuICBwzIY6ICdwJyxcbiAgxZQ6ICdSJyxcbiAgxZU6ICdyJyxcbiAgxZY6ICdSJyxcbiAgxZc6ICdyJyxcbiAgxZg6ICdSJyxcbiAgxZk6ICdyJyxcbiAgUsyGOiAnUicsXG4gIHLMhjogJ3InLFxuICDIkjogJ1InLFxuICDIkzogJ3InLFxuICDFmjogJ1MnLFxuICDFmzogJ3MnLFxuICDFnDogJ1MnLFxuICDFnTogJ3MnLFxuICDFnjogJ1MnLFxuICDImDogJ1MnLFxuICDImTogJ3MnLFxuICDFnzogJ3MnLFxuICDFoDogJ1MnLFxuICDFoTogJ3MnLFxuICDFojogJ1QnLFxuICDFozogJ3QnLFxuICDImzogJ3QnLFxuICDImjogJ1QnLFxuICDFpDogJ1QnLFxuICDFpTogJ3QnLFxuICDFpjogJ1QnLFxuICDFpzogJ3QnLFxuICBUzIY6ICdUJyxcbiAgdMyGOiAndCcsXG4gIMWoOiAnVScsXG4gIMWpOiAndScsXG4gIMWqOiAnVScsXG4gIMWrOiAndScsXG4gIMWsOiAnVScsXG4gIMWtOiAndScsXG4gIMWuOiAnVScsXG4gIMWvOiAndScsXG4gIMWwOiAnVScsXG4gIMWxOiAndScsXG4gIMWyOiAnVScsXG4gIMWzOiAndScsXG4gIMiWOiAnVScsXG4gIMiXOiAndScsXG4gIFbMhjogJ1YnLFxuICB2zIY6ICd2JyxcbiAgxbQ6ICdXJyxcbiAgxbU6ICd3JyxcbiAg4bqCOiAnVycsXG4gIOG6gzogJ3cnLFxuICBYzIY6ICdYJyxcbiAgeMyGOiAneCcsXG4gIMW2OiAnWScsXG4gIMW3OiAneScsXG4gIMW4OiAnWScsXG4gIFnMhjogJ1knLFxuICB5zIY6ICd5JyxcbiAgxbk6ICdaJyxcbiAgxbo6ICd6JyxcbiAgxbs6ICdaJyxcbiAgxbw6ICd6JyxcbiAgxb06ICdaJyxcbiAgxb46ICd6JyxcbiAgxb86ICdzJyxcbiAgxpI6ICdmJyxcbiAgxqA6ICdPJyxcbiAgxqE6ICdvJyxcbiAgxq86ICdVJyxcbiAgxrA6ICd1JyxcbiAgx406ICdBJyxcbiAgx446ICdhJyxcbiAgx486ICdJJyxcbiAgx5A6ICdpJyxcbiAgx5E6ICdPJyxcbiAgx5I6ICdvJyxcbiAgx5M6ICdVJyxcbiAgx5Q6ICd1JyxcbiAgx5U6ICdVJyxcbiAgx5Y6ICd1JyxcbiAgx5c6ICdVJyxcbiAgx5g6ICd1JyxcbiAgx5k6ICdVJyxcbiAgx5o6ICd1JyxcbiAgx5s6ICdVJyxcbiAgx5w6ICd1JyxcbiAg4buoOiAnVScsXG4gIOG7qTogJ3UnLFxuICDhubg6ICdVJyxcbiAg4bm5OiAndScsXG4gIMe6OiAnQScsXG4gIMe7OiAnYScsXG4gIMe8OiAnQUUnLFxuICDHvTogJ2FlJyxcbiAgx746ICdPJyxcbiAgx786ICdvJyxcbiAgw546ICdUSCcsXG4gIMO+OiAndGgnLFxuICDhuZQ6ICdQJyxcbiAg4bmVOiAncCcsXG4gIOG5pDogJ1MnLFxuICDhuaU6ICdzJyxcbiAgWMyBOiAnWCcsXG4gIHjMgTogJ3gnLFxuICDQgzogJ9CTJyxcbiAg0ZM6ICfQsycsXG4gINCMOiAn0JonLFxuICDRnDogJ9C6JyxcbiAgQcyLOiAnQScsXG4gIGHMizogJ2EnLFxuICBFzIs6ICdFJyxcbiAgZcyLOiAnZScsXG4gIEnMizogJ0knLFxuICBpzIs6ICdpJyxcbiAgx7g6ICdOJyxcbiAgx7k6ICduJyxcbiAg4buSOiAnTycsXG4gIOG7kzogJ28nLFxuICDhuZA6ICdPJyxcbiAg4bmROiAnbycsXG4gIOG7qjogJ1UnLFxuICDhu6s6ICd1JyxcbiAg4bqAOiAnVycsXG4gIOG6gTogJ3cnLFxuICDhu7I6ICdZJyxcbiAg4buzOiAneScsXG4gIMiAOiAnQScsXG4gIMiBOiAnYScsXG4gIMiEOiAnRScsXG4gIMiFOiAnZScsXG4gIMiIOiAnSScsXG4gIMiJOiAnaScsXG4gIMiMOiAnTycsXG4gIMiNOiAnbycsXG4gIMiQOiAnUicsXG4gIMiROiAncicsXG4gIMiUOiAnVScsXG4gIMiVOiAndScsXG4gIELMjDogJ0InLFxuICBizIw6ICdiJyxcbiAgxIzMozogJ0MnLFxuICDEjcyjOiAnYycsXG4gIMOKzIw6ICdFJyxcbiAgw6rMjDogJ2UnLFxuICBGzIw6ICdGJyxcbiAgZsyMOiAnZicsXG4gIMemOiAnRycsXG4gIMenOiAnZycsXG4gIMieOiAnSCcsXG4gIMifOiAnaCcsXG4gIErMjDogJ0onLFxuICDHsDogJ2onLFxuICDHqDogJ0snLFxuICDHqTogJ2snLFxuICBNzIw6ICdNJyxcbiAgbcyMOiAnbScsXG4gIFDMjDogJ1AnLFxuICBwzIw6ICdwJyxcbiAgUcyMOiAnUScsXG4gIHHMjDogJ3EnLFxuICDFmMypOiAnUicsXG4gIMWZzKk6ICdyJyxcbiAg4bmmOiAnUycsXG4gIOG5pzogJ3MnLFxuICBWzIw6ICdWJyxcbiAgdsyMOiAndicsXG4gIFfMjDogJ1cnLFxuICB3zIw6ICd3JyxcbiAgWMyMOiAnWCcsXG4gIHjMjDogJ3gnLFxuICBZzIw6ICdZJyxcbiAgecyMOiAneScsXG4gIEHMpzogJ0EnLFxuICBhzKc6ICdhJyxcbiAgQsynOiAnQicsXG4gIGLMpzogJ2InLFxuICDhuJA6ICdEJyxcbiAg4biROiAnZCcsXG4gIMioOiAnRScsXG4gIMipOiAnZScsXG4gIMaQzKc6ICdFJyxcbiAgyZvMpzogJ2UnLFxuICDhuKg6ICdIJyxcbiAg4bipOiAnaCcsXG4gIEnMpzogJ0knLFxuICBpzKc6ICdpJyxcbiAgxpfMpzogJ0knLFxuICDJqMynOiAnaScsXG4gIE3MpzogJ00nLFxuICBtzKc6ICdtJyxcbiAgT8ynOiAnTycsXG4gIG/MpzogJ28nLFxuICBRzKc6ICdRJyxcbiAgccynOiAncScsXG4gIFXMpzogJ1UnLFxuICB1zKc6ICd1JyxcbiAgWMynOiAnWCcsXG4gIHjMpzogJ3gnLFxuICBazKc6ICdaJyxcbiAgesynOiAneidcbn07XG5jb25zdCBjaGFycyA9IE9iamVjdC5rZXlzKGNoYXJhY3Rlck1hcCkuam9pbignfCcpO1xuY29uc3QgYWxsQWNjZW50cyA9IG5ldyBSZWdFeHAoY2hhcnMsICdnJyk7XG5mdW5jdGlvbiByZW1vdmVBY2NlbnRzKHN0cikge1xuICByZXR1cm4gc3RyLnJlcGxhY2UoYWxsQWNjZW50cywgbWF0Y2ggPT4ge1xuICAgIHJldHVybiBjaGFyYWN0ZXJNYXBbbWF0Y2hdO1xuICB9KTtcbn1cblxuLyoqXG4gKiBAbmFtZSBtYXRjaC1zb3J0ZXJcbiAqIEBsaWNlbnNlIE1JVCBsaWNlbnNlLlxuICogQGNvcHlyaWdodCAoYykgMjA5OSBLZW50IEMuIERvZGRzXG4gKiBAYXV0aG9yIEtlbnQgQy4gRG9kZHMgPG1lQGtlbnRjZG9kZHMuY29tPiAoaHR0cHM6Ly9rZW50Y2RvZGRzLmNvbSlcbiAqL1xuY29uc3QgcmFua2luZ3MgPSB7XG4gIENBU0VfU0VOU0lUSVZFX0VRVUFMOiA3LFxuICBFUVVBTDogNixcbiAgU1RBUlRTX1dJVEg6IDUsXG4gIFdPUkRfU1RBUlRTX1dJVEg6IDQsXG4gIENPTlRBSU5TOiAzLFxuICBBQ1JPTllNOiAyLFxuICBNQVRDSEVTOiAxLFxuICBOT19NQVRDSDogMFxufTtcbi8qKlxuICogR2V0cyB0aGUgaGlnaGVzdCByYW5raW5nIGZvciB2YWx1ZSBmb3IgdGhlIGdpdmVuIGl0ZW0gYmFzZWQgb24gaXRzIHZhbHVlcyBmb3IgdGhlIGdpdmVuIGtleXNcbiAqIEBwYXJhbSB7Kn0gaXRlbSAtIHRoZSBpdGVtIHRvIHJhbmtcbiAqIEBwYXJhbSB7QXJyYXl9IGtleXMgLSB0aGUga2V5cyB0byBnZXQgdmFsdWVzIGZyb20gdGhlIGl0ZW0gZm9yIHRoZSByYW5raW5nXG4gKiBAcGFyYW0ge1N0cmluZ30gdmFsdWUgLSB0aGUgdmFsdWUgdG8gcmFuayBhZ2FpbnN0XG4gKiBAcGFyYW0ge09iamVjdH0gb3B0aW9ucyAtIG9wdGlvbnMgdG8gY29udHJvbCB0aGUgcmFua2luZ1xuICogQHJldHVybiB7e3Jhbms6IE51bWJlciwgYWNjZXNzb3JJbmRleDogTnVtYmVyLCBhY2Nlc3NvclRocmVzaG9sZDogTnVtYmVyfX0gLSB0aGUgaGlnaGVzdCByYW5raW5nXG4gKi9cbmZ1bmN0aW9uIHJhbmtJdGVtKGl0ZW0sIHZhbHVlLCBvcHRpb25zKSB7XG4gIHZhciBfb3B0aW9ucyR0aHJlc2hvbGQ7XG4gIG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xuICBvcHRpb25zLnRocmVzaG9sZCA9IChfb3B0aW9ucyR0aHJlc2hvbGQgPSBvcHRpb25zLnRocmVzaG9sZCkgIT0gbnVsbCA/IF9vcHRpb25zJHRocmVzaG9sZCA6IHJhbmtpbmdzLk1BVENIRVM7XG4gIGlmICghb3B0aW9ucy5hY2Nlc3NvcnMpIHtcbiAgICAvLyBpZiBrZXlzIGlzIG5vdCBzcGVjaWZpZWQsIHRoZW4gd2UgYXNzdW1lIHRoZSBpdGVtIGdpdmVuIGlzIHJlYWR5IHRvIGJlIG1hdGNoZWRcbiAgICBjb25zdCByYW5rID0gZ2V0TWF0Y2hSYW5raW5nKGl0ZW0sIHZhbHVlLCBvcHRpb25zKTtcbiAgICByZXR1cm4ge1xuICAgICAgLy8gZW5kcyB1cCBiZWluZyBkdXBsaWNhdGUgb2YgJ2l0ZW0nIGluIG1hdGNoZXMgYnV0IGNvbnNpc3RlbnRcbiAgICAgIHJhbmtlZFZhbHVlOiBpdGVtLFxuICAgICAgcmFuayxcbiAgICAgIGFjY2Vzc29ySW5kZXg6IC0xLFxuICAgICAgYWNjZXNzb3JUaHJlc2hvbGQ6IG9wdGlvbnMudGhyZXNob2xkLFxuICAgICAgcGFzc2VkOiByYW5rID49IG9wdGlvbnMudGhyZXNob2xkXG4gICAgfTtcbiAgfVxuICBjb25zdCB2YWx1ZXNUb1JhbmsgPSBnZXRBbGxWYWx1ZXNUb1JhbmsoaXRlbSwgb3B0aW9ucy5hY2Nlc3NvcnMpO1xuICBjb25zdCByYW5raW5nSW5mbyA9IHtcbiAgICByYW5rZWRWYWx1ZTogaXRlbSxcbiAgICByYW5rOiByYW5raW5ncy5OT19NQVRDSCxcbiAgICBhY2Nlc3NvckluZGV4OiAtMSxcbiAgICBhY2Nlc3NvclRocmVzaG9sZDogb3B0aW9ucy50aHJlc2hvbGQsXG4gICAgcGFzc2VkOiBmYWxzZVxuICB9O1xuICBmb3IgKGxldCBpID0gMDsgaSA8IHZhbHVlc1RvUmFuay5sZW5ndGg7IGkrKykge1xuICAgIGNvbnN0IHJhbmtWYWx1ZSA9IHZhbHVlc1RvUmFua1tpXTtcbiAgICBsZXQgbmV3UmFuayA9IGdldE1hdGNoUmFua2luZyhyYW5rVmFsdWUuaXRlbVZhbHVlLCB2YWx1ZSwgb3B0aW9ucyk7XG4gICAgY29uc3Qge1xuICAgICAgbWluUmFua2luZyxcbiAgICAgIG1heFJhbmtpbmcsXG4gICAgICB0aHJlc2hvbGQgPSBvcHRpb25zLnRocmVzaG9sZFxuICAgIH0gPSByYW5rVmFsdWUuYXR0cmlidXRlcztcbiAgICBpZiAobmV3UmFuayA8IG1pblJhbmtpbmcgJiYgbmV3UmFuayA+PSByYW5raW5ncy5NQVRDSEVTKSB7XG4gICAgICBuZXdSYW5rID0gbWluUmFua2luZztcbiAgICB9IGVsc2UgaWYgKG5ld1JhbmsgPiBtYXhSYW5raW5nKSB7XG4gICAgICBuZXdSYW5rID0gbWF4UmFua2luZztcbiAgICB9XG4gICAgbmV3UmFuayA9IE1hdGgubWluKG5ld1JhbmssIG1heFJhbmtpbmcpO1xuICAgIGlmIChuZXdSYW5rID49IHRocmVzaG9sZCAmJiBuZXdSYW5rID4gcmFua2luZ0luZm8ucmFuaykge1xuICAgICAgcmFua2luZ0luZm8ucmFuayA9IG5ld1Jhbms7XG4gICAgICByYW5raW5nSW5mby5wYXNzZWQgPSB0cnVlO1xuICAgICAgcmFua2luZ0luZm8uYWNjZXNzb3JJbmRleCA9IGk7XG4gICAgICByYW5raW5nSW5mby5hY2Nlc3NvclRocmVzaG9sZCA9IHRocmVzaG9sZDtcbiAgICAgIHJhbmtpbmdJbmZvLnJhbmtlZFZhbHVlID0gcmFua1ZhbHVlLml0ZW1WYWx1ZTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHJhbmtpbmdJbmZvO1xufVxuXG4vKipcbiAqIEdpdmVzIGEgcmFua2luZ3Mgc2NvcmUgYmFzZWQgb24gaG93IHdlbGwgdGhlIHR3byBzdHJpbmdzIG1hdGNoLlxuICogQHBhcmFtIHtTdHJpbmd9IHRlc3RTdHJpbmcgLSB0aGUgc3RyaW5nIHRvIHRlc3QgYWdhaW5zdFxuICogQHBhcmFtIHtTdHJpbmd9IHN0cmluZ1RvUmFuayAtIHRoZSBzdHJpbmcgdG8gcmFua1xuICogQHBhcmFtIHtPYmplY3R9IG9wdGlvbnMgLSBvcHRpb25zIGZvciB0aGUgbWF0Y2ggKGxpa2Uga2VlcERpYWNyaXRpY3MgZm9yIGNvbXBhcmlzb24pXG4gKiBAcmV0dXJucyB7TnVtYmVyfSB0aGUgcmFua2luZyBmb3IgaG93IHdlbGwgc3RyaW5nVG9SYW5rIG1hdGNoZXMgdGVzdFN0cmluZ1xuICovXG5mdW5jdGlvbiBnZXRNYXRjaFJhbmtpbmcodGVzdFN0cmluZywgc3RyaW5nVG9SYW5rLCBvcHRpb25zKSB7XG4gIHRlc3RTdHJpbmcgPSBwcmVwYXJlVmFsdWVGb3JDb21wYXJpc29uKHRlc3RTdHJpbmcsIG9wdGlvbnMpO1xuICBzdHJpbmdUb1JhbmsgPSBwcmVwYXJlVmFsdWVGb3JDb21wYXJpc29uKHN0cmluZ1RvUmFuaywgb3B0aW9ucyk7XG5cbiAgLy8gdG9vIGxvbmdcbiAgaWYgKHN0cmluZ1RvUmFuay5sZW5ndGggPiB0ZXN0U3RyaW5nLmxlbmd0aCkge1xuICAgIHJldHVybiByYW5raW5ncy5OT19NQVRDSDtcbiAgfVxuXG4gIC8vIGNhc2Ugc2Vuc2l0aXZlIGVxdWFsc1xuICBpZiAodGVzdFN0cmluZyA9PT0gc3RyaW5nVG9SYW5rKSB7XG4gICAgcmV0dXJuIHJhbmtpbmdzLkNBU0VfU0VOU0lUSVZFX0VRVUFMO1xuICB9XG5cbiAgLy8gTG93ZXIgY2FzaW5nIGJlZm9yZSBmdXJ0aGVyIGNvbXBhcmlzb25cbiAgdGVzdFN0cmluZyA9IHRlc3RTdHJpbmcudG9Mb3dlckNhc2UoKTtcbiAgc3RyaW5nVG9SYW5rID0gc3RyaW5nVG9SYW5rLnRvTG93ZXJDYXNlKCk7XG5cbiAgLy8gY2FzZSBpbnNlbnNpdGl2ZSBlcXVhbHNcbiAgaWYgKHRlc3RTdHJpbmcgPT09IHN0cmluZ1RvUmFuaykge1xuICAgIHJldHVybiByYW5raW5ncy5FUVVBTDtcbiAgfVxuXG4gIC8vIHN0YXJ0cyB3aXRoXG4gIGlmICh0ZXN0U3RyaW5nLnN0YXJ0c1dpdGgoc3RyaW5nVG9SYW5rKSkge1xuICAgIHJldHVybiByYW5raW5ncy5TVEFSVFNfV0lUSDtcbiAgfVxuXG4gIC8vIHdvcmQgc3RhcnRzIHdpdGhcbiAgaWYgKHRlc3RTdHJpbmcuaW5jbHVkZXMoYCAke3N0cmluZ1RvUmFua31gKSkge1xuICAgIHJldHVybiByYW5raW5ncy5XT1JEX1NUQVJUU19XSVRIO1xuICB9XG5cbiAgLy8gY29udGFpbnNcbiAgaWYgKHRlc3RTdHJpbmcuaW5jbHVkZXMoc3RyaW5nVG9SYW5rKSkge1xuICAgIHJldHVybiByYW5raW5ncy5DT05UQUlOUztcbiAgfSBlbHNlIGlmIChzdHJpbmdUb1JhbmsubGVuZ3RoID09PSAxKSB7XG4gICAgLy8gSWYgdGhlIG9ubHkgY2hhcmFjdGVyIGluIHRoZSBnaXZlbiBzdHJpbmdUb1JhbmtcbiAgICAvLyAgIGlzbid0IGV2ZW4gY29udGFpbmVkIGluIHRoZSB0ZXN0U3RyaW5nLCB0aGVuXG4gICAgLy8gICBpdCdzIGRlZmluaXRlbHkgbm90IGEgbWF0Y2guXG4gICAgcmV0dXJuIHJhbmtpbmdzLk5PX01BVENIO1xuICB9XG5cbiAgLy8gYWNyb255bVxuICBpZiAoZ2V0QWNyb255bSh0ZXN0U3RyaW5nKS5pbmNsdWRlcyhzdHJpbmdUb1JhbmspKSB7XG4gICAgcmV0dXJuIHJhbmtpbmdzLkFDUk9OWU07XG4gIH1cblxuICAvLyB3aWxsIHJldHVybiBhIG51bWJlciBiZXR3ZWVuIHJhbmtpbmdzLk1BVENIRVMgYW5kXG4gIC8vIHJhbmtpbmdzLk1BVENIRVMgKyAxIGRlcGVuZGluZyAgb24gaG93IGNsb3NlIG9mIGEgbWF0Y2ggaXQgaXMuXG4gIHJldHVybiBnZXRDbG9zZW5lc3NSYW5raW5nKHRlc3RTdHJpbmcsIHN0cmluZ1RvUmFuayk7XG59XG5cbi8qKlxuICogR2VuZXJhdGVzIGFuIGFjcm9ueW0gZm9yIGEgc3RyaW5nLlxuICpcbiAqIEBwYXJhbSB7U3RyaW5nfSBzdHJpbmcgdGhlIHN0cmluZyBmb3Igd2hpY2ggdG8gcHJvZHVjZSB0aGUgYWNyb255bVxuICogQHJldHVybnMge1N0cmluZ30gdGhlIGFjcm9ueW1cbiAqL1xuZnVuY3Rpb24gZ2V0QWNyb255bShzdHJpbmcpIHtcbiAgbGV0IGFjcm9ueW0gPSAnJztcbiAgY29uc3Qgd29yZHNJblN0cmluZyA9IHN0cmluZy5zcGxpdCgnICcpO1xuICB3b3Jkc0luU3RyaW5nLmZvckVhY2god29yZEluU3RyaW5nID0+IHtcbiAgICBjb25zdCBzcGxpdEJ5SHlwaGVuV29yZHMgPSB3b3JkSW5TdHJpbmcuc3BsaXQoJy0nKTtcbiAgICBzcGxpdEJ5SHlwaGVuV29yZHMuZm9yRWFjaChzcGxpdEJ5SHlwaGVuV29yZCA9PiB7XG4gICAgICBhY3JvbnltICs9IHNwbGl0QnlIeXBoZW5Xb3JkLnN1YnN0cigwLCAxKTtcbiAgICB9KTtcbiAgfSk7XG4gIHJldHVybiBhY3JvbnltO1xufVxuXG4vKipcbiAqIFJldHVybnMgYSBzY29yZSBiYXNlZCBvbiBob3cgc3ByZWFkIGFwYXJ0IHRoZVxuICogY2hhcmFjdGVycyBmcm9tIHRoZSBzdHJpbmdUb1JhbmsgYXJlIHdpdGhpbiB0aGUgdGVzdFN0cmluZy5cbiAqIEEgbnVtYmVyIGNsb3NlIHRvIHJhbmtpbmdzLk1BVENIRVMgcmVwcmVzZW50cyBhIGxvb3NlIG1hdGNoLiBBIG51bWJlciBjbG9zZVxuICogdG8gcmFua2luZ3MuTUFUQ0hFUyArIDEgcmVwcmVzZW50cyBhIHRpZ2h0ZXIgbWF0Y2guXG4gKiBAcGFyYW0ge1N0cmluZ30gdGVzdFN0cmluZyAtIHRoZSBzdHJpbmcgdG8gdGVzdCBhZ2FpbnN0XG4gKiBAcGFyYW0ge1N0cmluZ30gc3RyaW5nVG9SYW5rIC0gdGhlIHN0cmluZyB0byByYW5rXG4gKiBAcmV0dXJucyB7TnVtYmVyfSB0aGUgbnVtYmVyIGJldHdlZW4gcmFua2luZ3MuTUFUQ0hFUyBhbmRcbiAqIHJhbmtpbmdzLk1BVENIRVMgKyAxIGZvciBob3cgd2VsbCBzdHJpbmdUb1JhbmsgbWF0Y2hlcyB0ZXN0U3RyaW5nXG4gKi9cbmZ1bmN0aW9uIGdldENsb3NlbmVzc1JhbmtpbmcodGVzdFN0cmluZywgc3RyaW5nVG9SYW5rKSB7XG4gIGxldCBtYXRjaGluZ0luT3JkZXJDaGFyQ291bnQgPSAwO1xuICBsZXQgY2hhck51bWJlciA9IDA7XG4gIGZ1bmN0aW9uIGZpbmRNYXRjaGluZ0NoYXJhY3RlcihtYXRjaENoYXIsIHN0cmluZywgaW5kZXgpIHtcbiAgICBmb3IgKGxldCBqID0gaW5kZXgsIEogPSBzdHJpbmcubGVuZ3RoOyBqIDwgSjsgaisrKSB7XG4gICAgICBjb25zdCBzdHJpbmdDaGFyID0gc3RyaW5nW2pdO1xuICAgICAgaWYgKHN0cmluZ0NoYXIgPT09IG1hdGNoQ2hhcikge1xuICAgICAgICBtYXRjaGluZ0luT3JkZXJDaGFyQ291bnQgKz0gMTtcbiAgICAgICAgcmV0dXJuIGogKyAxO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gLTE7XG4gIH1cbiAgZnVuY3Rpb24gZ2V0UmFua2luZyhzcHJlYWQpIHtcbiAgICBjb25zdCBzcHJlYWRQZXJjZW50YWdlID0gMSAvIHNwcmVhZDtcbiAgICBjb25zdCBpbk9yZGVyUGVyY2VudGFnZSA9IG1hdGNoaW5nSW5PcmRlckNoYXJDb3VudCAvIHN0cmluZ1RvUmFuay5sZW5ndGg7XG4gICAgY29uc3QgcmFua2luZyA9IHJhbmtpbmdzLk1BVENIRVMgKyBpbk9yZGVyUGVyY2VudGFnZSAqIHNwcmVhZFBlcmNlbnRhZ2U7XG4gICAgcmV0dXJuIHJhbmtpbmc7XG4gIH1cbiAgY29uc3QgZmlyc3RJbmRleCA9IGZpbmRNYXRjaGluZ0NoYXJhY3RlcihzdHJpbmdUb1JhbmtbMF0sIHRlc3RTdHJpbmcsIDApO1xuICBpZiAoZmlyc3RJbmRleCA8IDApIHtcbiAgICByZXR1cm4gcmFua2luZ3MuTk9fTUFUQ0g7XG4gIH1cbiAgY2hhck51bWJlciA9IGZpcnN0SW5kZXg7XG4gIGZvciAobGV0IGkgPSAxLCBJID0gc3RyaW5nVG9SYW5rLmxlbmd0aDsgaSA8IEk7IGkrKykge1xuICAgIGNvbnN0IG1hdGNoQ2hhciA9IHN0cmluZ1RvUmFua1tpXTtcbiAgICBjaGFyTnVtYmVyID0gZmluZE1hdGNoaW5nQ2hhcmFjdGVyKG1hdGNoQ2hhciwgdGVzdFN0cmluZywgY2hhck51bWJlcik7XG4gICAgY29uc3QgZm91bmQgPSBjaGFyTnVtYmVyID4gLTE7XG4gICAgaWYgKCFmb3VuZCkge1xuICAgICAgcmV0dXJuIHJhbmtpbmdzLk5PX01BVENIO1xuICAgIH1cbiAgfVxuICBjb25zdCBzcHJlYWQgPSBjaGFyTnVtYmVyIC0gZmlyc3RJbmRleDtcbiAgcmV0dXJuIGdldFJhbmtpbmcoc3ByZWFkKTtcbn1cblxuLyoqXG4gKiBTb3J0cyBpdGVtcyB0aGF0IGhhdmUgYSByYW5rLCBpbmRleCwgYW5kIGFjY2Vzc29ySW5kZXhcbiAqIEBwYXJhbSB7T2JqZWN0fSBhIC0gdGhlIGZpcnN0IGl0ZW0gdG8gc29ydFxuICogQHBhcmFtIHtPYmplY3R9IGIgLSB0aGUgc2Vjb25kIGl0ZW0gdG8gc29ydFxuICogQHJldHVybiB7TnVtYmVyfSAtMSBpZiBhIHNob3VsZCBjb21lIGZpcnN0LCAxIGlmIGIgc2hvdWxkIGNvbWUgZmlyc3QsIDAgaWYgZXF1YWxcbiAqL1xuZnVuY3Rpb24gY29tcGFyZUl0ZW1zKGEsIGIpIHtcbiAgcmV0dXJuIGEucmFuayA9PT0gYi5yYW5rID8gMCA6IGEucmFuayA+IGIucmFuayA/IC0xIDogMTtcbn1cblxuLyoqXG4gKiBQcmVwYXJlcyB2YWx1ZSBmb3IgY29tcGFyaXNvbiBieSBzdHJpbmdpZnlpbmcgaXQsIHJlbW92aW5nIGRpYWNyaXRpY3MgKGlmIHNwZWNpZmllZClcbiAqIEBwYXJhbSB7U3RyaW5nfSB2YWx1ZSAtIHRoZSB2YWx1ZSB0byBjbGVhblxuICogQHBhcmFtIHtPYmplY3R9IG9wdGlvbnMgLSB7a2VlcERpYWNyaXRpY3M6IHdoZXRoZXIgdG8gcmVtb3ZlIGRpYWNyaXRpY3N9XG4gKiBAcmV0dXJuIHtTdHJpbmd9IHRoZSBwcmVwYXJlZCB2YWx1ZVxuICovXG5mdW5jdGlvbiBwcmVwYXJlVmFsdWVGb3JDb21wYXJpc29uKHZhbHVlLCBfcmVmKSB7XG4gIGxldCB7XG4gICAga2VlcERpYWNyaXRpY3NcbiAgfSA9IF9yZWY7XG4gIC8vIHZhbHVlIG1pZ2h0IG5vdCBhY3R1YWxseSBiZSBhIHN0cmluZyBhdCB0aGlzIHBvaW50ICh3ZSBkb24ndCBnZXQgdG8gY2hvb3NlKVxuICAvLyBzbyBwYXJ0IG9mIHByZXBhcmluZyB0aGUgdmFsdWUgZm9yIGNvbXBhcmlzb24gaXMgZW5zdXJlIHRoYXQgaXQgaXMgYSBzdHJpbmdcbiAgdmFsdWUgPSBgJHt2YWx1ZX1gOyAvLyB0b1N0cmluZ1xuICBpZiAoIWtlZXBEaWFjcml0aWNzKSB7XG4gICAgdmFsdWUgPSByZW1vdmVBY2NlbnRzKHZhbHVlKTtcbiAgfVxuICByZXR1cm4gdmFsdWU7XG59XG5cbi8qKlxuICogR2V0cyB2YWx1ZSBmb3Iga2V5IGluIGl0ZW0gYXQgYXJiaXRyYXJpbHkgbmVzdGVkIGtleXBhdGhcbiAqIEBwYXJhbSB7T2JqZWN0fSBpdGVtIC0gdGhlIGl0ZW1cbiAqIEBwYXJhbSB7T2JqZWN0fEZ1bmN0aW9ufSBrZXkgLSB0aGUgcG90ZW50aWFsbHkgbmVzdGVkIGtleXBhdGggb3IgcHJvcGVydHkgY2FsbGJhY2tcbiAqIEByZXR1cm4ge0FycmF5fSAtIGFuIGFycmF5IGNvbnRhaW5pbmcgdGhlIHZhbHVlKHMpIGF0IHRoZSBuZXN0ZWQga2V5cGF0aFxuICovXG5mdW5jdGlvbiBnZXRJdGVtVmFsdWVzKGl0ZW0sIGFjY2Vzc29yKSB7XG4gIGxldCBhY2Nlc3NvckZuID0gYWNjZXNzb3I7XG4gIGlmICh0eXBlb2YgYWNjZXNzb3IgPT09ICdvYmplY3QnKSB7XG4gICAgYWNjZXNzb3JGbiA9IGFjY2Vzc29yLmFjY2Vzc29yO1xuICB9XG4gIGNvbnN0IHZhbHVlID0gYWNjZXNzb3JGbihpdGVtKTtcblxuICAvLyBiZWNhdXNlIGB2YWx1ZWAgY2FuIGFsc28gYmUgdW5kZWZpbmVkXG4gIGlmICh2YWx1ZSA9PSBudWxsKSB7XG4gICAgcmV0dXJuIFtdO1xuICB9XG4gIGlmIChBcnJheS5pc0FycmF5KHZhbHVlKSkge1xuICAgIHJldHVybiB2YWx1ZTtcbiAgfVxuICByZXR1cm4gW1N0cmluZyh2YWx1ZSldO1xufVxuXG4vKipcbiAqIEdldHMgYWxsIHRoZSB2YWx1ZXMgZm9yIHRoZSBnaXZlbiBrZXlzIGluIHRoZSBnaXZlbiBpdGVtIGFuZCByZXR1cm5zIGFuIGFycmF5IG9mIHRob3NlIHZhbHVlc1xuICogQHBhcmFtIGl0ZW0gLSB0aGUgaXRlbSBmcm9tIHdoaWNoIHRoZSB2YWx1ZXMgd2lsbCBiZSByZXRyaWV2ZWRcbiAqIEBwYXJhbSBrZXlzIC0gdGhlIGtleXMgdG8gdXNlIHRvIHJldHJpZXZlIHRoZSB2YWx1ZXNcbiAqIEByZXR1cm4gb2JqZWN0cyB3aXRoIHtpdGVtVmFsdWUsIGF0dHJpYnV0ZXN9XG4gKi9cbmZ1bmN0aW9uIGdldEFsbFZhbHVlc1RvUmFuayhpdGVtLCBhY2Nlc3NvcnMpIHtcbiAgY29uc3QgYWxsVmFsdWVzID0gW107XG4gIGZvciAobGV0IGogPSAwLCBKID0gYWNjZXNzb3JzLmxlbmd0aDsgaiA8IEo7IGorKykge1xuICAgIGNvbnN0IGFjY2Vzc29yID0gYWNjZXNzb3JzW2pdO1xuICAgIGNvbnN0IGF0dHJpYnV0ZXMgPSBnZXRBY2Nlc3NvckF0dHJpYnV0ZXMoYWNjZXNzb3IpO1xuICAgIGNvbnN0IGl0ZW1WYWx1ZXMgPSBnZXRJdGVtVmFsdWVzKGl0ZW0sIGFjY2Vzc29yKTtcbiAgICBmb3IgKGxldCBpID0gMCwgSSA9IGl0ZW1WYWx1ZXMubGVuZ3RoOyBpIDwgSTsgaSsrKSB7XG4gICAgICBhbGxWYWx1ZXMucHVzaCh7XG4gICAgICAgIGl0ZW1WYWx1ZTogaXRlbVZhbHVlc1tpXSxcbiAgICAgICAgYXR0cmlidXRlc1xuICAgICAgfSk7XG4gICAgfVxuICB9XG4gIHJldHVybiBhbGxWYWx1ZXM7XG59XG5jb25zdCBkZWZhdWx0S2V5QXR0cmlidXRlcyA9IHtcbiAgbWF4UmFua2luZzogSW5maW5pdHksXG4gIG1pblJhbmtpbmc6IC1JbmZpbml0eVxufTtcbi8qKlxuICogR2V0cyBhbGwgdGhlIGF0dHJpYnV0ZXMgZm9yIHRoZSBnaXZlbiBhY2Nlc3NvclxuICogQHBhcmFtIGFjY2Vzc29yIC0gdGhlIGFjY2Vzc29yIGZyb20gd2hpY2ggdGhlIGF0dHJpYnV0ZXMgd2lsbCBiZSByZXRyaWV2ZWRcbiAqIEByZXR1cm4gb2JqZWN0IGNvbnRhaW5pbmcgdGhlIGFjY2Vzc29yJ3MgYXR0cmlidXRlc1xuICovXG5mdW5jdGlvbiBnZXRBY2Nlc3NvckF0dHJpYnV0ZXMoYWNjZXNzb3IpIHtcbiAgaWYgKHR5cGVvZiBhY2Nlc3NvciA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIHJldHVybiBkZWZhdWx0S2V5QXR0cmlidXRlcztcbiAgfVxuICByZXR1cm4ge1xuICAgIC4uLmRlZmF1bHRLZXlBdHRyaWJ1dGVzLFxuICAgIC4uLmFjY2Vzc29yXG4gIH07XG59XG5cbmV4cG9ydCB7IGNvbXBhcmVJdGVtcywgcmFua0l0ZW0sIHJhbmtpbmdzIH07XG4vLyMgc291cmNlTWFwcGluZ1VSTD1pbmRleC5tanMubWFwXG4iXSwibmFtZXMiOlsiY2hhcmFjdGVyTWFwIiwiw4AiLCLDgSIsIsOCIiwiw4MiLCLDhCIsIsOFIiwi4bqkIiwi4bquIiwi4bqyIiwi4bq0Iiwi4bq2Iiwiw4YiLCLhuqYiLCLhurAiLCLIgiIsIsOHIiwi4biIIiwiw4giLCLDiSIsIsOKIiwiw4siLCLhur4iLCLhuJYiLCLhu4AiLCLhuJQiLCLhuJwiLCLIhiIsIsOMIiwiw40iLCLDjiIsIsOPIiwi4biuIiwiyIoiLCLDkCIsIsORIiwiw5IiLCLDkyIsIsOUIiwiw5UiLCLDliIsIsOYIiwi4buQIiwi4bmMIiwi4bmSIiwiyI4iLCLDmSIsIsOaIiwiw5siLCLDnCIsIsOdIiwiw6AiLCLDoSIsIsOiIiwiw6MiLCLDpCIsIsOlIiwi4bqlIiwi4bqvIiwi4bqzIiwi4bq1Iiwi4bq3Iiwiw6YiLCLhuqciLCLhurEiLCLIgyIsIsOnIiwi4biJIiwiw6giLCLDqSIsIsOqIiwiw6siLCLhur8iLCLhuJciLCLhu4EiLCLhuJUiLCLhuJ0iLCLIhyIsIsOsIiwiw60iLCLDriIsIsOvIiwi4bivIiwiyIsiLCLDsCIsIsOxIiwiw7IiLCLDsyIsIsO0Iiwiw7UiLCLDtiIsIsO4Iiwi4buRIiwi4bmNIiwi4bmTIiwiyI8iLCLDuSIsIsO6Iiwiw7siLCLDvCIsIsO9Iiwiw78iLCLEgCIsIsSBIiwixIIiLCLEgyIsIsSEIiwixIUiLCLEhiIsIsSHIiwixIgiLCLEiSIsIsSKIiwixIsiLCLEjCIsIsSNIiwiQ8yGIiwiY8yGIiwixI4iLCLEjyIsIsSQIiwixJEiLCLEkiIsIsSTIiwixJQiLCLElSIsIsSWIiwixJciLCLEmCIsIsSZIiwixJoiLCLEmyIsIsScIiwix7QiLCLEnSIsIse1IiwixJ4iLCLEnyIsIsSgIiwixKEiLCLEoiIsIsSjIiwixKQiLCLEpSIsIsSmIiwixKciLCLhuKoiLCLhuKsiLCLEqCIsIsSpIiwixKoiLCLEqyIsIsSsIiwixK0iLCLEriIsIsSvIiwixLAiLCLEsSIsIsSyIiwixLMiLCLEtCIsIsS1IiwixLYiLCLEtyIsIuG4sCIsIuG4sSIsIkvMhiIsImvMhiIsIsS5IiwixLoiLCLEuyIsIsS8IiwixL0iLCLEviIsIsS/IiwixYAiLCLFgSIsIsWCIiwi4bi+Iiwi4bi/IiwiTcyGIiwibcyGIiwixYMiLCLFhCIsIsWFIiwixYYiLCLFhyIsIsWIIiwixYkiLCJOzIYiLCJuzIYiLCLFjCIsIsWNIiwixY4iLCLFjyIsIsWQIiwixZEiLCLFkiIsIsWTIiwiUMyGIiwicMyGIiwixZQiLCLFlSIsIsWWIiwixZciLCLFmCIsIsWZIiwiUsyGIiwicsyGIiwiyJIiLCLIkyIsIsWaIiwixZsiLCLFnCIsIsWdIiwixZ4iLCLImCIsIsiZIiwixZ8iLCLFoCIsIsWhIiwixaIiLCLFoyIsIsibIiwiyJoiLCLFpCIsIsWlIiwixaYiLCLFpyIsIlTMhiIsInTMhiIsIsWoIiwixakiLCLFqiIsIsWrIiwixawiLCLFrSIsIsWuIiwixa8iLCLFsCIsIsWxIiwixbIiLCLFsyIsIsiWIiwiyJciLCJWzIYiLCJ2zIYiLCLFtCIsIsW1Iiwi4bqCIiwi4bqDIiwiWMyGIiwieMyGIiwixbYiLCLFtyIsIsW4IiwiWcyGIiwiecyGIiwixbkiLCLFuiIsIsW7IiwixbwiLCLFvSIsIsW+Iiwixb8iLCLGkiIsIsagIiwixqEiLCLGryIsIsawIiwix40iLCLHjiIsIsePIiwix5AiLCLHkSIsIseSIiwix5MiLCLHlCIsIseVIiwix5YiLCLHlyIsIseYIiwix5kiLCLHmiIsIsebIiwix5wiLCLhu6giLCLhu6kiLCLhubgiLCLhubkiLCLHuiIsIse7Iiwix7wiLCLHvSIsIse+Iiwix78iLCLDniIsIsO+Iiwi4bmUIiwi4bmVIiwi4bmkIiwi4bmlIiwiWMyBIiwieMyBIiwi0IMiLCLRkyIsItCMIiwi0ZwiLCJBzIsiLCJhzIsiLCJFzIsiLCJlzIsiLCJJzIsiLCJpzIsiLCLHuCIsIse5Iiwi4buSIiwi4buTIiwi4bmQIiwi4bmRIiwi4buqIiwi4burIiwi4bqAIiwi4bqBIiwi4buyIiwi4buzIiwiyIAiLCLIgSIsIsiEIiwiyIUiLCLIiCIsIsiJIiwiyIwiLCLIjSIsIsiQIiwiyJEiLCLIlCIsIsiVIiwiQsyMIiwiYsyMIiwixIzMoyIsIsSNzKMiLCLDisyMIiwiw6rMjCIsIkbMjCIsImbMjCIsIsemIiwix6ciLCLIniIsIsifIiwiSsyMIiwix7AiLCLHqCIsIsepIiwiTcyMIiwibcyMIiwiUMyMIiwicMyMIiwiUcyMIiwiccyMIiwixZjMqSIsIsWZzKkiLCLhuaYiLCLhuaciLCJWzIwiLCJ2zIwiLCJXzIwiLCJ3zIwiLCJYzIwiLCJ4zIwiLCJZzIwiLCJ5zIwiLCJBzKciLCJhzKciLCJCzKciLCJizKciLCLhuJAiLCLhuJEiLCLIqCIsIsipIiwixpDMpyIsIsmbzKciLCLhuKgiLCLhuKkiLCJJzKciLCJpzKciLCLGl8ynIiwiyajMpyIsIk3MpyIsIm3MpyIsIk/MpyIsIm/MpyIsIlHMpyIsInHMpyIsIlXMpyIsInXMpyIsIljMpyIsInjMpyIsIlrMpyIsInrMpyIsImNoYXJzIiwiT2JqZWN0Iiwia2V5cyIsImpvaW4iLCJhbGxBY2NlbnRzIiwiUmVnRXhwIiwicmVtb3ZlQWNjZW50cyIsInN0ciIsInJlcGxhY2UiLCJtYXRjaCIsInJhbmtpbmdzIiwiQ0FTRV9TRU5TSVRJVkVfRVFVQUwiLCJFUVVBTCIsIlNUQVJUU19XSVRIIiwiV09SRF9TVEFSVFNfV0lUSCIsIkNPTlRBSU5TIiwiQUNST05ZTSIsIk1BVENIRVMiLCJOT19NQVRDSCIsInJhbmtJdGVtIiwiaXRlbSIsInZhbHVlIiwib3B0aW9ucyIsIl9vcHRpb25zJHRocmVzaG9sZCIsInRocmVzaG9sZCIsImFjY2Vzc29ycyIsInJhbmsiLCJnZXRNYXRjaFJhbmtpbmciLCJyYW5rZWRWYWx1ZSIsImFjY2Vzc29ySW5kZXgiLCJhY2Nlc3NvclRocmVzaG9sZCIsInBhc3NlZCIsInZhbHVlc1RvUmFuayIsImdldEFsbFZhbHVlc1RvUmFuayIsInJhbmtpbmdJbmZvIiwiaSIsImxlbmd0aCIsInJhbmtWYWx1ZSIsIm5ld1JhbmsiLCJpdGVtVmFsdWUiLCJtaW5SYW5raW5nIiwibWF4UmFua2luZyIsImF0dHJpYnV0ZXMiLCJNYXRoIiwibWluIiwidGVzdFN0cmluZyIsInN0cmluZ1RvUmFuayIsInByZXBhcmVWYWx1ZUZvckNvbXBhcmlzb24iLCJ0b0xvd2VyQ2FzZSIsInN0YXJ0c1dpdGgiLCJpbmNsdWRlcyIsImdldEFjcm9ueW0iLCJnZXRDbG9zZW5lc3NSYW5raW5nIiwic3RyaW5nIiwiYWNyb255bSIsIndvcmRzSW5TdHJpbmciLCJzcGxpdCIsImZvckVhY2giLCJ3b3JkSW5TdHJpbmciLCJzcGxpdEJ5SHlwaGVuV29yZHMiLCJzcGxpdEJ5SHlwaGVuV29yZCIsInN1YnN0ciIsIm1hdGNoaW5nSW5PcmRlckNoYXJDb3VudCIsImNoYXJOdW1iZXIiLCJmaW5kTWF0Y2hpbmdDaGFyYWN0ZXIiLCJtYXRjaENoYXIiLCJpbmRleCIsImoiLCJKIiwic3RyaW5nQ2hhciIsImdldFJhbmtpbmciLCJzcHJlYWQiLCJzcHJlYWRQZXJjZW50YWdlIiwiaW5PcmRlclBlcmNlbnRhZ2UiLCJyYW5raW5nIiwiZmlyc3RJbmRleCIsIkkiLCJmb3VuZCIsImNvbXBhcmVJdGVtcyIsImEiLCJiIiwiX3JlZiIsImtlZXBEaWFjcml0aWNzIiwiZ2V0SXRlbVZhbHVlcyIsImFjY2Vzc29yIiwiYWNjZXNzb3JGbiIsIkFycmF5IiwiaXNBcnJheSIsIlN0cmluZyIsImFsbFZhbHVlcyIsImdldEFjY2Vzc29yQXR0cmlidXRlcyIsIml0ZW1WYWx1ZXMiLCJwdXNoIiwiZGVmYXVsdEtleUF0dHJpYnV0ZXMiLCJJbmZpbml0eSJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@tanstack/match-sorter-utils/build/lib/index.mjs\n");

/***/ }),

/***/ "(ssr)/./node_modules/@tanstack/react-table/build/lib/index.mjs":
/*!****************************************************************!*\
  !*** ./node_modules/@tanstack/react-table/build/lib/index.mjs ***!
  \****************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   ColumnSizing: () => (/* reexport safe */ _tanstack_table_core__WEBPACK_IMPORTED_MODULE_1__.ColumnSizing),\n/* harmony export */   Expanding: () => (/* reexport safe */ _tanstack_table_core__WEBPACK_IMPORTED_MODULE_1__.Expanding),\n/* harmony export */   Filters: () => (/* reexport safe */ _tanstack_table_core__WEBPACK_IMPORTED_MODULE_1__.Filters),\n/* harmony export */   Grouping: () => (/* reexport safe */ _tanstack_table_core__WEBPACK_IMPORTED_MODULE_1__.Grouping),\n/* harmony export */   Headers: () => (/* reexport safe */ _tanstack_table_core__WEBPACK_IMPORTED_MODULE_1__.Headers),\n/* harmony export */   Ordering: () => (/* reexport safe */ _tanstack_table_core__WEBPACK_IMPORTED_MODULE_1__.Ordering),\n/* harmony export */   Pagination: () => (/* reexport safe */ _tanstack_table_core__WEBPACK_IMPORTED_MODULE_1__.Pagination),\n/* harmony export */   Pinning: () => (/* reexport safe */ _tanstack_table_core__WEBPACK_IMPORTED_MODULE_1__.Pinning),\n/* harmony export */   RowSelection: () => (/* reexport safe */ _tanstack_table_core__WEBPACK_IMPORTED_MODULE_1__.RowSelection),\n/* harmony export */   Sorting: () => (/* reexport safe */ _tanstack_table_core__WEBPACK_IMPORTED_MODULE_1__.Sorting),\n/* harmony export */   Visibility: () => (/* reexport safe */ _tanstack_table_core__WEBPACK_IMPORTED_MODULE_1__.Visibility),\n/* harmony export */   aggregationFns: () => (/* reexport safe */ _tanstack_table_core__WEBPACK_IMPORTED_MODULE_1__.aggregationFns),\n/* harmony export */   buildHeaderGroups: () => (/* reexport safe */ _tanstack_table_core__WEBPACK_IMPORTED_MODULE_1__.buildHeaderGroups),\n/* harmony export */   createCell: () => (/* reexport safe */ _tanstack_table_core__WEBPACK_IMPORTED_MODULE_1__.createCell),\n/* harmony export */   createColumn: () => (/* reexport safe */ _tanstack_table_core__WEBPACK_IMPORTED_MODULE_1__.createColumn),\n/* harmony export */   createColumnHelper: () => (/* reexport safe */ _tanstack_table_core__WEBPACK_IMPORTED_MODULE_1__.createColumnHelper),\n/* harmony export */   createRow: () => (/* reexport safe */ _tanstack_table_core__WEBPACK_IMPORTED_MODULE_1__.createRow),\n/* harmony export */   createTable: () => (/* reexport safe */ _tanstack_table_core__WEBPACK_IMPORTED_MODULE_1__.createTable),\n/* harmony export */   defaultColumnSizing: () => (/* reexport safe */ _tanstack_table_core__WEBPACK_IMPORTED_MODULE_1__.defaultColumnSizing),\n/* harmony export */   expandRows: () => (/* reexport safe */ _tanstack_table_core__WEBPACK_IMPORTED_MODULE_1__.expandRows),\n/* harmony export */   filterFns: () => (/* reexport safe */ _tanstack_table_core__WEBPACK_IMPORTED_MODULE_1__.filterFns),\n/* harmony export */   flattenBy: () => (/* reexport safe */ _tanstack_table_core__WEBPACK_IMPORTED_MODULE_1__.flattenBy),\n/* harmony export */   flexRender: () => (/* binding */ flexRender),\n/* harmony export */   functionalUpdate: () => (/* reexport safe */ _tanstack_table_core__WEBPACK_IMPORTED_MODULE_1__.functionalUpdate),\n/* harmony export */   getCoreRowModel: () => (/* reexport safe */ _tanstack_table_core__WEBPACK_IMPORTED_MODULE_1__.getCoreRowModel),\n/* harmony export */   getExpandedRowModel: () => (/* reexport safe */ _tanstack_table_core__WEBPACK_IMPORTED_MODULE_1__.getExpandedRowModel),\n/* harmony export */   getFacetedMinMaxValues: () => (/* reexport safe */ _tanstack_table_core__WEBPACK_IMPORTED_MODULE_1__.getFacetedMinMaxValues),\n/* harmony export */   getFacetedRowModel: () => (/* reexport safe */ _tanstack_table_core__WEBPACK_IMPORTED_MODULE_1__.getFacetedRowModel),\n/* harmony export */   getFacetedUniqueValues: () => (/* reexport safe */ _tanstack_table_core__WEBPACK_IMPORTED_MODULE_1__.getFacetedUniqueValues),\n/* harmony export */   getFilteredRowModel: () => (/* reexport safe */ _tanstack_table_core__WEBPACK_IMPORTED_MODULE_1__.getFilteredRowModel),\n/* harmony export */   getGroupedRowModel: () => (/* reexport safe */ _tanstack_table_core__WEBPACK_IMPORTED_MODULE_1__.getGroupedRowModel),\n/* harmony export */   getPaginationRowModel: () => (/* reexport safe */ _tanstack_table_core__WEBPACK_IMPORTED_MODULE_1__.getPaginationRowModel),\n/* harmony export */   getSortedRowModel: () => (/* reexport safe */ _tanstack_table_core__WEBPACK_IMPORTED_MODULE_1__.getSortedRowModel),\n/* harmony export */   isFunction: () => (/* reexport safe */ _tanstack_table_core__WEBPACK_IMPORTED_MODULE_1__.isFunction),\n/* harmony export */   isNumberArray: () => (/* reexport safe */ _tanstack_table_core__WEBPACK_IMPORTED_MODULE_1__.isNumberArray),\n/* harmony export */   isRowSelected: () => (/* reexport safe */ _tanstack_table_core__WEBPACK_IMPORTED_MODULE_1__.isRowSelected),\n/* harmony export */   isSubRowSelected: () => (/* reexport safe */ _tanstack_table_core__WEBPACK_IMPORTED_MODULE_1__.isSubRowSelected),\n/* harmony export */   makeStateUpdater: () => (/* reexport safe */ _tanstack_table_core__WEBPACK_IMPORTED_MODULE_1__.makeStateUpdater),\n/* harmony export */   memo: () => (/* reexport safe */ _tanstack_table_core__WEBPACK_IMPORTED_MODULE_1__.memo),\n/* harmony export */   noop: () => (/* reexport safe */ _tanstack_table_core__WEBPACK_IMPORTED_MODULE_1__.noop),\n/* harmony export */   orderColumns: () => (/* reexport safe */ _tanstack_table_core__WEBPACK_IMPORTED_MODULE_1__.orderColumns),\n/* harmony export */   passiveEventSupported: () => (/* reexport safe */ _tanstack_table_core__WEBPACK_IMPORTED_MODULE_1__.passiveEventSupported),\n/* harmony export */   reSplitAlphaNumeric: () => (/* reexport safe */ _tanstack_table_core__WEBPACK_IMPORTED_MODULE_1__.reSplitAlphaNumeric),\n/* harmony export */   selectRowsFn: () => (/* reexport safe */ _tanstack_table_core__WEBPACK_IMPORTED_MODULE_1__.selectRowsFn),\n/* harmony export */   shouldAutoRemoveFilter: () => (/* reexport safe */ _tanstack_table_core__WEBPACK_IMPORTED_MODULE_1__.shouldAutoRemoveFilter),\n/* harmony export */   sortingFns: () => (/* reexport safe */ _tanstack_table_core__WEBPACK_IMPORTED_MODULE_1__.sortingFns),\n/* harmony export */   useReactTable: () => (/* binding */ useReactTable)\n/* harmony export */ });\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react */ \"(ssr)/./node_modules/next/dist/server/future/route-modules/app-page/vendored/ssr/react.js\");\n/* harmony import */ var _tanstack_table_core__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @tanstack/table-core */ \"(ssr)/./node_modules/@tanstack/table-core/build/lib/index.mjs\");\n/**\n * react-table\n *\n * Copyright (c) TanStack\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE.md file in the root directory of this source tree.\n *\n * @license MIT\n */ \n\n\n//\n/**\n * If rendering headers, cells, or footers with custom markup, use flexRender instead of `cell.getValue()` or `cell.renderValue()`.\n */ function flexRender(Comp, props) {\n    return !Comp ? null : isReactComponent(Comp) ? /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0__.createElement(Comp, props) : Comp;\n}\nfunction isReactComponent(component) {\n    return isClassComponent(component) || typeof component === \"function\" || isExoticComponent(component);\n}\nfunction isClassComponent(component) {\n    return typeof component === \"function\" && (()=>{\n        const proto = Object.getPrototypeOf(component);\n        return proto.prototype && proto.prototype.isReactComponent;\n    })();\n}\nfunction isExoticComponent(component) {\n    return typeof component === \"object\" && typeof component.$$typeof === \"symbol\" && [\n        \"react.memo\",\n        \"react.forward_ref\"\n    ].includes(component.$$typeof.description);\n}\nfunction useReactTable(options) {\n    // Compose in the generic options to the user options\n    const resolvedOptions = {\n        state: {},\n        // Dummy state\n        onStateChange: ()=>{},\n        // noop\n        renderFallbackValue: null,\n        ...options\n    };\n    // Create a new table and store it in state\n    const [tableRef] = react__WEBPACK_IMPORTED_MODULE_0__.useState(()=>({\n            current: (0,_tanstack_table_core__WEBPACK_IMPORTED_MODULE_1__.createTable)(resolvedOptions)\n        }));\n    // By default, manage table state here using the table's initial state\n    const [state, setState] = react__WEBPACK_IMPORTED_MODULE_0__.useState(()=>tableRef.current.initialState);\n    // Compose the default state above with any user state. This will allow the user\n    // to only control a subset of the state if desired.\n    tableRef.current.setOptions((prev)=>({\n            ...prev,\n            ...options,\n            state: {\n                ...state,\n                ...options.state\n            },\n            // Similarly, we'll maintain both our internal state and any user-provided\n            // state.\n            onStateChange: (updater)=>{\n                setState(updater);\n                options.onStateChange == null || options.onStateChange(updater);\n            }\n        }));\n    return tableRef.current;\n}\n //# sourceMappingURL=index.mjs.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQHRhbnN0YWNrL3JlYWN0LXRhYmxlL2J1aWxkL2xpYi9pbmRleC5tanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQUFBOzs7Ozs7Ozs7Q0FTQyxHQUM4QjtBQUNvQjtBQUNkO0FBRXJDLEVBQUU7QUFFRjs7Q0FFQyxHQUNELFNBQVNFLFdBQVdDLElBQUksRUFBRUMsS0FBSztJQUM3QixPQUFPLENBQUNELE9BQU8sT0FBT0UsaUJBQWlCRixRQUFRLFdBQVcsR0FBRUgsZ0RBQW1CLENBQUNHLE1BQU1DLFNBQVNEO0FBQ2pHO0FBQ0EsU0FBU0UsaUJBQWlCRSxTQUFTO0lBQ2pDLE9BQU9DLGlCQUFpQkQsY0FBYyxPQUFPQSxjQUFjLGNBQWNFLGtCQUFrQkY7QUFDN0Y7QUFDQSxTQUFTQyxpQkFBaUJELFNBQVM7SUFDakMsT0FBTyxPQUFPQSxjQUFjLGNBQWMsQ0FBQztRQUN6QyxNQUFNRyxRQUFRQyxPQUFPQyxjQUFjLENBQUNMO1FBQ3BDLE9BQU9HLE1BQU1HLFNBQVMsSUFBSUgsTUFBTUcsU0FBUyxDQUFDUixnQkFBZ0I7SUFDNUQ7QUFDRjtBQUNBLFNBQVNJLGtCQUFrQkYsU0FBUztJQUNsQyxPQUFPLE9BQU9BLGNBQWMsWUFBWSxPQUFPQSxVQUFVTyxRQUFRLEtBQUssWUFBWTtRQUFDO1FBQWM7S0FBb0IsQ0FBQ0MsUUFBUSxDQUFDUixVQUFVTyxRQUFRLENBQUNFLFdBQVc7QUFDL0o7QUFDQSxTQUFTQyxjQUFjQyxPQUFPO0lBQzVCLHFEQUFxRDtJQUNyRCxNQUFNQyxrQkFBa0I7UUFDdEJDLE9BQU8sQ0FBQztRQUNSLGNBQWM7UUFDZEMsZUFBZSxLQUFPO1FBQ3RCLE9BQU87UUFDUEMscUJBQXFCO1FBQ3JCLEdBQUdKLE9BQU87SUFDWjtJQUVBLDJDQUEyQztJQUMzQyxNQUFNLENBQUNLLFNBQVMsR0FBR3ZCLDJDQUFjLENBQUMsSUFBTztZQUN2Q3lCLFNBQVN4QixpRUFBV0EsQ0FBQ2tCO1FBQ3ZCO0lBRUEsc0VBQXNFO0lBQ3RFLE1BQU0sQ0FBQ0MsT0FBT00sU0FBUyxHQUFHMUIsMkNBQWMsQ0FBQyxJQUFNdUIsU0FBU0UsT0FBTyxDQUFDRSxZQUFZO0lBRTVFLGdGQUFnRjtJQUNoRixvREFBb0Q7SUFDcERKLFNBQVNFLE9BQU8sQ0FBQ0csVUFBVSxDQUFDQyxDQUFBQSxPQUFTO1lBQ25DLEdBQUdBLElBQUk7WUFDUCxHQUFHWCxPQUFPO1lBQ1ZFLE9BQU87Z0JBQ0wsR0FBR0EsS0FBSztnQkFDUixHQUFHRixRQUFRRSxLQUFLO1lBQ2xCO1lBQ0EsMEVBQTBFO1lBQzFFLFNBQVM7WUFDVEMsZUFBZVMsQ0FBQUE7Z0JBQ2JKLFNBQVNJO2dCQUNUWixRQUFRRyxhQUFhLElBQUksUUFBUUgsUUFBUUcsYUFBYSxDQUFDUztZQUN6RDtRQUNGO0lBQ0EsT0FBT1AsU0FBU0UsT0FBTztBQUN6QjtBQUVxQyxDQUNyQyxrQ0FBa0MiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly92aXNpb24vLi9ub2RlX21vZHVsZXMvQHRhbnN0YWNrL3JlYWN0LXRhYmxlL2J1aWxkL2xpYi9pbmRleC5tanM/YTE2YyJdLCJzb3VyY2VzQ29udGVudCI6WyIvKipcbiAqIHJlYWN0LXRhYmxlXG4gKlxuICogQ29weXJpZ2h0IChjKSBUYW5TdGFja1xuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIE1JVCBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRS5tZCBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLlxuICpcbiAqIEBsaWNlbnNlIE1JVFxuICovXG5pbXBvcnQgKiBhcyBSZWFjdCBmcm9tICdyZWFjdCc7XG5pbXBvcnQgeyBjcmVhdGVUYWJsZSB9IGZyb20gJ0B0YW5zdGFjay90YWJsZS1jb3JlJztcbmV4cG9ydCAqIGZyb20gJ0B0YW5zdGFjay90YWJsZS1jb3JlJztcblxuLy9cblxuLyoqXG4gKiBJZiByZW5kZXJpbmcgaGVhZGVycywgY2VsbHMsIG9yIGZvb3RlcnMgd2l0aCBjdXN0b20gbWFya3VwLCB1c2UgZmxleFJlbmRlciBpbnN0ZWFkIG9mIGBjZWxsLmdldFZhbHVlKClgIG9yIGBjZWxsLnJlbmRlclZhbHVlKClgLlxuICovXG5mdW5jdGlvbiBmbGV4UmVuZGVyKENvbXAsIHByb3BzKSB7XG4gIHJldHVybiAhQ29tcCA/IG51bGwgOiBpc1JlYWN0Q29tcG9uZW50KENvbXApID8gLyojX19QVVJFX18qL1JlYWN0LmNyZWF0ZUVsZW1lbnQoQ29tcCwgcHJvcHMpIDogQ29tcDtcbn1cbmZ1bmN0aW9uIGlzUmVhY3RDb21wb25lbnQoY29tcG9uZW50KSB7XG4gIHJldHVybiBpc0NsYXNzQ29tcG9uZW50KGNvbXBvbmVudCkgfHwgdHlwZW9mIGNvbXBvbmVudCA9PT0gJ2Z1bmN0aW9uJyB8fCBpc0V4b3RpY0NvbXBvbmVudChjb21wb25lbnQpO1xufVxuZnVuY3Rpb24gaXNDbGFzc0NvbXBvbmVudChjb21wb25lbnQpIHtcbiAgcmV0dXJuIHR5cGVvZiBjb21wb25lbnQgPT09ICdmdW5jdGlvbicgJiYgKCgpID0+IHtcbiAgICBjb25zdCBwcm90byA9IE9iamVjdC5nZXRQcm90b3R5cGVPZihjb21wb25lbnQpO1xuICAgIHJldHVybiBwcm90by5wcm90b3R5cGUgJiYgcHJvdG8ucHJvdG90eXBlLmlzUmVhY3RDb21wb25lbnQ7XG4gIH0pKCk7XG59XG5mdW5jdGlvbiBpc0V4b3RpY0NvbXBvbmVudChjb21wb25lbnQpIHtcbiAgcmV0dXJuIHR5cGVvZiBjb21wb25lbnQgPT09ICdvYmplY3QnICYmIHR5cGVvZiBjb21wb25lbnQuJCR0eXBlb2YgPT09ICdzeW1ib2wnICYmIFsncmVhY3QubWVtbycsICdyZWFjdC5mb3J3YXJkX3JlZiddLmluY2x1ZGVzKGNvbXBvbmVudC4kJHR5cGVvZi5kZXNjcmlwdGlvbik7XG59XG5mdW5jdGlvbiB1c2VSZWFjdFRhYmxlKG9wdGlvbnMpIHtcbiAgLy8gQ29tcG9zZSBpbiB0aGUgZ2VuZXJpYyBvcHRpb25zIHRvIHRoZSB1c2VyIG9wdGlvbnNcbiAgY29uc3QgcmVzb2x2ZWRPcHRpb25zID0ge1xuICAgIHN0YXRlOiB7fSxcbiAgICAvLyBEdW1teSBzdGF0ZVxuICAgIG9uU3RhdGVDaGFuZ2U6ICgpID0+IHt9LFxuICAgIC8vIG5vb3BcbiAgICByZW5kZXJGYWxsYmFja1ZhbHVlOiBudWxsLFxuICAgIC4uLm9wdGlvbnNcbiAgfTtcblxuICAvLyBDcmVhdGUgYSBuZXcgdGFibGUgYW5kIHN0b3JlIGl0IGluIHN0YXRlXG4gIGNvbnN0IFt0YWJsZVJlZl0gPSBSZWFjdC51c2VTdGF0ZSgoKSA9PiAoe1xuICAgIGN1cnJlbnQ6IGNyZWF0ZVRhYmxlKHJlc29sdmVkT3B0aW9ucylcbiAgfSkpO1xuXG4gIC8vIEJ5IGRlZmF1bHQsIG1hbmFnZSB0YWJsZSBzdGF0ZSBoZXJlIHVzaW5nIHRoZSB0YWJsZSdzIGluaXRpYWwgc3RhdGVcbiAgY29uc3QgW3N0YXRlLCBzZXRTdGF0ZV0gPSBSZWFjdC51c2VTdGF0ZSgoKSA9PiB0YWJsZVJlZi5jdXJyZW50LmluaXRpYWxTdGF0ZSk7XG5cbiAgLy8gQ29tcG9zZSB0aGUgZGVmYXVsdCBzdGF0ZSBhYm92ZSB3aXRoIGFueSB1c2VyIHN0YXRlLiBUaGlzIHdpbGwgYWxsb3cgdGhlIHVzZXJcbiAgLy8gdG8gb25seSBjb250cm9sIGEgc3Vic2V0IG9mIHRoZSBzdGF0ZSBpZiBkZXNpcmVkLlxuICB0YWJsZVJlZi5jdXJyZW50LnNldE9wdGlvbnMocHJldiA9PiAoe1xuICAgIC4uLnByZXYsXG4gICAgLi4ub3B0aW9ucyxcbiAgICBzdGF0ZToge1xuICAgICAgLi4uc3RhdGUsXG4gICAgICAuLi5vcHRpb25zLnN0YXRlXG4gICAgfSxcbiAgICAvLyBTaW1pbGFybHksIHdlJ2xsIG1haW50YWluIGJvdGggb3VyIGludGVybmFsIHN0YXRlIGFuZCBhbnkgdXNlci1wcm92aWRlZFxuICAgIC8vIHN0YXRlLlxuICAgIG9uU3RhdGVDaGFuZ2U6IHVwZGF0ZXIgPT4ge1xuICAgICAgc2V0U3RhdGUodXBkYXRlcik7XG4gICAgICBvcHRpb25zLm9uU3RhdGVDaGFuZ2UgPT0gbnVsbCB8fCBvcHRpb25zLm9uU3RhdGVDaGFuZ2UodXBkYXRlcik7XG4gICAgfVxuICB9KSk7XG4gIHJldHVybiB0YWJsZVJlZi5jdXJyZW50O1xufVxuXG5leHBvcnQgeyBmbGV4UmVuZGVyLCB1c2VSZWFjdFRhYmxlIH07XG4vLyMgc291cmNlTWFwcGluZ1VSTD1pbmRleC5tanMubWFwXG4iXSwibmFtZXMiOlsiUmVhY3QiLCJjcmVhdGVUYWJsZSIsImZsZXhSZW5kZXIiLCJDb21wIiwicHJvcHMiLCJpc1JlYWN0Q29tcG9uZW50IiwiY3JlYXRlRWxlbWVudCIsImNvbXBvbmVudCIsImlzQ2xhc3NDb21wb25lbnQiLCJpc0V4b3RpY0NvbXBvbmVudCIsInByb3RvIiwiT2JqZWN0IiwiZ2V0UHJvdG90eXBlT2YiLCJwcm90b3R5cGUiLCIkJHR5cGVvZiIsImluY2x1ZGVzIiwiZGVzY3JpcHRpb24iLCJ1c2VSZWFjdFRhYmxlIiwib3B0aW9ucyIsInJlc29sdmVkT3B0aW9ucyIsInN0YXRlIiwib25TdGF0ZUNoYW5nZSIsInJlbmRlckZhbGxiYWNrVmFsdWUiLCJ0YWJsZVJlZiIsInVzZVN0YXRlIiwiY3VycmVudCIsInNldFN0YXRlIiwiaW5pdGlhbFN0YXRlIiwic2V0T3B0aW9ucyIsInByZXYiLCJ1cGRhdGVyIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@tanstack/react-table/build/lib/index.mjs\n");

/***/ }),

/***/ "(ssr)/./node_modules/@tanstack/react-virtual/build/lib/_virtual/_rollupPluginBabelHelpers.mjs":
/*!***********************************************************************************************!*\
  !*** ./node_modules/@tanstack/react-virtual/build/lib/_virtual/_rollupPluginBabelHelpers.mjs ***!
  \***********************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"extends\": () => (/* binding */ _extends)\n/* harmony export */ });\n/**\n * react-virtual\n *\n * Copyright (c) TanStack\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE.md file in the root directory of this source tree.\n *\n * @license MIT\n */ function _extends() {\n    _extends = Object.assign ? Object.assign.bind() : function(target) {\n        for(var i = 1; i < arguments.length; i++){\n            var source = arguments[i];\n            for(var key in source){\n                if (Object.prototype.hasOwnProperty.call(source, key)) {\n                    target[key] = source[key];\n                }\n            }\n        }\n        return target;\n    };\n    return _extends.apply(this, arguments);\n}\n //# sourceMappingURL=_rollupPluginBabelHelpers.mjs.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQHRhbnN0YWNrL3JlYWN0LXZpcnR1YWwvYnVpbGQvbGliL192aXJ0dWFsL19yb2xsdXBQbHVnaW5CYWJlbEhlbHBlcnMubWpzIiwibWFwcGluZ3MiOiI7Ozs7QUFBQTs7Ozs7Ozs7O0NBU0MsR0FDRCxTQUFTQTtJQUNQQSxXQUFXQyxPQUFPQyxNQUFNLEdBQUdELE9BQU9DLE1BQU0sQ0FBQ0MsSUFBSSxLQUFLLFNBQVVDLE1BQU07UUFDaEUsSUFBSyxJQUFJQyxJQUFJLEdBQUdBLElBQUlDLFVBQVVDLE1BQU0sRUFBRUYsSUFBSztZQUN6QyxJQUFJRyxTQUFTRixTQUFTLENBQUNELEVBQUU7WUFDekIsSUFBSyxJQUFJSSxPQUFPRCxPQUFRO2dCQUN0QixJQUFJUCxPQUFPUyxTQUFTLENBQUNDLGNBQWMsQ0FBQ0MsSUFBSSxDQUFDSixRQUFRQyxNQUFNO29CQUNyREwsTUFBTSxDQUFDSyxJQUFJLEdBQUdELE1BQU0sQ0FBQ0MsSUFBSTtnQkFDM0I7WUFDRjtRQUNGO1FBQ0EsT0FBT0w7SUFDVDtJQUNBLE9BQU9KLFNBQVNhLEtBQUssQ0FBQyxJQUFJLEVBQUVQO0FBQzlCO0FBRStCLENBQy9CLHNEQUFzRCIsInNvdXJjZXMiOlsid2VicGFjazovL3Zpc2lvbi8uL25vZGVfbW9kdWxlcy9AdGFuc3RhY2svcmVhY3QtdmlydHVhbC9idWlsZC9saWIvX3ZpcnR1YWwvX3JvbGx1cFBsdWdpbkJhYmVsSGVscGVycy5tanM/MDNiMSJdLCJzb3VyY2VzQ29udGVudCI6WyIvKipcbiAqIHJlYWN0LXZpcnR1YWxcbiAqXG4gKiBDb3B5cmlnaHQgKGMpIFRhblN0YWNrXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgTUlUIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFLm1kIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuXG4gKlxuICogQGxpY2Vuc2UgTUlUXG4gKi9cbmZ1bmN0aW9uIF9leHRlbmRzKCkge1xuICBfZXh0ZW5kcyA9IE9iamVjdC5hc3NpZ24gPyBPYmplY3QuYXNzaWduLmJpbmQoKSA6IGZ1bmN0aW9uICh0YXJnZXQpIHtcbiAgICBmb3IgKHZhciBpID0gMTsgaSA8IGFyZ3VtZW50cy5sZW5ndGg7IGkrKykge1xuICAgICAgdmFyIHNvdXJjZSA9IGFyZ3VtZW50c1tpXTtcbiAgICAgIGZvciAodmFyIGtleSBpbiBzb3VyY2UpIHtcbiAgICAgICAgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChzb3VyY2UsIGtleSkpIHtcbiAgICAgICAgICB0YXJnZXRba2V5XSA9IHNvdXJjZVtrZXldO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiB0YXJnZXQ7XG4gIH07XG4gIHJldHVybiBfZXh0ZW5kcy5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xufVxuXG5leHBvcnQgeyBfZXh0ZW5kcyBhcyBleHRlbmRzIH07XG4vLyMgc291cmNlTWFwcGluZ1VSTD1fcm9sbHVwUGx1Z2luQmFiZWxIZWxwZXJzLm1qcy5tYXBcbiJdLCJuYW1lcyI6WyJfZXh0ZW5kcyIsIk9iamVjdCIsImFzc2lnbiIsImJpbmQiLCJ0YXJnZXQiLCJpIiwiYXJndW1lbnRzIiwibGVuZ3RoIiwic291cmNlIiwia2V5IiwicHJvdG90eXBlIiwiaGFzT3duUHJvcGVydHkiLCJjYWxsIiwiYXBwbHkiLCJleHRlbmRzIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@tanstack/react-virtual/build/lib/_virtual/_rollupPluginBabelHelpers.mjs\n");

/***/ }),

/***/ "(ssr)/./node_modules/@tanstack/react-virtual/build/lib/index.mjs":
/*!******************************************************************!*\
  !*** ./node_modules/@tanstack/react-virtual/build/lib/index.mjs ***!
  \******************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   Virtualizer: () => (/* reexport safe */ _tanstack_virtual_core__WEBPACK_IMPORTED_MODULE_2__.Virtualizer),\n/* harmony export */   approxEqual: () => (/* reexport safe */ _tanstack_virtual_core__WEBPACK_IMPORTED_MODULE_2__.approxEqual),\n/* harmony export */   defaultKeyExtractor: () => (/* reexport safe */ _tanstack_virtual_core__WEBPACK_IMPORTED_MODULE_2__.defaultKeyExtractor),\n/* harmony export */   defaultRangeExtractor: () => (/* reexport safe */ _tanstack_virtual_core__WEBPACK_IMPORTED_MODULE_2__.defaultRangeExtractor),\n/* harmony export */   elementScroll: () => (/* reexport safe */ _tanstack_virtual_core__WEBPACK_IMPORTED_MODULE_2__.elementScroll),\n/* harmony export */   measureElement: () => (/* reexport safe */ _tanstack_virtual_core__WEBPACK_IMPORTED_MODULE_2__.measureElement),\n/* harmony export */   memo: () => (/* reexport safe */ _tanstack_virtual_core__WEBPACK_IMPORTED_MODULE_2__.memo),\n/* harmony export */   notUndefined: () => (/* reexport safe */ _tanstack_virtual_core__WEBPACK_IMPORTED_MODULE_2__.notUndefined),\n/* harmony export */   observeElementOffset: () => (/* reexport safe */ _tanstack_virtual_core__WEBPACK_IMPORTED_MODULE_2__.observeElementOffset),\n/* harmony export */   observeElementRect: () => (/* reexport safe */ _tanstack_virtual_core__WEBPACK_IMPORTED_MODULE_2__.observeElementRect),\n/* harmony export */   observeWindowOffset: () => (/* reexport safe */ _tanstack_virtual_core__WEBPACK_IMPORTED_MODULE_2__.observeWindowOffset),\n/* harmony export */   observeWindowRect: () => (/* reexport safe */ _tanstack_virtual_core__WEBPACK_IMPORTED_MODULE_2__.observeWindowRect),\n/* harmony export */   useVirtualizer: () => (/* binding */ useVirtualizer),\n/* harmony export */   useWindowVirtualizer: () => (/* binding */ useWindowVirtualizer),\n/* harmony export */   windowScroll: () => (/* reexport safe */ _tanstack_virtual_core__WEBPACK_IMPORTED_MODULE_2__.windowScroll)\n/* harmony export */ });\n/* harmony import */ var _virtual_rollupPluginBabelHelpers_mjs__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./_virtual/_rollupPluginBabelHelpers.mjs */ \"(ssr)/./node_modules/@tanstack/react-virtual/build/lib/_virtual/_rollupPluginBabelHelpers.mjs\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react */ \"(ssr)/./node_modules/next/dist/server/future/route-modules/app-page/vendored/ssr/react.js\");\n/* harmony import */ var react_dom__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! react-dom */ \"(ssr)/./node_modules/next/dist/server/future/route-modules/app-page/vendored/ssr/react-dom.js\");\n/* harmony import */ var _tanstack_virtual_core__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @tanstack/virtual-core */ \"(ssr)/./node_modules/@tanstack/virtual-core/build/lib/index.mjs\");\n/**\n * react-virtual\n *\n * Copyright (c) TanStack\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE.md file in the root directory of this source tree.\n *\n * @license MIT\n */ \n\n\n\n\n//\nvar useIsomorphicLayoutEffect = typeof document !== \"undefined\" ? react__WEBPACK_IMPORTED_MODULE_0__.useLayoutEffect : react__WEBPACK_IMPORTED_MODULE_0__.useEffect;\nfunction useVirtualizerBase(options) {\n    var rerender = react__WEBPACK_IMPORTED_MODULE_0__.useReducer(function() {\n        return {};\n    }, {})[1];\n    var resolvedOptions = (0,_virtual_rollupPluginBabelHelpers_mjs__WEBPACK_IMPORTED_MODULE_3__[\"extends\"])({}, options, {\n        onChange: function onChange(instance, sync) {\n            if (sync) {\n                (0,react_dom__WEBPACK_IMPORTED_MODULE_1__.flushSync)(rerender);\n            } else {\n                rerender();\n            }\n            options.onChange == null || options.onChange(instance, sync);\n        }\n    });\n    var _React$useState = react__WEBPACK_IMPORTED_MODULE_0__.useState(function() {\n        return new _tanstack_virtual_core__WEBPACK_IMPORTED_MODULE_2__.Virtualizer(resolvedOptions);\n    }), instance = _React$useState[0];\n    instance.setOptions(resolvedOptions);\n    react__WEBPACK_IMPORTED_MODULE_0__.useEffect(function() {\n        return instance._didMount();\n    }, []);\n    useIsomorphicLayoutEffect(function() {\n        return instance._willUpdate();\n    });\n    return instance;\n}\nfunction useVirtualizer(options) {\n    return useVirtualizerBase((0,_virtual_rollupPluginBabelHelpers_mjs__WEBPACK_IMPORTED_MODULE_3__[\"extends\"])({\n        observeElementRect: _tanstack_virtual_core__WEBPACK_IMPORTED_MODULE_2__.observeElementRect,\n        observeElementOffset: _tanstack_virtual_core__WEBPACK_IMPORTED_MODULE_2__.observeElementOffset,\n        scrollToFn: _tanstack_virtual_core__WEBPACK_IMPORTED_MODULE_2__.elementScroll\n    }, options));\n}\nfunction useWindowVirtualizer(options) {\n    return useVirtualizerBase((0,_virtual_rollupPluginBabelHelpers_mjs__WEBPACK_IMPORTED_MODULE_3__[\"extends\"])({\n        getScrollElement: function getScrollElement() {\n            return typeof document !== \"undefined\" ? window : null;\n        },\n        observeElementRect: _tanstack_virtual_core__WEBPACK_IMPORTED_MODULE_2__.observeWindowRect,\n        observeElementOffset: _tanstack_virtual_core__WEBPACK_IMPORTED_MODULE_2__.observeWindowOffset,\n        scrollToFn: _tanstack_virtual_core__WEBPACK_IMPORTED_MODULE_2__.windowScroll,\n        initialOffset: typeof document !== \"undefined\" ? window.scrollY : undefined\n    }, options));\n}\n //# sourceMappingURL=index.mjs.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQHRhbnN0YWNrL3JlYWN0LXZpcnR1YWwvYnVpbGQvbGliL2luZGV4Lm1qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBQUE7Ozs7Ozs7OztDQVNDLEdBQzhFO0FBQ2hEO0FBQ087QUFDOEg7QUFDN0g7QUFFdkMsRUFBRTtBQUVGLElBQUlXLDRCQUE0QixPQUFPQyxhQUFhLGNBQWNWLGtEQUFxQixHQUFHQSw0Q0FBZTtBQUN6RyxTQUFTYSxtQkFBbUJDLE9BQU87SUFDakMsSUFBSUMsV0FBV2YsNkNBQWdCLENBQUM7UUFDOUIsT0FBTyxDQUFDO0lBQ1YsR0FBRyxDQUFDLEVBQUUsQ0FBQyxFQUFFO0lBQ1QsSUFBSWlCLGtCQUFrQmxCLGlGQUFRQSxDQUFDLENBQUMsR0FBR2UsU0FBUztRQUMxQ0ksVUFBVSxTQUFTQSxTQUFTQyxRQUFRLEVBQUVDLElBQUk7WUFDeEMsSUFBSUEsTUFBTTtnQkFDUm5CLG9EQUFTQSxDQUFDYztZQUNaLE9BQU87Z0JBQ0xBO1lBQ0Y7WUFDQUQsUUFBUUksUUFBUSxJQUFJLFFBQVFKLFFBQVFJLFFBQVEsQ0FBQ0MsVUFBVUM7UUFDekQ7SUFDRjtJQUNBLElBQUlDLGtCQUFrQnJCLDJDQUFjLENBQUM7UUFDakMsT0FBTyxJQUFJUSwrREFBV0EsQ0FBQ1M7SUFDekIsSUFDQUUsV0FBV0UsZUFBZSxDQUFDLEVBQUU7SUFDL0JGLFNBQVNJLFVBQVUsQ0FBQ047SUFDcEJqQiw0Q0FBZSxDQUFDO1FBQ2QsT0FBT21CLFNBQVNLLFNBQVM7SUFDM0IsR0FBRyxFQUFFO0lBQ0xmLDBCQUEwQjtRQUN4QixPQUFPVSxTQUFTTSxXQUFXO0lBQzdCO0lBQ0EsT0FBT047QUFDVDtBQUNBLFNBQVNPLGVBQWVaLE9BQU87SUFDN0IsT0FBT0QsbUJBQW1CZCxpRkFBUUEsQ0FBQztRQUNqQ0csb0JBQW9CQSxzRUFBa0JBO1FBQ3RDQyxzQkFBc0JBLHdFQUFvQkE7UUFDMUN3QixZQUFZdkIsaUVBQWFBO0lBQzNCLEdBQUdVO0FBQ0w7QUFDQSxTQUFTYyxxQkFBcUJkLE9BQU87SUFDbkMsT0FBT0QsbUJBQW1CZCxpRkFBUUEsQ0FBQztRQUNqQzhCLGtCQUFrQixTQUFTQTtZQUN6QixPQUFPLE9BQU9uQixhQUFhLGNBQWNvQixTQUFTO1FBQ3BEO1FBQ0E1QixvQkFBb0JHLHFFQUFpQkE7UUFDckNGLHNCQUFzQkcsdUVBQW1CQTtRQUN6Q3FCLFlBQVlwQixnRUFBWUE7UUFDeEJ3QixlQUFlLE9BQU9yQixhQUFhLGNBQWNvQixPQUFPRSxPQUFPLEdBQUdDO0lBQ3BFLEdBQUduQjtBQUNMO0FBRWdELENBQ2hELGtDQUFrQyIsInNvdXJjZXMiOlsid2VicGFjazovL3Zpc2lvbi8uL25vZGVfbW9kdWxlcy9AdGFuc3RhY2svcmVhY3QtdmlydHVhbC9idWlsZC9saWIvaW5kZXgubWpzPzBjNjYiXSwic291cmNlc0NvbnRlbnQiOlsiLyoqXG4gKiByZWFjdC12aXJ0dWFsXG4gKlxuICogQ29weXJpZ2h0IChjKSBUYW5TdGFja1xuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIE1JVCBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRS5tZCBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLlxuICpcbiAqIEBsaWNlbnNlIE1JVFxuICovXG5pbXBvcnQgeyBleHRlbmRzIGFzIF9leHRlbmRzIH0gZnJvbSAnLi9fdmlydHVhbC9fcm9sbHVwUGx1Z2luQmFiZWxIZWxwZXJzLm1qcyc7XG5pbXBvcnQgKiBhcyBSZWFjdCBmcm9tICdyZWFjdCc7XG5pbXBvcnQgeyBmbHVzaFN5bmMgfSBmcm9tICdyZWFjdC1kb20nO1xuaW1wb3J0IHsgb2JzZXJ2ZUVsZW1lbnRSZWN0LCBvYnNlcnZlRWxlbWVudE9mZnNldCwgZWxlbWVudFNjcm9sbCwgb2JzZXJ2ZVdpbmRvd1JlY3QsIG9ic2VydmVXaW5kb3dPZmZzZXQsIHdpbmRvd1Njcm9sbCwgVmlydHVhbGl6ZXIgfSBmcm9tICdAdGFuc3RhY2svdmlydHVhbC1jb3JlJztcbmV4cG9ydCAqIGZyb20gJ0B0YW5zdGFjay92aXJ0dWFsLWNvcmUnO1xuXG4vL1xuXG52YXIgdXNlSXNvbW9ycGhpY0xheW91dEVmZmVjdCA9IHR5cGVvZiBkb2N1bWVudCAhPT0gJ3VuZGVmaW5lZCcgPyBSZWFjdC51c2VMYXlvdXRFZmZlY3QgOiBSZWFjdC51c2VFZmZlY3Q7XG5mdW5jdGlvbiB1c2VWaXJ0dWFsaXplckJhc2Uob3B0aW9ucykge1xuICB2YXIgcmVyZW5kZXIgPSBSZWFjdC51c2VSZWR1Y2VyKGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4ge307XG4gIH0sIHt9KVsxXTtcbiAgdmFyIHJlc29sdmVkT3B0aW9ucyA9IF9leHRlbmRzKHt9LCBvcHRpb25zLCB7XG4gICAgb25DaGFuZ2U6IGZ1bmN0aW9uIG9uQ2hhbmdlKGluc3RhbmNlLCBzeW5jKSB7XG4gICAgICBpZiAoc3luYykge1xuICAgICAgICBmbHVzaFN5bmMocmVyZW5kZXIpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmVyZW5kZXIoKTtcbiAgICAgIH1cbiAgICAgIG9wdGlvbnMub25DaGFuZ2UgPT0gbnVsbCB8fCBvcHRpb25zLm9uQ2hhbmdlKGluc3RhbmNlLCBzeW5jKTtcbiAgICB9XG4gIH0pO1xuICB2YXIgX1JlYWN0JHVzZVN0YXRlID0gUmVhY3QudXNlU3RhdGUoZnVuY3Rpb24gKCkge1xuICAgICAgcmV0dXJuIG5ldyBWaXJ0dWFsaXplcihyZXNvbHZlZE9wdGlvbnMpO1xuICAgIH0pLFxuICAgIGluc3RhbmNlID0gX1JlYWN0JHVzZVN0YXRlWzBdO1xuICBpbnN0YW5jZS5zZXRPcHRpb25zKHJlc29sdmVkT3B0aW9ucyk7XG4gIFJlYWN0LnVzZUVmZmVjdChmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIGluc3RhbmNlLl9kaWRNb3VudCgpO1xuICB9LCBbXSk7XG4gIHVzZUlzb21vcnBoaWNMYXlvdXRFZmZlY3QoZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiBpbnN0YW5jZS5fd2lsbFVwZGF0ZSgpO1xuICB9KTtcbiAgcmV0dXJuIGluc3RhbmNlO1xufVxuZnVuY3Rpb24gdXNlVmlydHVhbGl6ZXIob3B0aW9ucykge1xuICByZXR1cm4gdXNlVmlydHVhbGl6ZXJCYXNlKF9leHRlbmRzKHtcbiAgICBvYnNlcnZlRWxlbWVudFJlY3Q6IG9ic2VydmVFbGVtZW50UmVjdCxcbiAgICBvYnNlcnZlRWxlbWVudE9mZnNldDogb2JzZXJ2ZUVsZW1lbnRPZmZzZXQsXG4gICAgc2Nyb2xsVG9GbjogZWxlbWVudFNjcm9sbFxuICB9LCBvcHRpb25zKSk7XG59XG5mdW5jdGlvbiB1c2VXaW5kb3dWaXJ0dWFsaXplcihvcHRpb25zKSB7XG4gIHJldHVybiB1c2VWaXJ0dWFsaXplckJhc2UoX2V4dGVuZHMoe1xuICAgIGdldFNjcm9sbEVsZW1lbnQ6IGZ1bmN0aW9uIGdldFNjcm9sbEVsZW1lbnQoKSB7XG4gICAgICByZXR1cm4gdHlwZW9mIGRvY3VtZW50ICE9PSAndW5kZWZpbmVkJyA/IHdpbmRvdyA6IG51bGw7XG4gICAgfSxcbiAgICBvYnNlcnZlRWxlbWVudFJlY3Q6IG9ic2VydmVXaW5kb3dSZWN0LFxuICAgIG9ic2VydmVFbGVtZW50T2Zmc2V0OiBvYnNlcnZlV2luZG93T2Zmc2V0LFxuICAgIHNjcm9sbFRvRm46IHdpbmRvd1Njcm9sbCxcbiAgICBpbml0aWFsT2Zmc2V0OiB0eXBlb2YgZG9jdW1lbnQgIT09ICd1bmRlZmluZWQnID8gd2luZG93LnNjcm9sbFkgOiB1bmRlZmluZWRcbiAgfSwgb3B0aW9ucykpO1xufVxuXG5leHBvcnQgeyB1c2VWaXJ0dWFsaXplciwgdXNlV2luZG93VmlydHVhbGl6ZXIgfTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWluZGV4Lm1qcy5tYXBcbiJdLCJuYW1lcyI6WyJleHRlbmRzIiwiX2V4dGVuZHMiLCJSZWFjdCIsImZsdXNoU3luYyIsIm9ic2VydmVFbGVtZW50UmVjdCIsIm9ic2VydmVFbGVtZW50T2Zmc2V0IiwiZWxlbWVudFNjcm9sbCIsIm9ic2VydmVXaW5kb3dSZWN0Iiwib2JzZXJ2ZVdpbmRvd09mZnNldCIsIndpbmRvd1Njcm9sbCIsIlZpcnR1YWxpemVyIiwidXNlSXNvbW9ycGhpY0xheW91dEVmZmVjdCIsImRvY3VtZW50IiwidXNlTGF5b3V0RWZmZWN0IiwidXNlRWZmZWN0IiwidXNlVmlydHVhbGl6ZXJCYXNlIiwib3B0aW9ucyIsInJlcmVuZGVyIiwidXNlUmVkdWNlciIsInJlc29sdmVkT3B0aW9ucyIsIm9uQ2hhbmdlIiwiaW5zdGFuY2UiLCJzeW5jIiwiX1JlYWN0JHVzZVN0YXRlIiwidXNlU3RhdGUiLCJzZXRPcHRpb25zIiwiX2RpZE1vdW50IiwiX3dpbGxVcGRhdGUiLCJ1c2VWaXJ0dWFsaXplciIsInNjcm9sbFRvRm4iLCJ1c2VXaW5kb3dWaXJ0dWFsaXplciIsImdldFNjcm9sbEVsZW1lbnQiLCJ3aW5kb3ciLCJpbml0aWFsT2Zmc2V0Iiwic2Nyb2xsWSIsInVuZGVmaW5lZCJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@tanstack/react-virtual/build/lib/index.mjs\n");

/***/ }),

/***/ "(ssr)/./node_modules/@tanstack/table-core/build/lib/index.mjs":
/*!***************************************************************!*\
  !*** ./node_modules/@tanstack/table-core/build/lib/index.mjs ***!
  \***************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   ColumnSizing: () => (/* binding */ ColumnSizing),\n/* harmony export */   Expanding: () => (/* binding */ Expanding),\n/* harmony export */   Filters: () => (/* binding */ Filters),\n/* harmony export */   Grouping: () => (/* binding */ Grouping),\n/* harmony export */   Headers: () => (/* binding */ Headers),\n/* harmony export */   Ordering: () => (/* binding */ Ordering),\n/* harmony export */   Pagination: () => (/* binding */ Pagination),\n/* harmony export */   Pinning: () => (/* binding */ Pinning),\n/* harmony export */   RowSelection: () => (/* binding */ RowSelection),\n/* harmony export */   Sorting: () => (/* binding */ Sorting),\n/* harmony export */   Visibility: () => (/* binding */ Visibility),\n/* harmony export */   aggregationFns: () => (/* binding */ aggregationFns),\n/* harmony export */   buildHeaderGroups: () => (/* binding */ buildHeaderGroups),\n/* harmony export */   createCell: () => (/* binding */ createCell),\n/* harmony export */   createColumn: () => (/* binding */ createColumn),\n/* harmony export */   createColumnHelper: () => (/* binding */ createColumnHelper),\n/* harmony export */   createRow: () => (/* binding */ createRow),\n/* harmony export */   createTable: () => (/* binding */ createTable),\n/* harmony export */   defaultColumnSizing: () => (/* binding */ defaultColumnSizing),\n/* harmony export */   expandRows: () => (/* binding */ expandRows),\n/* harmony export */   filterFns: () => (/* binding */ filterFns),\n/* harmony export */   flattenBy: () => (/* binding */ flattenBy),\n/* harmony export */   functionalUpdate: () => (/* binding */ functionalUpdate),\n/* harmony export */   getCoreRowModel: () => (/* binding */ getCoreRowModel),\n/* harmony export */   getExpandedRowModel: () => (/* binding */ getExpandedRowModel),\n/* harmony export */   getFacetedMinMaxValues: () => (/* binding */ getFacetedMinMaxValues),\n/* harmony export */   getFacetedRowModel: () => (/* binding */ getFacetedRowModel),\n/* harmony export */   getFacetedUniqueValues: () => (/* binding */ getFacetedUniqueValues),\n/* harmony export */   getFilteredRowModel: () => (/* binding */ getFilteredRowModel),\n/* harmony export */   getGroupedRowModel: () => (/* binding */ getGroupedRowModel),\n/* harmony export */   getPaginationRowModel: () => (/* binding */ getPaginationRowModel),\n/* harmony export */   getSortedRowModel: () => (/* binding */ getSortedRowModel),\n/* harmony export */   isFunction: () => (/* binding */ isFunction),\n/* harmony export */   isNumberArray: () => (/* binding */ isNumberArray),\n/* harmony export */   isRowSelected: () => (/* binding */ isRowSelected),\n/* harmony export */   isSubRowSelected: () => (/* binding */ isSubRowSelected),\n/* harmony export */   makeStateUpdater: () => (/* binding */ makeStateUpdater),\n/* harmony export */   memo: () => (/* binding */ memo),\n/* harmony export */   noop: () => (/* binding */ noop),\n/* harmony export */   orderColumns: () => (/* binding */ orderColumns),\n/* harmony export */   passiveEventSupported: () => (/* binding */ passiveEventSupported),\n/* harmony export */   reSplitAlphaNumeric: () => (/* binding */ reSplitAlphaNumeric),\n/* harmony export */   selectRowsFn: () => (/* binding */ selectRowsFn),\n/* harmony export */   shouldAutoRemoveFilter: () => (/* binding */ shouldAutoRemoveFilter),\n/* harmony export */   sortingFns: () => (/* binding */ sortingFns)\n/* harmony export */ });\n/**\n * table-core\n *\n * Copyright (c) TanStack\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE.md file in the root directory of this source tree.\n *\n * @license MIT\n */ // Is this type a tuple?\n// If this type is a tuple, what indices are allowed?\n///\nfunction functionalUpdate(updater, input) {\n    return typeof updater === \"function\" ? updater(input) : updater;\n}\nfunction noop() {\n//\n}\nfunction makeStateUpdater(key, instance) {\n    return (updater)=>{\n        instance.setState((old)=>{\n            return {\n                ...old,\n                [key]: functionalUpdate(updater, old[key])\n            };\n        });\n    };\n}\nfunction isFunction(d) {\n    return d instanceof Function;\n}\nfunction isNumberArray(d) {\n    return Array.isArray(d) && d.every((val)=>typeof val === \"number\");\n}\nfunction flattenBy(arr, getChildren) {\n    const flat = [];\n    const recurse = (subArr)=>{\n        subArr.forEach((item)=>{\n            flat.push(item);\n            const children = getChildren(item);\n            if (children != null && children.length) {\n                recurse(children);\n            }\n        });\n    };\n    recurse(arr);\n    return flat;\n}\nfunction memo(getDeps, fn, opts) {\n    let deps = [];\n    let result;\n    return ()=>{\n        let depTime;\n        if (opts.key && opts.debug) depTime = Date.now();\n        const newDeps = getDeps();\n        const depsChanged = newDeps.length !== deps.length || newDeps.some((dep, index)=>deps[index] !== dep);\n        if (!depsChanged) {\n            return result;\n        }\n        deps = newDeps;\n        let resultTime;\n        if (opts.key && opts.debug) resultTime = Date.now();\n        result = fn(...newDeps);\n        opts == null || opts.onChange == null || opts.onChange(result);\n        if (opts.key && opts.debug) {\n            if (opts != null && opts.debug()) {\n                const depEndTime = Math.round((Date.now() - depTime) * 100) / 100;\n                const resultEndTime = Math.round((Date.now() - resultTime) * 100) / 100;\n                const resultFpsPercentage = resultEndTime / 16;\n                const pad = (str, num)=>{\n                    str = String(str);\n                    while(str.length < num){\n                        str = \" \" + str;\n                    }\n                    return str;\n                };\n                console.info(`%c⏱ ${pad(resultEndTime, 5)} /${pad(depEndTime, 5)} ms`, `\n            font-size: .6rem;\n            font-weight: bold;\n            color: hsl(${Math.max(0, Math.min(120 - 120 * resultFpsPercentage, 120))}deg 100% 31%);`, opts == null ? void 0 : opts.key);\n            }\n        }\n        return result;\n    };\n}\nfunction createColumn(table, columnDef, depth, parent) {\n    var _ref, _resolvedColumnDef$id;\n    const defaultColumn = table._getDefaultColumnDef();\n    const resolvedColumnDef = {\n        ...defaultColumn,\n        ...columnDef\n    };\n    const accessorKey = resolvedColumnDef.accessorKey;\n    let id = (_ref = (_resolvedColumnDef$id = resolvedColumnDef.id) != null ? _resolvedColumnDef$id : accessorKey ? accessorKey.replace(\".\", \"_\") : undefined) != null ? _ref : typeof resolvedColumnDef.header === \"string\" ? resolvedColumnDef.header : undefined;\n    let accessorFn;\n    if (resolvedColumnDef.accessorFn) {\n        accessorFn = resolvedColumnDef.accessorFn;\n    } else if (accessorKey) {\n        // Support deep accessor keys\n        if (accessorKey.includes(\".\")) {\n            accessorFn = (originalRow)=>{\n                let result = originalRow;\n                for (const key of accessorKey.split(\".\")){\n                    var _result;\n                    result = (_result = result) == null ? void 0 : _result[key];\n                    if ( true && result === undefined) {\n                        console.warn(`\"${key}\" in deeply nested key \"${accessorKey}\" returned undefined.`);\n                    }\n                }\n                return result;\n            };\n        } else {\n            accessorFn = (originalRow)=>originalRow[resolvedColumnDef.accessorKey];\n        }\n    }\n    if (!id) {\n        if (true) {\n            throw new Error(resolvedColumnDef.accessorFn ? `Columns require an id when using an accessorFn` : `Columns require an id when using a non-string header`);\n        }\n        throw new Error();\n    }\n    let column = {\n        id: `${String(id)}`,\n        accessorFn,\n        parent: parent,\n        depth,\n        columnDef: resolvedColumnDef,\n        columns: [],\n        getFlatColumns: memo(()=>[\n                true\n            ], ()=>{\n            var _column$columns;\n            return [\n                column,\n                ...(_column$columns = column.columns) == null ? void 0 : _column$columns.flatMap((d)=>d.getFlatColumns())\n            ];\n        }, {\n            key:  false && 0,\n            debug: ()=>{\n                var _table$options$debugA;\n                return (_table$options$debugA = table.options.debugAll) != null ? _table$options$debugA : table.options.debugColumns;\n            }\n        }),\n        getLeafColumns: memo(()=>[\n                table._getOrderColumnsFn()\n            ], (orderColumns)=>{\n            var _column$columns2;\n            if ((_column$columns2 = column.columns) != null && _column$columns2.length) {\n                let leafColumns = column.columns.flatMap((column)=>column.getLeafColumns());\n                return orderColumns(leafColumns);\n            }\n            return [\n                column\n            ];\n        }, {\n            key:  false && 0,\n            debug: ()=>{\n                var _table$options$debugA2;\n                return (_table$options$debugA2 = table.options.debugAll) != null ? _table$options$debugA2 : table.options.debugColumns;\n            }\n        })\n    };\n    for (const feature of table._features){\n        feature.createColumn == null || feature.createColumn(column, table);\n    }\n    // Yes, we have to convert table to uknown, because we know more than the compiler here.\n    return column;\n}\n//\nfunction createHeader(table, column, options) {\n    var _options$id;\n    const id = (_options$id = options.id) != null ? _options$id : column.id;\n    let header = {\n        id,\n        column,\n        index: options.index,\n        isPlaceholder: !!options.isPlaceholder,\n        placeholderId: options.placeholderId,\n        depth: options.depth,\n        subHeaders: [],\n        colSpan: 0,\n        rowSpan: 0,\n        headerGroup: null,\n        getLeafHeaders: ()=>{\n            const leafHeaders = [];\n            const recurseHeader = (h)=>{\n                if (h.subHeaders && h.subHeaders.length) {\n                    h.subHeaders.map(recurseHeader);\n                }\n                leafHeaders.push(h);\n            };\n            recurseHeader(header);\n            return leafHeaders;\n        },\n        getContext: ()=>({\n                table,\n                header: header,\n                column\n            })\n    };\n    table._features.forEach((feature)=>{\n        feature.createHeader == null || feature.createHeader(header, table);\n    });\n    return header;\n}\nconst Headers = {\n    createTable: (table)=>{\n        // Header Groups\n        table.getHeaderGroups = memo(()=>[\n                table.getAllColumns(),\n                table.getVisibleLeafColumns(),\n                table.getState().columnPinning.left,\n                table.getState().columnPinning.right\n            ], (allColumns, leafColumns, left, right)=>{\n            var _left$map$filter, _right$map$filter;\n            const leftColumns = (_left$map$filter = left == null ? void 0 : left.map((columnId)=>leafColumns.find((d)=>d.id === columnId)).filter(Boolean)) != null ? _left$map$filter : [];\n            const rightColumns = (_right$map$filter = right == null ? void 0 : right.map((columnId)=>leafColumns.find((d)=>d.id === columnId)).filter(Boolean)) != null ? _right$map$filter : [];\n            const centerColumns = leafColumns.filter((column)=>!(left != null && left.includes(column.id)) && !(right != null && right.includes(column.id)));\n            const headerGroups = buildHeaderGroups(allColumns, [\n                ...leftColumns,\n                ...centerColumns,\n                ...rightColumns\n            ], table);\n            return headerGroups;\n        }, {\n            key:  true && \"getHeaderGroups\",\n            debug: ()=>{\n                var _table$options$debugA;\n                return (_table$options$debugA = table.options.debugAll) != null ? _table$options$debugA : table.options.debugHeaders;\n            }\n        });\n        table.getCenterHeaderGroups = memo(()=>[\n                table.getAllColumns(),\n                table.getVisibleLeafColumns(),\n                table.getState().columnPinning.left,\n                table.getState().columnPinning.right\n            ], (allColumns, leafColumns, left, right)=>{\n            leafColumns = leafColumns.filter((column)=>!(left != null && left.includes(column.id)) && !(right != null && right.includes(column.id)));\n            return buildHeaderGroups(allColumns, leafColumns, table, \"center\");\n        }, {\n            key:  true && \"getCenterHeaderGroups\",\n            debug: ()=>{\n                var _table$options$debugA2;\n                return (_table$options$debugA2 = table.options.debugAll) != null ? _table$options$debugA2 : table.options.debugHeaders;\n            }\n        });\n        table.getLeftHeaderGroups = memo(()=>[\n                table.getAllColumns(),\n                table.getVisibleLeafColumns(),\n                table.getState().columnPinning.left\n            ], (allColumns, leafColumns, left)=>{\n            var _left$map$filter2;\n            const orderedLeafColumns = (_left$map$filter2 = left == null ? void 0 : left.map((columnId)=>leafColumns.find((d)=>d.id === columnId)).filter(Boolean)) != null ? _left$map$filter2 : [];\n            return buildHeaderGroups(allColumns, orderedLeafColumns, table, \"left\");\n        }, {\n            key:  true && \"getLeftHeaderGroups\",\n            debug: ()=>{\n                var _table$options$debugA3;\n                return (_table$options$debugA3 = table.options.debugAll) != null ? _table$options$debugA3 : table.options.debugHeaders;\n            }\n        });\n        table.getRightHeaderGroups = memo(()=>[\n                table.getAllColumns(),\n                table.getVisibleLeafColumns(),\n                table.getState().columnPinning.right\n            ], (allColumns, leafColumns, right)=>{\n            var _right$map$filter2;\n            const orderedLeafColumns = (_right$map$filter2 = right == null ? void 0 : right.map((columnId)=>leafColumns.find((d)=>d.id === columnId)).filter(Boolean)) != null ? _right$map$filter2 : [];\n            return buildHeaderGroups(allColumns, orderedLeafColumns, table, \"right\");\n        }, {\n            key:  true && \"getRightHeaderGroups\",\n            debug: ()=>{\n                var _table$options$debugA4;\n                return (_table$options$debugA4 = table.options.debugAll) != null ? _table$options$debugA4 : table.options.debugHeaders;\n            }\n        });\n        // Footer Groups\n        table.getFooterGroups = memo(()=>[\n                table.getHeaderGroups()\n            ], (headerGroups)=>{\n            return [\n                ...headerGroups\n            ].reverse();\n        }, {\n            key:  true && \"getFooterGroups\",\n            debug: ()=>{\n                var _table$options$debugA5;\n                return (_table$options$debugA5 = table.options.debugAll) != null ? _table$options$debugA5 : table.options.debugHeaders;\n            }\n        });\n        table.getLeftFooterGroups = memo(()=>[\n                table.getLeftHeaderGroups()\n            ], (headerGroups)=>{\n            return [\n                ...headerGroups\n            ].reverse();\n        }, {\n            key:  true && \"getLeftFooterGroups\",\n            debug: ()=>{\n                var _table$options$debugA6;\n                return (_table$options$debugA6 = table.options.debugAll) != null ? _table$options$debugA6 : table.options.debugHeaders;\n            }\n        });\n        table.getCenterFooterGroups = memo(()=>[\n                table.getCenterHeaderGroups()\n            ], (headerGroups)=>{\n            return [\n                ...headerGroups\n            ].reverse();\n        }, {\n            key:  true && \"getCenterFooterGroups\",\n            debug: ()=>{\n                var _table$options$debugA7;\n                return (_table$options$debugA7 = table.options.debugAll) != null ? _table$options$debugA7 : table.options.debugHeaders;\n            }\n        });\n        table.getRightFooterGroups = memo(()=>[\n                table.getRightHeaderGroups()\n            ], (headerGroups)=>{\n            return [\n                ...headerGroups\n            ].reverse();\n        }, {\n            key:  true && \"getRightFooterGroups\",\n            debug: ()=>{\n                var _table$options$debugA8;\n                return (_table$options$debugA8 = table.options.debugAll) != null ? _table$options$debugA8 : table.options.debugHeaders;\n            }\n        });\n        // Flat Headers\n        table.getFlatHeaders = memo(()=>[\n                table.getHeaderGroups()\n            ], (headerGroups)=>{\n            return headerGroups.map((headerGroup)=>{\n                return headerGroup.headers;\n            }).flat();\n        }, {\n            key:  true && \"getFlatHeaders\",\n            debug: ()=>{\n                var _table$options$debugA9;\n                return (_table$options$debugA9 = table.options.debugAll) != null ? _table$options$debugA9 : table.options.debugHeaders;\n            }\n        });\n        table.getLeftFlatHeaders = memo(()=>[\n                table.getLeftHeaderGroups()\n            ], (left)=>{\n            return left.map((headerGroup)=>{\n                return headerGroup.headers;\n            }).flat();\n        }, {\n            key:  true && \"getLeftFlatHeaders\",\n            debug: ()=>{\n                var _table$options$debugA10;\n                return (_table$options$debugA10 = table.options.debugAll) != null ? _table$options$debugA10 : table.options.debugHeaders;\n            }\n        });\n        table.getCenterFlatHeaders = memo(()=>[\n                table.getCenterHeaderGroups()\n            ], (left)=>{\n            return left.map((headerGroup)=>{\n                return headerGroup.headers;\n            }).flat();\n        }, {\n            key:  true && \"getCenterFlatHeaders\",\n            debug: ()=>{\n                var _table$options$debugA11;\n                return (_table$options$debugA11 = table.options.debugAll) != null ? _table$options$debugA11 : table.options.debugHeaders;\n            }\n        });\n        table.getRightFlatHeaders = memo(()=>[\n                table.getRightHeaderGroups()\n            ], (left)=>{\n            return left.map((headerGroup)=>{\n                return headerGroup.headers;\n            }).flat();\n        }, {\n            key:  true && \"getRightFlatHeaders\",\n            debug: ()=>{\n                var _table$options$debugA12;\n                return (_table$options$debugA12 = table.options.debugAll) != null ? _table$options$debugA12 : table.options.debugHeaders;\n            }\n        });\n        // Leaf Headers\n        table.getCenterLeafHeaders = memo(()=>[\n                table.getCenterFlatHeaders()\n            ], (flatHeaders)=>{\n            return flatHeaders.filter((header)=>{\n                var _header$subHeaders;\n                return !((_header$subHeaders = header.subHeaders) != null && _header$subHeaders.length);\n            });\n        }, {\n            key:  true && \"getCenterLeafHeaders\",\n            debug: ()=>{\n                var _table$options$debugA13;\n                return (_table$options$debugA13 = table.options.debugAll) != null ? _table$options$debugA13 : table.options.debugHeaders;\n            }\n        });\n        table.getLeftLeafHeaders = memo(()=>[\n                table.getLeftFlatHeaders()\n            ], (flatHeaders)=>{\n            return flatHeaders.filter((header)=>{\n                var _header$subHeaders2;\n                return !((_header$subHeaders2 = header.subHeaders) != null && _header$subHeaders2.length);\n            });\n        }, {\n            key:  true && \"getLeftLeafHeaders\",\n            debug: ()=>{\n                var _table$options$debugA14;\n                return (_table$options$debugA14 = table.options.debugAll) != null ? _table$options$debugA14 : table.options.debugHeaders;\n            }\n        });\n        table.getRightLeafHeaders = memo(()=>[\n                table.getRightFlatHeaders()\n            ], (flatHeaders)=>{\n            return flatHeaders.filter((header)=>{\n                var _header$subHeaders3;\n                return !((_header$subHeaders3 = header.subHeaders) != null && _header$subHeaders3.length);\n            });\n        }, {\n            key:  true && \"getRightLeafHeaders\",\n            debug: ()=>{\n                var _table$options$debugA15;\n                return (_table$options$debugA15 = table.options.debugAll) != null ? _table$options$debugA15 : table.options.debugHeaders;\n            }\n        });\n        table.getLeafHeaders = memo(()=>[\n                table.getLeftHeaderGroups(),\n                table.getCenterHeaderGroups(),\n                table.getRightHeaderGroups()\n            ], (left, center, right)=>{\n            var _left$0$headers, _left$, _center$0$headers, _center$, _right$0$headers, _right$;\n            return [\n                ...(_left$0$headers = (_left$ = left[0]) == null ? void 0 : _left$.headers) != null ? _left$0$headers : [],\n                ...(_center$0$headers = (_center$ = center[0]) == null ? void 0 : _center$.headers) != null ? _center$0$headers : [],\n                ...(_right$0$headers = (_right$ = right[0]) == null ? void 0 : _right$.headers) != null ? _right$0$headers : []\n            ].map((header)=>{\n                return header.getLeafHeaders();\n            }).flat();\n        }, {\n            key:  true && \"getLeafHeaders\",\n            debug: ()=>{\n                var _table$options$debugA16;\n                return (_table$options$debugA16 = table.options.debugAll) != null ? _table$options$debugA16 : table.options.debugHeaders;\n            }\n        });\n    }\n};\nfunction buildHeaderGroups(allColumns, columnsToGroup, table, headerFamily) {\n    var _headerGroups$0$heade, _headerGroups$;\n    // Find the max depth of the columns:\n    // build the leaf column row\n    // build each buffer row going up\n    //    placeholder for non-existent level\n    //    real column for existing level\n    let maxDepth = 0;\n    const findMaxDepth = function(columns, depth) {\n        if (depth === void 0) {\n            depth = 1;\n        }\n        maxDepth = Math.max(maxDepth, depth);\n        columns.filter((column)=>column.getIsVisible()).forEach((column)=>{\n            var _column$columns;\n            if ((_column$columns = column.columns) != null && _column$columns.length) {\n                findMaxDepth(column.columns, depth + 1);\n            }\n        }, 0);\n    };\n    findMaxDepth(allColumns);\n    let headerGroups = [];\n    const createHeaderGroup = (headersToGroup, depth)=>{\n        // The header group we are creating\n        const headerGroup = {\n            depth,\n            id: [\n                headerFamily,\n                `${depth}`\n            ].filter(Boolean).join(\"_\"),\n            headers: []\n        };\n        // The parent columns we're going to scan next\n        const pendingParentHeaders = [];\n        // Scan each column for parents\n        headersToGroup.forEach((headerToGroup)=>{\n            // What is the latest (last) parent column?\n            const latestPendingParentHeader = [\n                ...pendingParentHeaders\n            ].reverse()[0];\n            const isLeafHeader = headerToGroup.column.depth === headerGroup.depth;\n            let column;\n            let isPlaceholder = false;\n            if (isLeafHeader && headerToGroup.column.parent) {\n                // The parent header is new\n                column = headerToGroup.column.parent;\n            } else {\n                // The parent header is repeated\n                column = headerToGroup.column;\n                isPlaceholder = true;\n            }\n            if (latestPendingParentHeader && (latestPendingParentHeader == null ? void 0 : latestPendingParentHeader.column) === column) {\n                // This column is repeated. Add it as a sub header to the next batch\n                latestPendingParentHeader.subHeaders.push(headerToGroup);\n            } else {\n                // This is a new header. Let's create it\n                const header = createHeader(table, column, {\n                    id: [\n                        headerFamily,\n                        depth,\n                        column.id,\n                        headerToGroup == null ? void 0 : headerToGroup.id\n                    ].filter(Boolean).join(\"_\"),\n                    isPlaceholder,\n                    placeholderId: isPlaceholder ? `${pendingParentHeaders.filter((d)=>d.column === column).length}` : undefined,\n                    depth,\n                    index: pendingParentHeaders.length\n                });\n                // Add the headerToGroup as a subHeader of the new header\n                header.subHeaders.push(headerToGroup);\n                // Add the new header to the pendingParentHeaders to get grouped\n                // in the next batch\n                pendingParentHeaders.push(header);\n            }\n            headerGroup.headers.push(headerToGroup);\n            headerToGroup.headerGroup = headerGroup;\n        });\n        headerGroups.push(headerGroup);\n        if (depth > 0) {\n            createHeaderGroup(pendingParentHeaders, depth - 1);\n        }\n    };\n    const bottomHeaders = columnsToGroup.map((column, index)=>createHeader(table, column, {\n            depth: maxDepth,\n            index\n        }));\n    createHeaderGroup(bottomHeaders, maxDepth - 1);\n    headerGroups.reverse();\n    // headerGroups = headerGroups.filter(headerGroup => {\n    //   return !headerGroup.headers.every(header => header.isPlaceholder)\n    // })\n    const recurseHeadersForSpans = (headers)=>{\n        const filteredHeaders = headers.filter((header)=>header.column.getIsVisible());\n        return filteredHeaders.map((header)=>{\n            let colSpan = 0;\n            let rowSpan = 0;\n            let childRowSpans = [\n                0\n            ];\n            if (header.subHeaders && header.subHeaders.length) {\n                childRowSpans = [];\n                recurseHeadersForSpans(header.subHeaders).forEach((_ref)=>{\n                    let { colSpan: childColSpan, rowSpan: childRowSpan } = _ref;\n                    colSpan += childColSpan;\n                    childRowSpans.push(childRowSpan);\n                });\n            } else {\n                colSpan = 1;\n            }\n            const minChildRowSpan = Math.min(...childRowSpans);\n            rowSpan = rowSpan + minChildRowSpan;\n            header.colSpan = colSpan;\n            header.rowSpan = rowSpan;\n            return {\n                colSpan,\n                rowSpan\n            };\n        });\n    };\n    recurseHeadersForSpans((_headerGroups$0$heade = (_headerGroups$ = headerGroups[0]) == null ? void 0 : _headerGroups$.headers) != null ? _headerGroups$0$heade : []);\n    return headerGroups;\n}\n//\n//\nconst defaultColumnSizing = {\n    size: 150,\n    minSize: 20,\n    maxSize: Number.MAX_SAFE_INTEGER\n};\nconst getDefaultColumnSizingInfoState = ()=>({\n        startOffset: null,\n        startSize: null,\n        deltaOffset: null,\n        deltaPercentage: null,\n        isResizingColumn: false,\n        columnSizingStart: []\n    });\nconst ColumnSizing = {\n    getDefaultColumnDef: ()=>{\n        return defaultColumnSizing;\n    },\n    getInitialState: (state)=>{\n        return {\n            columnSizing: {},\n            columnSizingInfo: getDefaultColumnSizingInfoState(),\n            ...state\n        };\n    },\n    getDefaultOptions: (table)=>{\n        return {\n            columnResizeMode: \"onEnd\",\n            columnResizeDirection: \"ltr\",\n            onColumnSizingChange: makeStateUpdater(\"columnSizing\", table),\n            onColumnSizingInfoChange: makeStateUpdater(\"columnSizingInfo\", table)\n        };\n    },\n    createColumn: (column, table)=>{\n        column.getSize = ()=>{\n            var _column$columnDef$min, _ref, _column$columnDef$max;\n            const columnSize = table.getState().columnSizing[column.id];\n            return Math.min(Math.max((_column$columnDef$min = column.columnDef.minSize) != null ? _column$columnDef$min : defaultColumnSizing.minSize, (_ref = columnSize != null ? columnSize : column.columnDef.size) != null ? _ref : defaultColumnSizing.size), (_column$columnDef$max = column.columnDef.maxSize) != null ? _column$columnDef$max : defaultColumnSizing.maxSize);\n        };\n        column.getStart = (position)=>{\n            const columns = !position ? table.getVisibleLeafColumns() : position === \"left\" ? table.getLeftVisibleLeafColumns() : table.getRightVisibleLeafColumns();\n            const index = columns.findIndex((d)=>d.id === column.id);\n            if (index > 0) {\n                const prevSiblingColumn = columns[index - 1];\n                return prevSiblingColumn.getStart(position) + prevSiblingColumn.getSize();\n            }\n            return 0;\n        };\n        column.resetSize = ()=>{\n            table.setColumnSizing((_ref2)=>{\n                let { [column.id]: _, ...rest } = _ref2;\n                return rest;\n            });\n        };\n        column.getCanResize = ()=>{\n            var _column$columnDef$ena, _table$options$enable;\n            return ((_column$columnDef$ena = column.columnDef.enableResizing) != null ? _column$columnDef$ena : true) && ((_table$options$enable = table.options.enableColumnResizing) != null ? _table$options$enable : true);\n        };\n        column.getIsResizing = ()=>{\n            return table.getState().columnSizingInfo.isResizingColumn === column.id;\n        };\n    },\n    createHeader: (header, table)=>{\n        header.getSize = ()=>{\n            let sum = 0;\n            const recurse = (header)=>{\n                if (header.subHeaders.length) {\n                    header.subHeaders.forEach(recurse);\n                } else {\n                    var _header$column$getSiz;\n                    sum += (_header$column$getSiz = header.column.getSize()) != null ? _header$column$getSiz : 0;\n                }\n            };\n            recurse(header);\n            return sum;\n        };\n        header.getStart = ()=>{\n            if (header.index > 0) {\n                const prevSiblingHeader = header.headerGroup.headers[header.index - 1];\n                return prevSiblingHeader.getStart() + prevSiblingHeader.getSize();\n            }\n            return 0;\n        };\n        header.getResizeHandler = ()=>{\n            const column = table.getColumn(header.column.id);\n            const canResize = column == null ? void 0 : column.getCanResize();\n            return (e)=>{\n                if (!column || !canResize) {\n                    return;\n                }\n                e.persist == null || e.persist();\n                if (isTouchStartEvent(e)) {\n                    // lets not respond to multiple touches (e.g. 2 or 3 fingers)\n                    if (e.touches && e.touches.length > 1) {\n                        return;\n                    }\n                }\n                const startSize = header.getSize();\n                const columnSizingStart = header ? header.getLeafHeaders().map((d)=>[\n                        d.column.id,\n                        d.column.getSize()\n                    ]) : [\n                    [\n                        column.id,\n                        column.getSize()\n                    ]\n                ];\n                const clientX = isTouchStartEvent(e) ? Math.round(e.touches[0].clientX) : e.clientX;\n                const newColumnSizing = {};\n                const updateOffset = (eventType, clientXPos)=>{\n                    if (typeof clientXPos !== \"number\") {\n                        return;\n                    }\n                    table.setColumnSizingInfo((old)=>{\n                        var _old$startOffset, _old$startSize;\n                        const deltaDirection = table.options.columnResizeDirection === \"rtl\" ? -1 : 1;\n                        const deltaOffset = (clientXPos - ((_old$startOffset = old == null ? void 0 : old.startOffset) != null ? _old$startOffset : 0)) * deltaDirection;\n                        const deltaPercentage = Math.max(deltaOffset / ((_old$startSize = old == null ? void 0 : old.startSize) != null ? _old$startSize : 0), -0.999999);\n                        old.columnSizingStart.forEach((_ref3)=>{\n                            let [columnId, headerSize] = _ref3;\n                            newColumnSizing[columnId] = Math.round(Math.max(headerSize + headerSize * deltaPercentage, 0) * 100) / 100;\n                        });\n                        return {\n                            ...old,\n                            deltaOffset,\n                            deltaPercentage\n                        };\n                    });\n                    if (table.options.columnResizeMode === \"onChange\" || eventType === \"end\") {\n                        table.setColumnSizing((old)=>({\n                                ...old,\n                                ...newColumnSizing\n                            }));\n                    }\n                };\n                const onMove = (clientXPos)=>updateOffset(\"move\", clientXPos);\n                const onEnd = (clientXPos)=>{\n                    updateOffset(\"end\", clientXPos);\n                    table.setColumnSizingInfo((old)=>({\n                            ...old,\n                            isResizingColumn: false,\n                            startOffset: null,\n                            startSize: null,\n                            deltaOffset: null,\n                            deltaPercentage: null,\n                            columnSizingStart: []\n                        }));\n                };\n                const mouseEvents = {\n                    moveHandler: (e)=>onMove(e.clientX),\n                    upHandler: (e)=>{\n                        document.removeEventListener(\"mousemove\", mouseEvents.moveHandler);\n                        document.removeEventListener(\"mouseup\", mouseEvents.upHandler);\n                        onEnd(e.clientX);\n                    }\n                };\n                const touchEvents = {\n                    moveHandler: (e)=>{\n                        if (e.cancelable) {\n                            e.preventDefault();\n                            e.stopPropagation();\n                        }\n                        onMove(e.touches[0].clientX);\n                        return false;\n                    },\n                    upHandler: (e)=>{\n                        var _e$touches$;\n                        document.removeEventListener(\"touchmove\", touchEvents.moveHandler);\n                        document.removeEventListener(\"touchend\", touchEvents.upHandler);\n                        if (e.cancelable) {\n                            e.preventDefault();\n                            e.stopPropagation();\n                        }\n                        onEnd((_e$touches$ = e.touches[0]) == null ? void 0 : _e$touches$.clientX);\n                    }\n                };\n                const passiveIfSupported = passiveEventSupported() ? {\n                    passive: false\n                } : false;\n                if (isTouchStartEvent(e)) {\n                    document.addEventListener(\"touchmove\", touchEvents.moveHandler, passiveIfSupported);\n                    document.addEventListener(\"touchend\", touchEvents.upHandler, passiveIfSupported);\n                } else {\n                    document.addEventListener(\"mousemove\", mouseEvents.moveHandler, passiveIfSupported);\n                    document.addEventListener(\"mouseup\", mouseEvents.upHandler, passiveIfSupported);\n                }\n                table.setColumnSizingInfo((old)=>({\n                        ...old,\n                        startOffset: clientX,\n                        startSize,\n                        deltaOffset: 0,\n                        deltaPercentage: 0,\n                        columnSizingStart,\n                        isResizingColumn: column.id\n                    }));\n            };\n        };\n    },\n    createTable: (table)=>{\n        table.setColumnSizing = (updater)=>table.options.onColumnSizingChange == null ? void 0 : table.options.onColumnSizingChange(updater);\n        table.setColumnSizingInfo = (updater)=>table.options.onColumnSizingInfoChange == null ? void 0 : table.options.onColumnSizingInfoChange(updater);\n        table.resetColumnSizing = (defaultState)=>{\n            var _table$initialState$c;\n            table.setColumnSizing(defaultState ? {} : (_table$initialState$c = table.initialState.columnSizing) != null ? _table$initialState$c : {});\n        };\n        table.resetHeaderSizeInfo = (defaultState)=>{\n            var _table$initialState$c2;\n            table.setColumnSizingInfo(defaultState ? getDefaultColumnSizingInfoState() : (_table$initialState$c2 = table.initialState.columnSizingInfo) != null ? _table$initialState$c2 : getDefaultColumnSizingInfoState());\n        };\n        table.getTotalSize = ()=>{\n            var _table$getHeaderGroup, _table$getHeaderGroup2;\n            return (_table$getHeaderGroup = (_table$getHeaderGroup2 = table.getHeaderGroups()[0]) == null ? void 0 : _table$getHeaderGroup2.headers.reduce((sum, header)=>{\n                return sum + header.getSize();\n            }, 0)) != null ? _table$getHeaderGroup : 0;\n        };\n        table.getLeftTotalSize = ()=>{\n            var _table$getLeftHeaderG, _table$getLeftHeaderG2;\n            return (_table$getLeftHeaderG = (_table$getLeftHeaderG2 = table.getLeftHeaderGroups()[0]) == null ? void 0 : _table$getLeftHeaderG2.headers.reduce((sum, header)=>{\n                return sum + header.getSize();\n            }, 0)) != null ? _table$getLeftHeaderG : 0;\n        };\n        table.getCenterTotalSize = ()=>{\n            var _table$getCenterHeade, _table$getCenterHeade2;\n            return (_table$getCenterHeade = (_table$getCenterHeade2 = table.getCenterHeaderGroups()[0]) == null ? void 0 : _table$getCenterHeade2.headers.reduce((sum, header)=>{\n                return sum + header.getSize();\n            }, 0)) != null ? _table$getCenterHeade : 0;\n        };\n        table.getRightTotalSize = ()=>{\n            var _table$getRightHeader, _table$getRightHeader2;\n            return (_table$getRightHeader = (_table$getRightHeader2 = table.getRightHeaderGroups()[0]) == null ? void 0 : _table$getRightHeader2.headers.reduce((sum, header)=>{\n                return sum + header.getSize();\n            }, 0)) != null ? _table$getRightHeader : 0;\n        };\n    }\n};\nlet passiveSupported = null;\nfunction passiveEventSupported() {\n    if (typeof passiveSupported === \"boolean\") return passiveSupported;\n    let supported = false;\n    try {\n        const options = {\n            get passive () {\n                supported = true;\n                return false;\n            }\n        };\n        const noop = ()=>{};\n        window.addEventListener(\"test\", noop, options);\n        window.removeEventListener(\"test\", noop);\n    } catch (err) {\n        supported = false;\n    }\n    passiveSupported = supported;\n    return passiveSupported;\n}\nfunction isTouchStartEvent(e) {\n    return e.type === \"touchstart\";\n}\n//\nconst Expanding = {\n    getInitialState: (state)=>{\n        return {\n            expanded: {},\n            ...state\n        };\n    },\n    getDefaultOptions: (table)=>{\n        return {\n            onExpandedChange: makeStateUpdater(\"expanded\", table),\n            paginateExpandedRows: true\n        };\n    },\n    createTable: (table)=>{\n        let registered = false;\n        let queued = false;\n        table._autoResetExpanded = ()=>{\n            var _ref, _table$options$autoRe;\n            if (!registered) {\n                table._queue(()=>{\n                    registered = true;\n                });\n                return;\n            }\n            if ((_ref = (_table$options$autoRe = table.options.autoResetAll) != null ? _table$options$autoRe : table.options.autoResetExpanded) != null ? _ref : !table.options.manualExpanding) {\n                if (queued) return;\n                queued = true;\n                table._queue(()=>{\n                    table.resetExpanded();\n                    queued = false;\n                });\n            }\n        };\n        table.setExpanded = (updater)=>table.options.onExpandedChange == null ? void 0 : table.options.onExpandedChange(updater);\n        table.toggleAllRowsExpanded = (expanded)=>{\n            if (expanded != null ? expanded : !table.getIsAllRowsExpanded()) {\n                table.setExpanded(true);\n            } else {\n                table.setExpanded({});\n            }\n        };\n        table.resetExpanded = (defaultState)=>{\n            var _table$initialState$e, _table$initialState;\n            table.setExpanded(defaultState ? {} : (_table$initialState$e = (_table$initialState = table.initialState) == null ? void 0 : _table$initialState.expanded) != null ? _table$initialState$e : {});\n        };\n        table.getCanSomeRowsExpand = ()=>{\n            return table.getPrePaginationRowModel().flatRows.some((row)=>row.getCanExpand());\n        };\n        table.getToggleAllRowsExpandedHandler = ()=>{\n            return (e)=>{\n                e.persist == null || e.persist();\n                table.toggleAllRowsExpanded();\n            };\n        };\n        table.getIsSomeRowsExpanded = ()=>{\n            const expanded = table.getState().expanded;\n            return expanded === true || Object.values(expanded).some(Boolean);\n        };\n        table.getIsAllRowsExpanded = ()=>{\n            const expanded = table.getState().expanded;\n            // If expanded is true, save some cycles and return true\n            if (typeof expanded === \"boolean\") {\n                return expanded === true;\n            }\n            if (!Object.keys(expanded).length) {\n                return false;\n            }\n            // If any row is not expanded, return false\n            if (table.getRowModel().flatRows.some((row)=>!row.getIsExpanded())) {\n                return false;\n            }\n            // They must all be expanded :shrug:\n            return true;\n        };\n        table.getExpandedDepth = ()=>{\n            let maxDepth = 0;\n            const rowIds = table.getState().expanded === true ? Object.keys(table.getRowModel().rowsById) : Object.keys(table.getState().expanded);\n            rowIds.forEach((id)=>{\n                const splitId = id.split(\".\");\n                maxDepth = Math.max(maxDepth, splitId.length);\n            });\n            return maxDepth;\n        };\n        table.getPreExpandedRowModel = ()=>table.getSortedRowModel();\n        table.getExpandedRowModel = ()=>{\n            if (!table._getExpandedRowModel && table.options.getExpandedRowModel) {\n                table._getExpandedRowModel = table.options.getExpandedRowModel(table);\n            }\n            if (table.options.manualExpanding || !table._getExpandedRowModel) {\n                return table.getPreExpandedRowModel();\n            }\n            return table._getExpandedRowModel();\n        };\n    },\n    createRow: (row, table)=>{\n        row.toggleExpanded = (expanded)=>{\n            table.setExpanded((old)=>{\n                var _expanded;\n                const exists = old === true ? true : !!(old != null && old[row.id]);\n                let oldExpanded = {};\n                if (old === true) {\n                    Object.keys(table.getRowModel().rowsById).forEach((rowId)=>{\n                        oldExpanded[rowId] = true;\n                    });\n                } else {\n                    oldExpanded = old;\n                }\n                expanded = (_expanded = expanded) != null ? _expanded : !exists;\n                if (!exists && expanded) {\n                    return {\n                        ...oldExpanded,\n                        [row.id]: true\n                    };\n                }\n                if (exists && !expanded) {\n                    const { [row.id]: _, ...rest } = oldExpanded;\n                    return rest;\n                }\n                return old;\n            });\n        };\n        row.getIsExpanded = ()=>{\n            var _table$options$getIsR;\n            const expanded = table.getState().expanded;\n            return !!((_table$options$getIsR = table.options.getIsRowExpanded == null ? void 0 : table.options.getIsRowExpanded(row)) != null ? _table$options$getIsR : expanded === true || (expanded == null ? void 0 : expanded[row.id]));\n        };\n        row.getCanExpand = ()=>{\n            var _table$options$getRow, _table$options$enable, _row$subRows;\n            return (_table$options$getRow = table.options.getRowCanExpand == null ? void 0 : table.options.getRowCanExpand(row)) != null ? _table$options$getRow : ((_table$options$enable = table.options.enableExpanding) != null ? _table$options$enable : true) && !!((_row$subRows = row.subRows) != null && _row$subRows.length);\n        };\n        row.getIsAllParentsExpanded = ()=>{\n            let isFullyExpanded = true;\n            let currentRow = row;\n            while(isFullyExpanded && currentRow.parentId){\n                currentRow = table.getRow(currentRow.parentId, true);\n                isFullyExpanded = currentRow.getIsExpanded();\n            }\n            return isFullyExpanded;\n        };\n        row.getToggleExpandedHandler = ()=>{\n            const canExpand = row.getCanExpand();\n            return ()=>{\n                if (!canExpand) return;\n                row.toggleExpanded();\n            };\n        };\n    }\n};\nconst includesString = (row, columnId, filterValue)=>{\n    var _row$getValue;\n    const search = filterValue.toLowerCase();\n    return Boolean((_row$getValue = row.getValue(columnId)) == null || (_row$getValue = _row$getValue.toString()) == null || (_row$getValue = _row$getValue.toLowerCase()) == null ? void 0 : _row$getValue.includes(search));\n};\nincludesString.autoRemove = (val)=>testFalsey(val);\nconst includesStringSensitive = (row, columnId, filterValue)=>{\n    var _row$getValue2;\n    return Boolean((_row$getValue2 = row.getValue(columnId)) == null || (_row$getValue2 = _row$getValue2.toString()) == null ? void 0 : _row$getValue2.includes(filterValue));\n};\nincludesStringSensitive.autoRemove = (val)=>testFalsey(val);\nconst equalsString = (row, columnId, filterValue)=>{\n    var _row$getValue3;\n    return ((_row$getValue3 = row.getValue(columnId)) == null || (_row$getValue3 = _row$getValue3.toString()) == null ? void 0 : _row$getValue3.toLowerCase()) === (filterValue == null ? void 0 : filterValue.toLowerCase());\n};\nequalsString.autoRemove = (val)=>testFalsey(val);\nconst arrIncludes = (row, columnId, filterValue)=>{\n    var _row$getValue4;\n    return (_row$getValue4 = row.getValue(columnId)) == null ? void 0 : _row$getValue4.includes(filterValue);\n};\narrIncludes.autoRemove = (val)=>testFalsey(val) || !(val != null && val.length);\nconst arrIncludesAll = (row, columnId, filterValue)=>{\n    return !filterValue.some((val)=>{\n        var _row$getValue5;\n        return !((_row$getValue5 = row.getValue(columnId)) != null && _row$getValue5.includes(val));\n    });\n};\narrIncludesAll.autoRemove = (val)=>testFalsey(val) || !(val != null && val.length);\nconst arrIncludesSome = (row, columnId, filterValue)=>{\n    return filterValue.some((val)=>{\n        var _row$getValue6;\n        return (_row$getValue6 = row.getValue(columnId)) == null ? void 0 : _row$getValue6.includes(val);\n    });\n};\narrIncludesSome.autoRemove = (val)=>testFalsey(val) || !(val != null && val.length);\nconst equals = (row, columnId, filterValue)=>{\n    return row.getValue(columnId) === filterValue;\n};\nequals.autoRemove = (val)=>testFalsey(val);\nconst weakEquals = (row, columnId, filterValue)=>{\n    return row.getValue(columnId) == filterValue;\n};\nweakEquals.autoRemove = (val)=>testFalsey(val);\nconst inNumberRange = (row, columnId, filterValue)=>{\n    let [min, max] = filterValue;\n    const rowValue = row.getValue(columnId);\n    return rowValue >= min && rowValue <= max;\n};\ninNumberRange.resolveFilterValue = (val)=>{\n    let [unsafeMin, unsafeMax] = val;\n    let parsedMin = typeof unsafeMin !== \"number\" ? parseFloat(unsafeMin) : unsafeMin;\n    let parsedMax = typeof unsafeMax !== \"number\" ? parseFloat(unsafeMax) : unsafeMax;\n    let min = unsafeMin === null || Number.isNaN(parsedMin) ? -Infinity : parsedMin;\n    let max = unsafeMax === null || Number.isNaN(parsedMax) ? Infinity : parsedMax;\n    if (min > max) {\n        const temp = min;\n        min = max;\n        max = temp;\n    }\n    return [\n        min,\n        max\n    ];\n};\ninNumberRange.autoRemove = (val)=>testFalsey(val) || testFalsey(val[0]) && testFalsey(val[1]);\n// Export\nconst filterFns = {\n    includesString,\n    includesStringSensitive,\n    equalsString,\n    arrIncludes,\n    arrIncludesAll,\n    arrIncludesSome,\n    equals,\n    weakEquals,\n    inNumberRange\n};\n// Utils\nfunction testFalsey(val) {\n    return val === undefined || val === null || val === \"\";\n}\n//\nconst Filters = {\n    getDefaultColumnDef: ()=>{\n        return {\n            filterFn: \"auto\"\n        };\n    },\n    getInitialState: (state)=>{\n        return {\n            columnFilters: [],\n            globalFilter: undefined,\n            // filtersProgress: 1,\n            // facetProgress: {},\n            ...state\n        };\n    },\n    getDefaultOptions: (table)=>{\n        return {\n            onColumnFiltersChange: makeStateUpdater(\"columnFilters\", table),\n            onGlobalFilterChange: makeStateUpdater(\"globalFilter\", table),\n            filterFromLeafRows: false,\n            maxLeafRowFilterDepth: 100,\n            globalFilterFn: \"auto\",\n            getColumnCanGlobalFilter: (column)=>{\n                var _table$getCoreRowMode;\n                const value = (_table$getCoreRowMode = table.getCoreRowModel().flatRows[0]) == null || (_table$getCoreRowMode = _table$getCoreRowMode._getAllCellsByColumnId()[column.id]) == null ? void 0 : _table$getCoreRowMode.getValue();\n                return typeof value === \"string\" || typeof value === \"number\";\n            }\n        };\n    },\n    createColumn: (column, table)=>{\n        column.getAutoFilterFn = ()=>{\n            const firstRow = table.getCoreRowModel().flatRows[0];\n            const value = firstRow == null ? void 0 : firstRow.getValue(column.id);\n            if (typeof value === \"string\") {\n                return filterFns.includesString;\n            }\n            if (typeof value === \"number\") {\n                return filterFns.inNumberRange;\n            }\n            if (typeof value === \"boolean\") {\n                return filterFns.equals;\n            }\n            if (value !== null && typeof value === \"object\") {\n                return filterFns.equals;\n            }\n            if (Array.isArray(value)) {\n                return filterFns.arrIncludes;\n            }\n            return filterFns.weakEquals;\n        };\n        column.getFilterFn = ()=>{\n            var _table$options$filter, _table$options$filter2;\n            return isFunction(column.columnDef.filterFn) ? column.columnDef.filterFn : column.columnDef.filterFn === \"auto\" ? column.getAutoFilterFn() : (_table$options$filter = (_table$options$filter2 = table.options.filterFns) == null ? void 0 : _table$options$filter2[column.columnDef.filterFn]) != null ? _table$options$filter : filterFns[column.columnDef.filterFn];\n        };\n        column.getCanFilter = ()=>{\n            var _column$columnDef$ena, _table$options$enable, _table$options$enable2;\n            return ((_column$columnDef$ena = column.columnDef.enableColumnFilter) != null ? _column$columnDef$ena : true) && ((_table$options$enable = table.options.enableColumnFilters) != null ? _table$options$enable : true) && ((_table$options$enable2 = table.options.enableFilters) != null ? _table$options$enable2 : true) && !!column.accessorFn;\n        };\n        column.getCanGlobalFilter = ()=>{\n            var _column$columnDef$ena2, _table$options$enable3, _table$options$enable4, _table$options$getCol;\n            return ((_column$columnDef$ena2 = column.columnDef.enableGlobalFilter) != null ? _column$columnDef$ena2 : true) && ((_table$options$enable3 = table.options.enableGlobalFilter) != null ? _table$options$enable3 : true) && ((_table$options$enable4 = table.options.enableFilters) != null ? _table$options$enable4 : true) && ((_table$options$getCol = table.options.getColumnCanGlobalFilter == null ? void 0 : table.options.getColumnCanGlobalFilter(column)) != null ? _table$options$getCol : true) && !!column.accessorFn;\n        };\n        column.getIsFiltered = ()=>column.getFilterIndex() > -1;\n        column.getFilterValue = ()=>{\n            var _table$getState$colum;\n            return (_table$getState$colum = table.getState().columnFilters) == null || (_table$getState$colum = _table$getState$colum.find((d)=>d.id === column.id)) == null ? void 0 : _table$getState$colum.value;\n        };\n        column.getFilterIndex = ()=>{\n            var _table$getState$colum2, _table$getState$colum3;\n            return (_table$getState$colum2 = (_table$getState$colum3 = table.getState().columnFilters) == null ? void 0 : _table$getState$colum3.findIndex((d)=>d.id === column.id)) != null ? _table$getState$colum2 : -1;\n        };\n        column.setFilterValue = (value)=>{\n            table.setColumnFilters((old)=>{\n                const filterFn = column.getFilterFn();\n                const previousfilter = old == null ? void 0 : old.find((d)=>d.id === column.id);\n                const newFilter = functionalUpdate(value, previousfilter ? previousfilter.value : undefined);\n                //\n                if (shouldAutoRemoveFilter(filterFn, newFilter, column)) {\n                    var _old$filter;\n                    return (_old$filter = old == null ? void 0 : old.filter((d)=>d.id !== column.id)) != null ? _old$filter : [];\n                }\n                const newFilterObj = {\n                    id: column.id,\n                    value: newFilter\n                };\n                if (previousfilter) {\n                    var _old$map;\n                    return (_old$map = old == null ? void 0 : old.map((d)=>{\n                        if (d.id === column.id) {\n                            return newFilterObj;\n                        }\n                        return d;\n                    })) != null ? _old$map : [];\n                }\n                if (old != null && old.length) {\n                    return [\n                        ...old,\n                        newFilterObj\n                    ];\n                }\n                return [\n                    newFilterObj\n                ];\n            });\n        };\n        column._getFacetedRowModel = table.options.getFacetedRowModel && table.options.getFacetedRowModel(table, column.id);\n        column.getFacetedRowModel = ()=>{\n            if (!column._getFacetedRowModel) {\n                return table.getPreFilteredRowModel();\n            }\n            return column._getFacetedRowModel();\n        };\n        column._getFacetedUniqueValues = table.options.getFacetedUniqueValues && table.options.getFacetedUniqueValues(table, column.id);\n        column.getFacetedUniqueValues = ()=>{\n            if (!column._getFacetedUniqueValues) {\n                return new Map();\n            }\n            return column._getFacetedUniqueValues();\n        };\n        column._getFacetedMinMaxValues = table.options.getFacetedMinMaxValues && table.options.getFacetedMinMaxValues(table, column.id);\n        column.getFacetedMinMaxValues = ()=>{\n            if (!column._getFacetedMinMaxValues) {\n                return undefined;\n            }\n            return column._getFacetedMinMaxValues();\n        };\n    // () => [column.getFacetedRowModel()],\n    // facetedRowModel => getRowModelMinMaxValues(facetedRowModel, column.id),\n    },\n    createRow: (row, table)=>{\n        row.columnFilters = {};\n        row.columnFiltersMeta = {};\n    },\n    createTable: (table)=>{\n        table.getGlobalAutoFilterFn = ()=>{\n            return filterFns.includesString;\n        };\n        table.getGlobalFilterFn = ()=>{\n            var _table$options$filter3, _table$options$filter4;\n            const { globalFilterFn: globalFilterFn } = table.options;\n            return isFunction(globalFilterFn) ? globalFilterFn : globalFilterFn === \"auto\" ? table.getGlobalAutoFilterFn() : (_table$options$filter3 = (_table$options$filter4 = table.options.filterFns) == null ? void 0 : _table$options$filter4[globalFilterFn]) != null ? _table$options$filter3 : filterFns[globalFilterFn];\n        };\n        table.setColumnFilters = (updater)=>{\n            const leafColumns = table.getAllLeafColumns();\n            const updateFn = (old)=>{\n                var _functionalUpdate;\n                return (_functionalUpdate = functionalUpdate(updater, old)) == null ? void 0 : _functionalUpdate.filter((filter)=>{\n                    const column = leafColumns.find((d)=>d.id === filter.id);\n                    if (column) {\n                        const filterFn = column.getFilterFn();\n                        if (shouldAutoRemoveFilter(filterFn, filter.value, column)) {\n                            return false;\n                        }\n                    }\n                    return true;\n                });\n            };\n            table.options.onColumnFiltersChange == null || table.options.onColumnFiltersChange(updateFn);\n        };\n        table.setGlobalFilter = (updater)=>{\n            table.options.onGlobalFilterChange == null || table.options.onGlobalFilterChange(updater);\n        };\n        table.resetGlobalFilter = (defaultState)=>{\n            table.setGlobalFilter(defaultState ? undefined : table.initialState.globalFilter);\n        };\n        table.resetColumnFilters = (defaultState)=>{\n            var _table$initialState$c, _table$initialState;\n            table.setColumnFilters(defaultState ? [] : (_table$initialState$c = (_table$initialState = table.initialState) == null ? void 0 : _table$initialState.columnFilters) != null ? _table$initialState$c : []);\n        };\n        table.getPreFilteredRowModel = ()=>table.getCoreRowModel();\n        table.getFilteredRowModel = ()=>{\n            if (!table._getFilteredRowModel && table.options.getFilteredRowModel) {\n                table._getFilteredRowModel = table.options.getFilteredRowModel(table);\n            }\n            if (table.options.manualFiltering || !table._getFilteredRowModel) {\n                return table.getPreFilteredRowModel();\n            }\n            return table._getFilteredRowModel();\n        };\n        table._getGlobalFacetedRowModel = table.options.getFacetedRowModel && table.options.getFacetedRowModel(table, \"__global__\");\n        table.getGlobalFacetedRowModel = ()=>{\n            if (table.options.manualFiltering || !table._getGlobalFacetedRowModel) {\n                return table.getPreFilteredRowModel();\n            }\n            return table._getGlobalFacetedRowModel();\n        };\n        table._getGlobalFacetedUniqueValues = table.options.getFacetedUniqueValues && table.options.getFacetedUniqueValues(table, \"__global__\");\n        table.getGlobalFacetedUniqueValues = ()=>{\n            if (!table._getGlobalFacetedUniqueValues) {\n                return new Map();\n            }\n            return table._getGlobalFacetedUniqueValues();\n        };\n        table._getGlobalFacetedMinMaxValues = table.options.getFacetedMinMaxValues && table.options.getFacetedMinMaxValues(table, \"__global__\");\n        table.getGlobalFacetedMinMaxValues = ()=>{\n            if (!table._getGlobalFacetedMinMaxValues) {\n                return;\n            }\n            return table._getGlobalFacetedMinMaxValues();\n        };\n    }\n};\nfunction shouldAutoRemoveFilter(filterFn, value, column) {\n    return (filterFn && filterFn.autoRemove ? filterFn.autoRemove(value, column) : false) || typeof value === \"undefined\" || typeof value === \"string\" && !value;\n}\nconst sum = (columnId, _leafRows, childRows)=>{\n    // It's faster to just add the aggregations together instead of\n    // process leaf nodes individually\n    return childRows.reduce((sum, next)=>{\n        const nextValue = next.getValue(columnId);\n        return sum + (typeof nextValue === \"number\" ? nextValue : 0);\n    }, 0);\n};\nconst min = (columnId, _leafRows, childRows)=>{\n    let min;\n    childRows.forEach((row)=>{\n        const value = row.getValue(columnId);\n        if (value != null && (min > value || min === undefined && value >= value)) {\n            min = value;\n        }\n    });\n    return min;\n};\nconst max = (columnId, _leafRows, childRows)=>{\n    let max;\n    childRows.forEach((row)=>{\n        const value = row.getValue(columnId);\n        if (value != null && (max < value || max === undefined && value >= value)) {\n            max = value;\n        }\n    });\n    return max;\n};\nconst extent = (columnId, _leafRows, childRows)=>{\n    let min;\n    let max;\n    childRows.forEach((row)=>{\n        const value = row.getValue(columnId);\n        if (value != null) {\n            if (min === undefined) {\n                if (value >= value) min = max = value;\n            } else {\n                if (min > value) min = value;\n                if (max < value) max = value;\n            }\n        }\n    });\n    return [\n        min,\n        max\n    ];\n};\nconst mean = (columnId, leafRows)=>{\n    let count = 0;\n    let sum = 0;\n    leafRows.forEach((row)=>{\n        let value = row.getValue(columnId);\n        if (value != null && (value = +value) >= value) {\n            ++count, sum += value;\n        }\n    });\n    if (count) return sum / count;\n    return;\n};\nconst median = (columnId, leafRows)=>{\n    if (!leafRows.length) {\n        return;\n    }\n    const values = leafRows.map((row)=>row.getValue(columnId));\n    if (!isNumberArray(values)) {\n        return;\n    }\n    if (values.length === 1) {\n        return values[0];\n    }\n    const mid = Math.floor(values.length / 2);\n    const nums = values.sort((a, b)=>a - b);\n    return values.length % 2 !== 0 ? nums[mid] : (nums[mid - 1] + nums[mid]) / 2;\n};\nconst unique = (columnId, leafRows)=>{\n    return Array.from(new Set(leafRows.map((d)=>d.getValue(columnId))).values());\n};\nconst uniqueCount = (columnId, leafRows)=>{\n    return new Set(leafRows.map((d)=>d.getValue(columnId))).size;\n};\nconst count = (_columnId, leafRows)=>{\n    return leafRows.length;\n};\nconst aggregationFns = {\n    sum,\n    min,\n    max,\n    extent,\n    mean,\n    median,\n    unique,\n    uniqueCount,\n    count\n};\n//\nconst Grouping = {\n    getDefaultColumnDef: ()=>{\n        return {\n            aggregatedCell: (props)=>{\n                var _toString, _props$getValue;\n                return (_toString = (_props$getValue = props.getValue()) == null || _props$getValue.toString == null ? void 0 : _props$getValue.toString()) != null ? _toString : null;\n            },\n            aggregationFn: \"auto\"\n        };\n    },\n    getInitialState: (state)=>{\n        return {\n            grouping: [],\n            ...state\n        };\n    },\n    getDefaultOptions: (table)=>{\n        return {\n            onGroupingChange: makeStateUpdater(\"grouping\", table),\n            groupedColumnMode: \"reorder\"\n        };\n    },\n    createColumn: (column, table)=>{\n        column.toggleGrouping = ()=>{\n            table.setGrouping((old)=>{\n                // Find any existing grouping for this column\n                if (old != null && old.includes(column.id)) {\n                    return old.filter((d)=>d !== column.id);\n                }\n                return [\n                    ...old != null ? old : [],\n                    column.id\n                ];\n            });\n        };\n        column.getCanGroup = ()=>{\n            var _ref, _ref2, _ref3, _column$columnDef$ena;\n            return (_ref = (_ref2 = (_ref3 = (_column$columnDef$ena = column.columnDef.enableGrouping) != null ? _column$columnDef$ena : true) != null ? _ref3 : table.options.enableGrouping) != null ? _ref2 : true) != null ? _ref : !!column.accessorFn;\n        };\n        column.getIsGrouped = ()=>{\n            var _table$getState$group;\n            return (_table$getState$group = table.getState().grouping) == null ? void 0 : _table$getState$group.includes(column.id);\n        };\n        column.getGroupedIndex = ()=>{\n            var _table$getState$group2;\n            return (_table$getState$group2 = table.getState().grouping) == null ? void 0 : _table$getState$group2.indexOf(column.id);\n        };\n        column.getToggleGroupingHandler = ()=>{\n            const canGroup = column.getCanGroup();\n            return ()=>{\n                if (!canGroup) return;\n                column.toggleGrouping();\n            };\n        };\n        column.getAutoAggregationFn = ()=>{\n            const firstRow = table.getCoreRowModel().flatRows[0];\n            const value = firstRow == null ? void 0 : firstRow.getValue(column.id);\n            if (typeof value === \"number\") {\n                return aggregationFns.sum;\n            }\n            if (Object.prototype.toString.call(value) === \"[object Date]\") {\n                return aggregationFns.extent;\n            }\n        };\n        column.getAggregationFn = ()=>{\n            var _table$options$aggreg, _table$options$aggreg2;\n            if (!column) {\n                throw new Error();\n            }\n            return isFunction(column.columnDef.aggregationFn) ? column.columnDef.aggregationFn : column.columnDef.aggregationFn === \"auto\" ? column.getAutoAggregationFn() : (_table$options$aggreg = (_table$options$aggreg2 = table.options.aggregationFns) == null ? void 0 : _table$options$aggreg2[column.columnDef.aggregationFn]) != null ? _table$options$aggreg : aggregationFns[column.columnDef.aggregationFn];\n        };\n    },\n    createTable: (table)=>{\n        table.setGrouping = (updater)=>table.options.onGroupingChange == null ? void 0 : table.options.onGroupingChange(updater);\n        table.resetGrouping = (defaultState)=>{\n            var _table$initialState$g, _table$initialState;\n            table.setGrouping(defaultState ? [] : (_table$initialState$g = (_table$initialState = table.initialState) == null ? void 0 : _table$initialState.grouping) != null ? _table$initialState$g : []);\n        };\n        table.getPreGroupedRowModel = ()=>table.getFilteredRowModel();\n        table.getGroupedRowModel = ()=>{\n            if (!table._getGroupedRowModel && table.options.getGroupedRowModel) {\n                table._getGroupedRowModel = table.options.getGroupedRowModel(table);\n            }\n            if (table.options.manualGrouping || !table._getGroupedRowModel) {\n                return table.getPreGroupedRowModel();\n            }\n            return table._getGroupedRowModel();\n        };\n    },\n    createRow: (row, table)=>{\n        row.getIsGrouped = ()=>!!row.groupingColumnId;\n        row.getGroupingValue = (columnId)=>{\n            if (row._groupingValuesCache.hasOwnProperty(columnId)) {\n                return row._groupingValuesCache[columnId];\n            }\n            const column = table.getColumn(columnId);\n            if (!(column != null && column.columnDef.getGroupingValue)) {\n                return row.getValue(columnId);\n            }\n            row._groupingValuesCache[columnId] = column.columnDef.getGroupingValue(row.original);\n            return row._groupingValuesCache[columnId];\n        };\n        row._groupingValuesCache = {};\n    },\n    createCell: (cell, column, row, table)=>{\n        cell.getIsGrouped = ()=>column.getIsGrouped() && column.id === row.groupingColumnId;\n        cell.getIsPlaceholder = ()=>!cell.getIsGrouped() && column.getIsGrouped();\n        cell.getIsAggregated = ()=>{\n            var _row$subRows;\n            return !cell.getIsGrouped() && !cell.getIsPlaceholder() && !!((_row$subRows = row.subRows) != null && _row$subRows.length);\n        };\n    }\n};\nfunction orderColumns(leafColumns, grouping, groupedColumnMode) {\n    if (!(grouping != null && grouping.length) || !groupedColumnMode) {\n        return leafColumns;\n    }\n    const nonGroupingColumns = leafColumns.filter((col)=>!grouping.includes(col.id));\n    if (groupedColumnMode === \"remove\") {\n        return nonGroupingColumns;\n    }\n    const groupingColumns = grouping.map((g)=>leafColumns.find((col)=>col.id === g)).filter(Boolean);\n    return [\n        ...groupingColumns,\n        ...nonGroupingColumns\n    ];\n}\n//\nconst Ordering = {\n    getInitialState: (state)=>{\n        return {\n            columnOrder: [],\n            ...state\n        };\n    },\n    getDefaultOptions: (table)=>{\n        return {\n            onColumnOrderChange: makeStateUpdater(\"columnOrder\", table)\n        };\n    },\n    createTable: (table)=>{\n        table.setColumnOrder = (updater)=>table.options.onColumnOrderChange == null ? void 0 : table.options.onColumnOrderChange(updater);\n        table.resetColumnOrder = (defaultState)=>{\n            var _table$initialState$c;\n            table.setColumnOrder(defaultState ? [] : (_table$initialState$c = table.initialState.columnOrder) != null ? _table$initialState$c : []);\n        };\n        table._getOrderColumnsFn = memo(()=>[\n                table.getState().columnOrder,\n                table.getState().grouping,\n                table.options.groupedColumnMode\n            ], (columnOrder, grouping, groupedColumnMode)=>(columns)=>{\n                // Sort grouped columns to the start of the column list\n                // before the headers are built\n                let orderedColumns = [];\n                // If there is no order, return the normal columns\n                if (!(columnOrder != null && columnOrder.length)) {\n                    orderedColumns = columns;\n                } else {\n                    const columnOrderCopy = [\n                        ...columnOrder\n                    ];\n                    // If there is an order, make a copy of the columns\n                    const columnsCopy = [\n                        ...columns\n                    ];\n                    // And make a new ordered array of the columns\n                    // Loop over the columns and place them in order into the new array\n                    while(columnsCopy.length && columnOrderCopy.length){\n                        const targetColumnId = columnOrderCopy.shift();\n                        const foundIndex = columnsCopy.findIndex((d)=>d.id === targetColumnId);\n                        if (foundIndex > -1) {\n                            orderedColumns.push(columnsCopy.splice(foundIndex, 1)[0]);\n                        }\n                    }\n                    // If there are any columns left, add them to the end\n                    orderedColumns = [\n                        ...orderedColumns,\n                        ...columnsCopy\n                    ];\n                }\n                return orderColumns(orderedColumns, grouping, groupedColumnMode);\n            }, {\n            key:  true && \"getOrderColumnsFn\"\n        });\n    }\n};\n//\nconst defaultPageIndex = 0;\nconst defaultPageSize = 10;\nconst getDefaultPaginationState = ()=>({\n        pageIndex: defaultPageIndex,\n        pageSize: defaultPageSize\n    });\nconst Pagination = {\n    getInitialState: (state)=>{\n        return {\n            ...state,\n            pagination: {\n                ...getDefaultPaginationState(),\n                ...state == null ? void 0 : state.pagination\n            }\n        };\n    },\n    getDefaultOptions: (table)=>{\n        return {\n            onPaginationChange: makeStateUpdater(\"pagination\", table)\n        };\n    },\n    createTable: (table)=>{\n        let registered = false;\n        let queued = false;\n        table._autoResetPageIndex = ()=>{\n            var _ref, _table$options$autoRe;\n            if (!registered) {\n                table._queue(()=>{\n                    registered = true;\n                });\n                return;\n            }\n            if ((_ref = (_table$options$autoRe = table.options.autoResetAll) != null ? _table$options$autoRe : table.options.autoResetPageIndex) != null ? _ref : !table.options.manualPagination) {\n                if (queued) return;\n                queued = true;\n                table._queue(()=>{\n                    table.resetPageIndex();\n                    queued = false;\n                });\n            }\n        };\n        table.setPagination = (updater)=>{\n            const safeUpdater = (old)=>{\n                let newState = functionalUpdate(updater, old);\n                return newState;\n            };\n            return table.options.onPaginationChange == null ? void 0 : table.options.onPaginationChange(safeUpdater);\n        };\n        table.resetPagination = (defaultState)=>{\n            var _table$initialState$p;\n            table.setPagination(defaultState ? getDefaultPaginationState() : (_table$initialState$p = table.initialState.pagination) != null ? _table$initialState$p : getDefaultPaginationState());\n        };\n        table.setPageIndex = (updater)=>{\n            table.setPagination((old)=>{\n                let pageIndex = functionalUpdate(updater, old.pageIndex);\n                const maxPageIndex = typeof table.options.pageCount === \"undefined\" || table.options.pageCount === -1 ? Number.MAX_SAFE_INTEGER : table.options.pageCount - 1;\n                pageIndex = Math.max(0, Math.min(pageIndex, maxPageIndex));\n                return {\n                    ...old,\n                    pageIndex\n                };\n            });\n        };\n        table.resetPageIndex = (defaultState)=>{\n            var _table$initialState$p2, _table$initialState;\n            table.setPageIndex(defaultState ? defaultPageIndex : (_table$initialState$p2 = (_table$initialState = table.initialState) == null || (_table$initialState = _table$initialState.pagination) == null ? void 0 : _table$initialState.pageIndex) != null ? _table$initialState$p2 : defaultPageIndex);\n        };\n        table.resetPageSize = (defaultState)=>{\n            var _table$initialState$p3, _table$initialState2;\n            table.setPageSize(defaultState ? defaultPageSize : (_table$initialState$p3 = (_table$initialState2 = table.initialState) == null || (_table$initialState2 = _table$initialState2.pagination) == null ? void 0 : _table$initialState2.pageSize) != null ? _table$initialState$p3 : defaultPageSize);\n        };\n        table.setPageSize = (updater)=>{\n            table.setPagination((old)=>{\n                const pageSize = Math.max(1, functionalUpdate(updater, old.pageSize));\n                const topRowIndex = old.pageSize * old.pageIndex;\n                const pageIndex = Math.floor(topRowIndex / pageSize);\n                return {\n                    ...old,\n                    pageIndex,\n                    pageSize\n                };\n            });\n        };\n        table.setPageCount = (updater)=>table.setPagination((old)=>{\n                var _table$options$pageCo;\n                let newPageCount = functionalUpdate(updater, (_table$options$pageCo = table.options.pageCount) != null ? _table$options$pageCo : -1);\n                if (typeof newPageCount === \"number\") {\n                    newPageCount = Math.max(-1, newPageCount);\n                }\n                return {\n                    ...old,\n                    pageCount: newPageCount\n                };\n            });\n        table.getPageOptions = memo(()=>[\n                table.getPageCount()\n            ], (pageCount)=>{\n            let pageOptions = [];\n            if (pageCount && pageCount > 0) {\n                pageOptions = [\n                    ...new Array(pageCount)\n                ].fill(null).map((_, i)=>i);\n            }\n            return pageOptions;\n        }, {\n            key:  true && \"getPageOptions\",\n            debug: ()=>{\n                var _table$options$debugA;\n                return (_table$options$debugA = table.options.debugAll) != null ? _table$options$debugA : table.options.debugTable;\n            }\n        });\n        table.getCanPreviousPage = ()=>table.getState().pagination.pageIndex > 0;\n        table.getCanNextPage = ()=>{\n            const { pageIndex } = table.getState().pagination;\n            const pageCount = table.getPageCount();\n            if (pageCount === -1) {\n                return true;\n            }\n            if (pageCount === 0) {\n                return false;\n            }\n            return pageIndex < pageCount - 1;\n        };\n        table.previousPage = ()=>{\n            return table.setPageIndex((old)=>old - 1);\n        };\n        table.nextPage = ()=>{\n            return table.setPageIndex((old)=>{\n                return old + 1;\n            });\n        };\n        table.getPrePaginationRowModel = ()=>table.getExpandedRowModel();\n        table.getPaginationRowModel = ()=>{\n            if (!table._getPaginationRowModel && table.options.getPaginationRowModel) {\n                table._getPaginationRowModel = table.options.getPaginationRowModel(table);\n            }\n            if (table.options.manualPagination || !table._getPaginationRowModel) {\n                return table.getPrePaginationRowModel();\n            }\n            return table._getPaginationRowModel();\n        };\n        table.getPageCount = ()=>{\n            var _table$options$pageCo2;\n            return (_table$options$pageCo2 = table.options.pageCount) != null ? _table$options$pageCo2 : Math.ceil(table.getPrePaginationRowModel().rows.length / table.getState().pagination.pageSize);\n        };\n    }\n};\n//\nconst getDefaultColumnPinningState = ()=>({\n        left: [],\n        right: []\n    });\nconst getDefaultRowPinningState = ()=>({\n        top: [],\n        bottom: []\n    });\nconst Pinning = {\n    getInitialState: (state)=>{\n        return {\n            columnPinning: getDefaultColumnPinningState(),\n            rowPinning: getDefaultRowPinningState(),\n            ...state\n        };\n    },\n    getDefaultOptions: (table)=>{\n        return {\n            onColumnPinningChange: makeStateUpdater(\"columnPinning\", table),\n            onRowPinningChange: makeStateUpdater(\"rowPinning\", table)\n        };\n    },\n    createColumn: (column, table)=>{\n        column.pin = (position)=>{\n            const columnIds = column.getLeafColumns().map((d)=>d.id).filter(Boolean);\n            table.setColumnPinning((old)=>{\n                var _old$left3, _old$right3;\n                if (position === \"right\") {\n                    var _old$left, _old$right;\n                    return {\n                        left: ((_old$left = old == null ? void 0 : old.left) != null ? _old$left : []).filter((d)=>!(columnIds != null && columnIds.includes(d))),\n                        right: [\n                            ...((_old$right = old == null ? void 0 : old.right) != null ? _old$right : []).filter((d)=>!(columnIds != null && columnIds.includes(d))),\n                            ...columnIds\n                        ]\n                    };\n                }\n                if (position === \"left\") {\n                    var _old$left2, _old$right2;\n                    return {\n                        left: [\n                            ...((_old$left2 = old == null ? void 0 : old.left) != null ? _old$left2 : []).filter((d)=>!(columnIds != null && columnIds.includes(d))),\n                            ...columnIds\n                        ],\n                        right: ((_old$right2 = old == null ? void 0 : old.right) != null ? _old$right2 : []).filter((d)=>!(columnIds != null && columnIds.includes(d)))\n                    };\n                }\n                return {\n                    left: ((_old$left3 = old == null ? void 0 : old.left) != null ? _old$left3 : []).filter((d)=>!(columnIds != null && columnIds.includes(d))),\n                    right: ((_old$right3 = old == null ? void 0 : old.right) != null ? _old$right3 : []).filter((d)=>!(columnIds != null && columnIds.includes(d)))\n                };\n            });\n        };\n        column.getCanPin = ()=>{\n            const leafColumns = column.getLeafColumns();\n            return leafColumns.some((d)=>{\n                var _d$columnDef$enablePi, _ref, _table$options$enable;\n                return ((_d$columnDef$enablePi = d.columnDef.enablePinning) != null ? _d$columnDef$enablePi : true) && ((_ref = (_table$options$enable = table.options.enableColumnPinning) != null ? _table$options$enable : table.options.enablePinning) != null ? _ref : true);\n            });\n        };\n        column.getIsPinned = ()=>{\n            const leafColumnIds = column.getLeafColumns().map((d)=>d.id);\n            const { left, right } = table.getState().columnPinning;\n            const isLeft = leafColumnIds.some((d)=>left == null ? void 0 : left.includes(d));\n            const isRight = leafColumnIds.some((d)=>right == null ? void 0 : right.includes(d));\n            return isLeft ? \"left\" : isRight ? \"right\" : false;\n        };\n        column.getPinnedIndex = ()=>{\n            var _table$getState$colum, _table$getState$colum2;\n            const position = column.getIsPinned();\n            return position ? (_table$getState$colum = (_table$getState$colum2 = table.getState().columnPinning) == null || (_table$getState$colum2 = _table$getState$colum2[position]) == null ? void 0 : _table$getState$colum2.indexOf(column.id)) != null ? _table$getState$colum : -1 : 0;\n        };\n    },\n    createRow: (row, table)=>{\n        row.pin = (position, includeLeafRows, includeParentRows)=>{\n            const leafRowIds = includeLeafRows ? row.getLeafRows().map((_ref2)=>{\n                let { id } = _ref2;\n                return id;\n            }) : [];\n            const parentRowIds = includeParentRows ? row.getParentRows().map((_ref3)=>{\n                let { id } = _ref3;\n                return id;\n            }) : [];\n            const rowIds = new Set([\n                ...parentRowIds,\n                row.id,\n                ...leafRowIds\n            ]);\n            table.setRowPinning((old)=>{\n                var _old$top3, _old$bottom3;\n                if (position === \"bottom\") {\n                    var _old$top, _old$bottom;\n                    return {\n                        top: ((_old$top = old == null ? void 0 : old.top) != null ? _old$top : []).filter((d)=>!(rowIds != null && rowIds.has(d))),\n                        bottom: [\n                            ...((_old$bottom = old == null ? void 0 : old.bottom) != null ? _old$bottom : []).filter((d)=>!(rowIds != null && rowIds.has(d))),\n                            ...Array.from(rowIds)\n                        ]\n                    };\n                }\n                if (position === \"top\") {\n                    var _old$top2, _old$bottom2;\n                    return {\n                        top: [\n                            ...((_old$top2 = old == null ? void 0 : old.top) != null ? _old$top2 : []).filter((d)=>!(rowIds != null && rowIds.has(d))),\n                            ...Array.from(rowIds)\n                        ],\n                        bottom: ((_old$bottom2 = old == null ? void 0 : old.bottom) != null ? _old$bottom2 : []).filter((d)=>!(rowIds != null && rowIds.has(d)))\n                    };\n                }\n                return {\n                    top: ((_old$top3 = old == null ? void 0 : old.top) != null ? _old$top3 : []).filter((d)=>!(rowIds != null && rowIds.has(d))),\n                    bottom: ((_old$bottom3 = old == null ? void 0 : old.bottom) != null ? _old$bottom3 : []).filter((d)=>!(rowIds != null && rowIds.has(d)))\n                };\n            });\n        };\n        row.getCanPin = ()=>{\n            var _ref4;\n            const { enableRowPinning, enablePinning } = table.options;\n            if (typeof enableRowPinning === \"function\") {\n                return enableRowPinning(row);\n            }\n            return (_ref4 = enableRowPinning != null ? enableRowPinning : enablePinning) != null ? _ref4 : true;\n        };\n        row.getIsPinned = ()=>{\n            const rowIds = [\n                row.id\n            ];\n            const { top, bottom } = table.getState().rowPinning;\n            const isTop = rowIds.some((d)=>top == null ? void 0 : top.includes(d));\n            const isBottom = rowIds.some((d)=>bottom == null ? void 0 : bottom.includes(d));\n            return isTop ? \"top\" : isBottom ? \"bottom\" : false;\n        };\n        row.getPinnedIndex = ()=>{\n            var _table$_getPinnedRows, _visiblePinnedRowIds$;\n            const position = row.getIsPinned();\n            if (!position) return -1;\n            const visiblePinnedRowIds = (_table$_getPinnedRows = table._getPinnedRows(position)) == null ? void 0 : _table$_getPinnedRows.map((_ref5)=>{\n                let { id } = _ref5;\n                return id;\n            });\n            return (_visiblePinnedRowIds$ = visiblePinnedRowIds == null ? void 0 : visiblePinnedRowIds.indexOf(row.id)) != null ? _visiblePinnedRowIds$ : -1;\n        };\n        row.getCenterVisibleCells = memo(()=>[\n                row._getAllVisibleCells(),\n                table.getState().columnPinning.left,\n                table.getState().columnPinning.right\n            ], (allCells, left, right)=>{\n            const leftAndRight = [\n                ...left != null ? left : [],\n                ...right != null ? right : []\n            ];\n            return allCells.filter((d)=>!leftAndRight.includes(d.column.id));\n        }, {\n            key:  true && \"row.getCenterVisibleCells\",\n            debug: ()=>{\n                var _table$options$debugA;\n                return (_table$options$debugA = table.options.debugAll) != null ? _table$options$debugA : table.options.debugRows;\n            }\n        });\n        row.getLeftVisibleCells = memo(()=>[\n                row._getAllVisibleCells(),\n                table.getState().columnPinning.left,\n                , \n            ], (allCells, left)=>{\n            const cells = (left != null ? left : []).map((columnId)=>allCells.find((cell)=>cell.column.id === columnId)).filter(Boolean).map((d)=>({\n                    ...d,\n                    position: \"left\"\n                }));\n            return cells;\n        }, {\n            key:  true && \"row.getLeftVisibleCells\",\n            debug: ()=>{\n                var _table$options$debugA2;\n                return (_table$options$debugA2 = table.options.debugAll) != null ? _table$options$debugA2 : table.options.debugRows;\n            }\n        });\n        row.getRightVisibleCells = memo(()=>[\n                row._getAllVisibleCells(),\n                table.getState().columnPinning.right\n            ], (allCells, right)=>{\n            const cells = (right != null ? right : []).map((columnId)=>allCells.find((cell)=>cell.column.id === columnId)).filter(Boolean).map((d)=>({\n                    ...d,\n                    position: \"right\"\n                }));\n            return cells;\n        }, {\n            key:  true && \"row.getRightVisibleCells\",\n            debug: ()=>{\n                var _table$options$debugA3;\n                return (_table$options$debugA3 = table.options.debugAll) != null ? _table$options$debugA3 : table.options.debugRows;\n            }\n        });\n    },\n    createTable: (table)=>{\n        table.setColumnPinning = (updater)=>table.options.onColumnPinningChange == null ? void 0 : table.options.onColumnPinningChange(updater);\n        table.resetColumnPinning = (defaultState)=>{\n            var _table$initialState$c, _table$initialState;\n            return table.setColumnPinning(defaultState ? getDefaultColumnPinningState() : (_table$initialState$c = (_table$initialState = table.initialState) == null ? void 0 : _table$initialState.columnPinning) != null ? _table$initialState$c : getDefaultColumnPinningState());\n        };\n        table.getIsSomeColumnsPinned = (position)=>{\n            var _pinningState$positio;\n            const pinningState = table.getState().columnPinning;\n            if (!position) {\n                var _pinningState$left, _pinningState$right;\n                return Boolean(((_pinningState$left = pinningState.left) == null ? void 0 : _pinningState$left.length) || ((_pinningState$right = pinningState.right) == null ? void 0 : _pinningState$right.length));\n            }\n            return Boolean((_pinningState$positio = pinningState[position]) == null ? void 0 : _pinningState$positio.length);\n        };\n        table.getLeftLeafColumns = memo(()=>[\n                table.getAllLeafColumns(),\n                table.getState().columnPinning.left\n            ], (allColumns, left)=>{\n            return (left != null ? left : []).map((columnId)=>allColumns.find((column)=>column.id === columnId)).filter(Boolean);\n        }, {\n            key:  true && \"getLeftLeafColumns\",\n            debug: ()=>{\n                var _table$options$debugA4;\n                return (_table$options$debugA4 = table.options.debugAll) != null ? _table$options$debugA4 : table.options.debugColumns;\n            }\n        });\n        table.getRightLeafColumns = memo(()=>[\n                table.getAllLeafColumns(),\n                table.getState().columnPinning.right\n            ], (allColumns, right)=>{\n            return (right != null ? right : []).map((columnId)=>allColumns.find((column)=>column.id === columnId)).filter(Boolean);\n        }, {\n            key:  true && \"getRightLeafColumns\",\n            debug: ()=>{\n                var _table$options$debugA5;\n                return (_table$options$debugA5 = table.options.debugAll) != null ? _table$options$debugA5 : table.options.debugColumns;\n            }\n        });\n        table.getCenterLeafColumns = memo(()=>[\n                table.getAllLeafColumns(),\n                table.getState().columnPinning.left,\n                table.getState().columnPinning.right\n            ], (allColumns, left, right)=>{\n            const leftAndRight = [\n                ...left != null ? left : [],\n                ...right != null ? right : []\n            ];\n            return allColumns.filter((d)=>!leftAndRight.includes(d.id));\n        }, {\n            key:  true && \"getCenterLeafColumns\",\n            debug: ()=>{\n                var _table$options$debugA6;\n                return (_table$options$debugA6 = table.options.debugAll) != null ? _table$options$debugA6 : table.options.debugColumns;\n            }\n        });\n        table.setRowPinning = (updater)=>table.options.onRowPinningChange == null ? void 0 : table.options.onRowPinningChange(updater);\n        table.resetRowPinning = (defaultState)=>{\n            var _table$initialState$r, _table$initialState2;\n            return table.setRowPinning(defaultState ? getDefaultRowPinningState() : (_table$initialState$r = (_table$initialState2 = table.initialState) == null ? void 0 : _table$initialState2.rowPinning) != null ? _table$initialState$r : getDefaultRowPinningState());\n        };\n        table.getIsSomeRowsPinned = (position)=>{\n            var _pinningState$positio2;\n            const pinningState = table.getState().rowPinning;\n            if (!position) {\n                var _pinningState$top, _pinningState$bottom;\n                return Boolean(((_pinningState$top = pinningState.top) == null ? void 0 : _pinningState$top.length) || ((_pinningState$bottom = pinningState.bottom) == null ? void 0 : _pinningState$bottom.length));\n            }\n            return Boolean((_pinningState$positio2 = pinningState[position]) == null ? void 0 : _pinningState$positio2.length);\n        };\n        table._getPinnedRows = (position)=>memo(()=>[\n                    table.getRowModel().rows,\n                    table.getState().rowPinning[position]\n                ], (visibleRows, pinnedRowIds)=>{\n                var _table$options$keepPi;\n                const rows = ((_table$options$keepPi = table.options.keepPinnedRows) != null ? _table$options$keepPi : true) ? //get all rows that are pinned even if they would not be otherwise visible\n                //account for expanded parent rows, but not pagination or filtering\n                (pinnedRowIds != null ? pinnedRowIds : []).map((rowId)=>{\n                    const row = table.getRow(rowId, true);\n                    return row.getIsAllParentsExpanded() ? row : null;\n                }) : //else get only visible rows that are pinned\n                (pinnedRowIds != null ? pinnedRowIds : []).map((rowId)=>visibleRows.find((row)=>row.id === rowId));\n                return rows.filter(Boolean).map((d)=>({\n                        ...d,\n                        position\n                    }));\n            }, {\n                key:  true && `row.get${position === \"top\" ? \"Top\" : \"Bottom\"}Rows`,\n                debug: ()=>{\n                    var _table$options$debugA7;\n                    return (_table$options$debugA7 = table.options.debugAll) != null ? _table$options$debugA7 : table.options.debugRows;\n                }\n            })();\n        table.getTopRows = ()=>table._getPinnedRows(\"top\");\n        table.getBottomRows = ()=>table._getPinnedRows(\"bottom\");\n        table.getCenterRows = memo(()=>[\n                table.getRowModel().rows,\n                table.getState().rowPinning.top,\n                table.getState().rowPinning.bottom\n            ], (allRows, top, bottom)=>{\n            const topAndBottom = new Set([\n                ...top != null ? top : [],\n                ...bottom != null ? bottom : []\n            ]);\n            return allRows.filter((d)=>!topAndBottom.has(d.id));\n        }, {\n            key:  true && \"row.getCenterRows\",\n            debug: ()=>{\n                var _table$options$debugA8;\n                return (_table$options$debugA8 = table.options.debugAll) != null ? _table$options$debugA8 : table.options.debugRows;\n            }\n        });\n    }\n};\n//\nconst RowSelection = {\n    getInitialState: (state)=>{\n        return {\n            rowSelection: {},\n            ...state\n        };\n    },\n    getDefaultOptions: (table)=>{\n        return {\n            onRowSelectionChange: makeStateUpdater(\"rowSelection\", table),\n            enableRowSelection: true,\n            enableMultiRowSelection: true,\n            enableSubRowSelection: true\n        };\n    },\n    createTable: (table)=>{\n        table.setRowSelection = (updater)=>table.options.onRowSelectionChange == null ? void 0 : table.options.onRowSelectionChange(updater);\n        table.resetRowSelection = (defaultState)=>{\n            var _table$initialState$r;\n            return table.setRowSelection(defaultState ? {} : (_table$initialState$r = table.initialState.rowSelection) != null ? _table$initialState$r : {});\n        };\n        table.toggleAllRowsSelected = (value)=>{\n            table.setRowSelection((old)=>{\n                value = typeof value !== \"undefined\" ? value : !table.getIsAllRowsSelected();\n                const rowSelection = {\n                    ...old\n                };\n                const preGroupedFlatRows = table.getPreGroupedRowModel().flatRows;\n                // We don't use `mutateRowIsSelected` here for performance reasons.\n                // All of the rows are flat already, so it wouldn't be worth it\n                if (value) {\n                    preGroupedFlatRows.forEach((row)=>{\n                        if (!row.getCanSelect()) {\n                            return;\n                        }\n                        rowSelection[row.id] = true;\n                    });\n                } else {\n                    preGroupedFlatRows.forEach((row)=>{\n                        delete rowSelection[row.id];\n                    });\n                }\n                return rowSelection;\n            });\n        };\n        table.toggleAllPageRowsSelected = (value)=>table.setRowSelection((old)=>{\n                const resolvedValue = typeof value !== \"undefined\" ? value : !table.getIsAllPageRowsSelected();\n                const rowSelection = {\n                    ...old\n                };\n                table.getRowModel().rows.forEach((row)=>{\n                    mutateRowIsSelected(rowSelection, row.id, resolvedValue, true, table);\n                });\n                return rowSelection;\n            });\n        // addRowSelectionRange: rowId => {\n        //   const {\n        //     rows,\n        //     rowsById,\n        //     options: { selectGroupingRows, selectSubRows },\n        //   } = table\n        //   const findSelectedRow = (rows: Row[]) => {\n        //     let found\n        //     rows.find(d => {\n        //       if (d.getIsSelected()) {\n        //         found = d\n        //         return true\n        //       }\n        //       const subFound = findSelectedRow(d.subRows || [])\n        //       if (subFound) {\n        //         found = subFound\n        //         return true\n        //       }\n        //       return false\n        //     })\n        //     return found\n        //   }\n        //   const firstRow = findSelectedRow(rows) || rows[0]\n        //   const lastRow = rowsById[rowId]\n        //   let include = false\n        //   const selectedRowIds = {}\n        //   const addRow = (row: Row) => {\n        //     mutateRowIsSelected(selectedRowIds, row.id, true, {\n        //       rowsById,\n        //       selectGroupingRows: selectGroupingRows!,\n        //       selectSubRows: selectSubRows!,\n        //     })\n        //   }\n        //   table.rows.forEach(row => {\n        //     const isFirstRow = row.id === firstRow.id\n        //     const isLastRow = row.id === lastRow.id\n        //     if (isFirstRow || isLastRow) {\n        //       if (!include) {\n        //         include = true\n        //       } else if (include) {\n        //         addRow(row)\n        //         include = false\n        //       }\n        //     }\n        //     if (include) {\n        //       addRow(row)\n        //     }\n        //   })\n        //   table.setRowSelection(selectedRowIds)\n        // },\n        table.getPreSelectedRowModel = ()=>table.getCoreRowModel();\n        table.getSelectedRowModel = memo(()=>[\n                table.getState().rowSelection,\n                table.getCoreRowModel()\n            ], (rowSelection, rowModel)=>{\n            if (!Object.keys(rowSelection).length) {\n                return {\n                    rows: [],\n                    flatRows: [],\n                    rowsById: {}\n                };\n            }\n            return selectRowsFn(table, rowModel);\n        }, {\n            key:  true && \"getSelectedRowModel\",\n            debug: ()=>{\n                var _table$options$debugA;\n                return (_table$options$debugA = table.options.debugAll) != null ? _table$options$debugA : table.options.debugTable;\n            }\n        });\n        table.getFilteredSelectedRowModel = memo(()=>[\n                table.getState().rowSelection,\n                table.getFilteredRowModel()\n            ], (rowSelection, rowModel)=>{\n            if (!Object.keys(rowSelection).length) {\n                return {\n                    rows: [],\n                    flatRows: [],\n                    rowsById: {}\n                };\n            }\n            return selectRowsFn(table, rowModel);\n        }, {\n            key:  false && 0,\n            debug: ()=>{\n                var _table$options$debugA2;\n                return (_table$options$debugA2 = table.options.debugAll) != null ? _table$options$debugA2 : table.options.debugTable;\n            }\n        });\n        table.getGroupedSelectedRowModel = memo(()=>[\n                table.getState().rowSelection,\n                table.getSortedRowModel()\n            ], (rowSelection, rowModel)=>{\n            if (!Object.keys(rowSelection).length) {\n                return {\n                    rows: [],\n                    flatRows: [],\n                    rowsById: {}\n                };\n            }\n            return selectRowsFn(table, rowModel);\n        }, {\n            key:  false && 0,\n            debug: ()=>{\n                var _table$options$debugA3;\n                return (_table$options$debugA3 = table.options.debugAll) != null ? _table$options$debugA3 : table.options.debugTable;\n            }\n        });\n        ///\n        // getGroupingRowCanSelect: rowId => {\n        //   const row = table.getRow(rowId)\n        //   if (!row) {\n        //     throw new Error()\n        //   }\n        //   if (typeof table.options.enableGroupingRowSelection === 'function') {\n        //     return table.options.enableGroupingRowSelection(row)\n        //   }\n        //   return table.options.enableGroupingRowSelection ?? false\n        // },\n        table.getIsAllRowsSelected = ()=>{\n            const preGroupedFlatRows = table.getFilteredRowModel().flatRows;\n            const { rowSelection } = table.getState();\n            let isAllRowsSelected = Boolean(preGroupedFlatRows.length && Object.keys(rowSelection).length);\n            if (isAllRowsSelected) {\n                if (preGroupedFlatRows.some((row)=>row.getCanSelect() && !rowSelection[row.id])) {\n                    isAllRowsSelected = false;\n                }\n            }\n            return isAllRowsSelected;\n        };\n        table.getIsAllPageRowsSelected = ()=>{\n            const paginationFlatRows = table.getPaginationRowModel().flatRows.filter((row)=>row.getCanSelect());\n            const { rowSelection } = table.getState();\n            let isAllPageRowsSelected = !!paginationFlatRows.length;\n            if (isAllPageRowsSelected && paginationFlatRows.some((row)=>!rowSelection[row.id])) {\n                isAllPageRowsSelected = false;\n            }\n            return isAllPageRowsSelected;\n        };\n        table.getIsSomeRowsSelected = ()=>{\n            var _table$getState$rowSe;\n            const totalSelected = Object.keys((_table$getState$rowSe = table.getState().rowSelection) != null ? _table$getState$rowSe : {}).length;\n            return totalSelected > 0 && totalSelected < table.getFilteredRowModel().flatRows.length;\n        };\n        table.getIsSomePageRowsSelected = ()=>{\n            const paginationFlatRows = table.getPaginationRowModel().flatRows;\n            return table.getIsAllPageRowsSelected() ? false : paginationFlatRows.filter((row)=>row.getCanSelect()).some((d)=>d.getIsSelected() || d.getIsSomeSelected());\n        };\n        table.getToggleAllRowsSelectedHandler = ()=>{\n            return (e)=>{\n                table.toggleAllRowsSelected(e.target.checked);\n            };\n        };\n        table.getToggleAllPageRowsSelectedHandler = ()=>{\n            return (e)=>{\n                table.toggleAllPageRowsSelected(e.target.checked);\n            };\n        };\n    },\n    createRow: (row, table)=>{\n        row.toggleSelected = (value, opts)=>{\n            const isSelected = row.getIsSelected();\n            table.setRowSelection((old)=>{\n                var _opts$selectChildren;\n                value = typeof value !== \"undefined\" ? value : !isSelected;\n                if (row.getCanSelect() && isSelected === value) {\n                    return old;\n                }\n                const selectedRowIds = {\n                    ...old\n                };\n                mutateRowIsSelected(selectedRowIds, row.id, value, (_opts$selectChildren = opts == null ? void 0 : opts.selectChildren) != null ? _opts$selectChildren : true, table);\n                return selectedRowIds;\n            });\n        };\n        row.getIsSelected = ()=>{\n            const { rowSelection } = table.getState();\n            return isRowSelected(row, rowSelection);\n        };\n        row.getIsSomeSelected = ()=>{\n            const { rowSelection } = table.getState();\n            return isSubRowSelected(row, rowSelection) === \"some\";\n        };\n        row.getIsAllSubRowsSelected = ()=>{\n            const { rowSelection } = table.getState();\n            return isSubRowSelected(row, rowSelection) === \"all\";\n        };\n        row.getCanSelect = ()=>{\n            var _table$options$enable;\n            if (typeof table.options.enableRowSelection === \"function\") {\n                return table.options.enableRowSelection(row);\n            }\n            return (_table$options$enable = table.options.enableRowSelection) != null ? _table$options$enable : true;\n        };\n        row.getCanSelectSubRows = ()=>{\n            var _table$options$enable2;\n            if (typeof table.options.enableSubRowSelection === \"function\") {\n                return table.options.enableSubRowSelection(row);\n            }\n            return (_table$options$enable2 = table.options.enableSubRowSelection) != null ? _table$options$enable2 : true;\n        };\n        row.getCanMultiSelect = ()=>{\n            var _table$options$enable3;\n            if (typeof table.options.enableMultiRowSelection === \"function\") {\n                return table.options.enableMultiRowSelection(row);\n            }\n            return (_table$options$enable3 = table.options.enableMultiRowSelection) != null ? _table$options$enable3 : true;\n        };\n        row.getToggleSelectedHandler = ()=>{\n            const canSelect = row.getCanSelect();\n            return (e)=>{\n                var _target;\n                if (!canSelect) return;\n                row.toggleSelected((_target = e.target) == null ? void 0 : _target.checked);\n            };\n        };\n    }\n};\nconst mutateRowIsSelected = (selectedRowIds, id, value, includeChildren, table)=>{\n    var _row$subRows;\n    const row = table.getRow(id, true);\n    // const isGrouped = row.getIsGrouped()\n    // if ( // TODO: enforce grouping row selection rules\n    //   !isGrouped ||\n    //   (isGrouped && table.options.enableGroupingRowSelection)\n    // ) {\n    if (value) {\n        if (!row.getCanMultiSelect()) {\n            Object.keys(selectedRowIds).forEach((key)=>delete selectedRowIds[key]);\n        }\n        if (row.getCanSelect()) {\n            selectedRowIds[id] = true;\n        }\n    } else {\n        delete selectedRowIds[id];\n    }\n    // }\n    if (includeChildren && (_row$subRows = row.subRows) != null && _row$subRows.length && row.getCanSelectSubRows()) {\n        row.subRows.forEach((row)=>mutateRowIsSelected(selectedRowIds, row.id, value, includeChildren, table));\n    }\n};\nfunction selectRowsFn(table, rowModel) {\n    const rowSelection = table.getState().rowSelection;\n    const newSelectedFlatRows = [];\n    const newSelectedRowsById = {};\n    // Filters top level and nested rows\n    const recurseRows = function(rows, depth) {\n        return rows.map((row)=>{\n            var _row$subRows2;\n            const isSelected = isRowSelected(row, rowSelection);\n            if (isSelected) {\n                newSelectedFlatRows.push(row);\n                newSelectedRowsById[row.id] = row;\n            }\n            if ((_row$subRows2 = row.subRows) != null && _row$subRows2.length) {\n                row = {\n                    ...row,\n                    subRows: recurseRows(row.subRows)\n                };\n            }\n            if (isSelected) {\n                return row;\n            }\n        }).filter(Boolean);\n    };\n    return {\n        rows: recurseRows(rowModel.rows),\n        flatRows: newSelectedFlatRows,\n        rowsById: newSelectedRowsById\n    };\n}\nfunction isRowSelected(row, selection) {\n    var _selection$row$id;\n    return (_selection$row$id = selection[row.id]) != null ? _selection$row$id : false;\n}\nfunction isSubRowSelected(row, selection, table) {\n    var _row$subRows3;\n    if (!((_row$subRows3 = row.subRows) != null && _row$subRows3.length)) return false;\n    let allChildrenSelected = true;\n    let someSelected = false;\n    row.subRows.forEach((subRow)=>{\n        // Bail out early if we know both of these\n        if (someSelected && !allChildrenSelected) {\n            return;\n        }\n        if (subRow.getCanSelect()) {\n            if (isRowSelected(subRow, selection)) {\n                someSelected = true;\n            } else {\n                allChildrenSelected = false;\n            }\n        }\n        // Check row selection of nested subrows\n        if (subRow.subRows && subRow.subRows.length) {\n            const subRowChildrenSelected = isSubRowSelected(subRow, selection);\n            if (subRowChildrenSelected === \"all\") {\n                someSelected = true;\n            } else if (subRowChildrenSelected === \"some\") {\n                someSelected = true;\n                allChildrenSelected = false;\n            } else {\n                allChildrenSelected = false;\n            }\n        }\n    });\n    return allChildrenSelected ? \"all\" : someSelected ? \"some\" : false;\n}\nconst reSplitAlphaNumeric = /([0-9]+)/gm;\nconst alphanumeric = (rowA, rowB, columnId)=>{\n    return compareAlphanumeric(toString(rowA.getValue(columnId)).toLowerCase(), toString(rowB.getValue(columnId)).toLowerCase());\n};\nconst alphanumericCaseSensitive = (rowA, rowB, columnId)=>{\n    return compareAlphanumeric(toString(rowA.getValue(columnId)), toString(rowB.getValue(columnId)));\n};\n// The text filter is more basic (less numeric support)\n// but is much faster\nconst text = (rowA, rowB, columnId)=>{\n    return compareBasic(toString(rowA.getValue(columnId)).toLowerCase(), toString(rowB.getValue(columnId)).toLowerCase());\n};\n// The text filter is more basic (less numeric support)\n// but is much faster\nconst textCaseSensitive = (rowA, rowB, columnId)=>{\n    return compareBasic(toString(rowA.getValue(columnId)), toString(rowB.getValue(columnId)));\n};\nconst datetime = (rowA, rowB, columnId)=>{\n    const a = rowA.getValue(columnId);\n    const b = rowB.getValue(columnId);\n    // Can handle nullish values\n    // Use > and < because == (and ===) doesn't work with\n    // Date objects (would require calling getTime()).\n    return a > b ? 1 : a < b ? -1 : 0;\n};\nconst basic = (rowA, rowB, columnId)=>{\n    return compareBasic(rowA.getValue(columnId), rowB.getValue(columnId));\n};\n// Utils\nfunction compareBasic(a, b) {\n    return a === b ? 0 : a > b ? 1 : -1;\n}\nfunction toString(a) {\n    if (typeof a === \"number\") {\n        if (isNaN(a) || a === Infinity || a === -Infinity) {\n            return \"\";\n        }\n        return String(a);\n    }\n    if (typeof a === \"string\") {\n        return a;\n    }\n    return \"\";\n}\n// Mixed sorting is slow, but very inclusive of many edge cases.\n// It handles numbers, mixed alphanumeric combinations, and even\n// null, undefined, and Infinity\nfunction compareAlphanumeric(aStr, bStr) {\n    // Split on number groups, but keep the delimiter\n    // Then remove falsey split values\n    const a = aStr.split(reSplitAlphaNumeric).filter(Boolean);\n    const b = bStr.split(reSplitAlphaNumeric).filter(Boolean);\n    // While\n    while(a.length && b.length){\n        const aa = a.shift();\n        const bb = b.shift();\n        const an = parseInt(aa, 10);\n        const bn = parseInt(bb, 10);\n        const combo = [\n            an,\n            bn\n        ].sort();\n        // Both are string\n        if (isNaN(combo[0])) {\n            if (aa > bb) {\n                return 1;\n            }\n            if (bb > aa) {\n                return -1;\n            }\n            continue;\n        }\n        // One is a string, one is a number\n        if (isNaN(combo[1])) {\n            return isNaN(an) ? -1 : 1;\n        }\n        // Both are numbers\n        if (an > bn) {\n            return 1;\n        }\n        if (bn > an) {\n            return -1;\n        }\n    }\n    return a.length - b.length;\n}\n// Exports\nconst sortingFns = {\n    alphanumeric,\n    alphanumericCaseSensitive,\n    text,\n    textCaseSensitive,\n    datetime,\n    basic\n};\n//\nconst Sorting = {\n    getInitialState: (state)=>{\n        return {\n            sorting: [],\n            ...state\n        };\n    },\n    getDefaultColumnDef: ()=>{\n        return {\n            sortingFn: \"auto\",\n            sortUndefined: 1\n        };\n    },\n    getDefaultOptions: (table)=>{\n        return {\n            onSortingChange: makeStateUpdater(\"sorting\", table),\n            isMultiSortEvent: (e)=>{\n                return e.shiftKey;\n            }\n        };\n    },\n    createColumn: (column, table)=>{\n        column.getAutoSortingFn = ()=>{\n            const firstRows = table.getFilteredRowModel().flatRows.slice(10);\n            let isString = false;\n            for (const row of firstRows){\n                const value = row == null ? void 0 : row.getValue(column.id);\n                if (Object.prototype.toString.call(value) === \"[object Date]\") {\n                    return sortingFns.datetime;\n                }\n                if (typeof value === \"string\") {\n                    isString = true;\n                    if (value.split(reSplitAlphaNumeric).length > 1) {\n                        return sortingFns.alphanumeric;\n                    }\n                }\n            }\n            if (isString) {\n                return sortingFns.text;\n            }\n            return sortingFns.basic;\n        };\n        column.getAutoSortDir = ()=>{\n            const firstRow = table.getFilteredRowModel().flatRows[0];\n            const value = firstRow == null ? void 0 : firstRow.getValue(column.id);\n            if (typeof value === \"string\") {\n                return \"asc\";\n            }\n            return \"desc\";\n        };\n        column.getSortingFn = ()=>{\n            var _table$options$sortin, _table$options$sortin2;\n            if (!column) {\n                throw new Error();\n            }\n            return isFunction(column.columnDef.sortingFn) ? column.columnDef.sortingFn : column.columnDef.sortingFn === \"auto\" ? column.getAutoSortingFn() : (_table$options$sortin = (_table$options$sortin2 = table.options.sortingFns) == null ? void 0 : _table$options$sortin2[column.columnDef.sortingFn]) != null ? _table$options$sortin : sortingFns[column.columnDef.sortingFn];\n        };\n        column.toggleSorting = (desc, multi)=>{\n            // if (column.columns.length) {\n            //   column.columns.forEach((c, i) => {\n            //     if (c.id) {\n            //       table.toggleColumnSorting(c.id, undefined, multi || !!i)\n            //     }\n            //   })\n            //   return\n            // }\n            // this needs to be outside of table.setSorting to be in sync with rerender\n            const nextSortingOrder = column.getNextSortingOrder();\n            const hasManualValue = typeof desc !== \"undefined\" && desc !== null;\n            table.setSorting((old)=>{\n                // Find any existing sorting for this column\n                const existingSorting = old == null ? void 0 : old.find((d)=>d.id === column.id);\n                const existingIndex = old == null ? void 0 : old.findIndex((d)=>d.id === column.id);\n                let newSorting = [];\n                // What should we do with this sort action?\n                let sortAction;\n                let nextDesc = hasManualValue ? desc : nextSortingOrder === \"desc\";\n                // Multi-mode\n                if (old != null && old.length && column.getCanMultiSort() && multi) {\n                    if (existingSorting) {\n                        sortAction = \"toggle\";\n                    } else {\n                        sortAction = \"add\";\n                    }\n                } else {\n                    // Normal mode\n                    if (old != null && old.length && existingIndex !== old.length - 1) {\n                        sortAction = \"replace\";\n                    } else if (existingSorting) {\n                        sortAction = \"toggle\";\n                    } else {\n                        sortAction = \"replace\";\n                    }\n                }\n                // Handle toggle states that will remove the sorting\n                if (sortAction === \"toggle\") {\n                    // If we are \"actually\" toggling (not a manual set value), should we remove the sorting?\n                    if (!hasManualValue) {\n                        // Is our intention to remove?\n                        if (!nextSortingOrder) {\n                            sortAction = \"remove\";\n                        }\n                    }\n                }\n                if (sortAction === \"add\") {\n                    var _table$options$maxMul;\n                    newSorting = [\n                        ...old,\n                        {\n                            id: column.id,\n                            desc: nextDesc\n                        }\n                    ];\n                    // Take latest n columns\n                    newSorting.splice(0, newSorting.length - ((_table$options$maxMul = table.options.maxMultiSortColCount) != null ? _table$options$maxMul : Number.MAX_SAFE_INTEGER));\n                } else if (sortAction === \"toggle\") {\n                    // This flips (or sets) the\n                    newSorting = old.map((d)=>{\n                        if (d.id === column.id) {\n                            return {\n                                ...d,\n                                desc: nextDesc\n                            };\n                        }\n                        return d;\n                    });\n                } else if (sortAction === \"remove\") {\n                    newSorting = old.filter((d)=>d.id !== column.id);\n                } else {\n                    newSorting = [\n                        {\n                            id: column.id,\n                            desc: nextDesc\n                        }\n                    ];\n                }\n                return newSorting;\n            });\n        };\n        column.getFirstSortDir = ()=>{\n            var _ref, _column$columnDef$sor;\n            const sortDescFirst = (_ref = (_column$columnDef$sor = column.columnDef.sortDescFirst) != null ? _column$columnDef$sor : table.options.sortDescFirst) != null ? _ref : column.getAutoSortDir() === \"desc\";\n            return sortDescFirst ? \"desc\" : \"asc\";\n        };\n        column.getNextSortingOrder = (multi)=>{\n            var _table$options$enable, _table$options$enable2;\n            const firstSortDirection = column.getFirstSortDir();\n            const isSorted = column.getIsSorted();\n            if (!isSorted) {\n                return firstSortDirection;\n            }\n            if (isSorted !== firstSortDirection && ((_table$options$enable = table.options.enableSortingRemoval) != null ? _table$options$enable : true) && // If enableSortRemove, enable in general\n            (multi ? (_table$options$enable2 = table.options.enableMultiRemove) != null ? _table$options$enable2 : true : true // If multi, don't allow if enableMultiRemove))\n            )) {\n                return false;\n            }\n            return isSorted === \"desc\" ? \"asc\" : \"desc\";\n        };\n        column.getCanSort = ()=>{\n            var _column$columnDef$ena, _table$options$enable3;\n            return ((_column$columnDef$ena = column.columnDef.enableSorting) != null ? _column$columnDef$ena : true) && ((_table$options$enable3 = table.options.enableSorting) != null ? _table$options$enable3 : true) && !!column.accessorFn;\n        };\n        column.getCanMultiSort = ()=>{\n            var _ref2, _column$columnDef$ena2;\n            return (_ref2 = (_column$columnDef$ena2 = column.columnDef.enableMultiSort) != null ? _column$columnDef$ena2 : table.options.enableMultiSort) != null ? _ref2 : !!column.accessorFn;\n        };\n        column.getIsSorted = ()=>{\n            var _table$getState$sorti;\n            const columnSort = (_table$getState$sorti = table.getState().sorting) == null ? void 0 : _table$getState$sorti.find((d)=>d.id === column.id);\n            return !columnSort ? false : columnSort.desc ? \"desc\" : \"asc\";\n        };\n        column.getSortIndex = ()=>{\n            var _table$getState$sorti2, _table$getState$sorti3;\n            return (_table$getState$sorti2 = (_table$getState$sorti3 = table.getState().sorting) == null ? void 0 : _table$getState$sorti3.findIndex((d)=>d.id === column.id)) != null ? _table$getState$sorti2 : -1;\n        };\n        column.clearSorting = ()=>{\n            //clear sorting for just 1 column\n            table.setSorting((old)=>old != null && old.length ? old.filter((d)=>d.id !== column.id) : []);\n        };\n        column.getToggleSortingHandler = ()=>{\n            const canSort = column.getCanSort();\n            return (e)=>{\n                if (!canSort) return;\n                e.persist == null || e.persist();\n                column.toggleSorting == null || column.toggleSorting(undefined, column.getCanMultiSort() ? table.options.isMultiSortEvent == null ? void 0 : table.options.isMultiSortEvent(e) : false);\n            };\n        };\n    },\n    createTable: (table)=>{\n        table.setSorting = (updater)=>table.options.onSortingChange == null ? void 0 : table.options.onSortingChange(updater);\n        table.resetSorting = (defaultState)=>{\n            var _table$initialState$s, _table$initialState;\n            table.setSorting(defaultState ? [] : (_table$initialState$s = (_table$initialState = table.initialState) == null ? void 0 : _table$initialState.sorting) != null ? _table$initialState$s : []);\n        };\n        table.getPreSortedRowModel = ()=>table.getGroupedRowModel();\n        table.getSortedRowModel = ()=>{\n            if (!table._getSortedRowModel && table.options.getSortedRowModel) {\n                table._getSortedRowModel = table.options.getSortedRowModel(table);\n            }\n            if (table.options.manualSorting || !table._getSortedRowModel) {\n                return table.getPreSortedRowModel();\n            }\n            return table._getSortedRowModel();\n        };\n    }\n};\n//\nconst Visibility = {\n    getInitialState: (state)=>{\n        return {\n            columnVisibility: {},\n            ...state\n        };\n    },\n    getDefaultOptions: (table)=>{\n        return {\n            onColumnVisibilityChange: makeStateUpdater(\"columnVisibility\", table)\n        };\n    },\n    createColumn: (column, table)=>{\n        column.toggleVisibility = (value)=>{\n            if (column.getCanHide()) {\n                table.setColumnVisibility((old)=>({\n                        ...old,\n                        [column.id]: value != null ? value : !column.getIsVisible()\n                    }));\n            }\n        };\n        column.getIsVisible = ()=>{\n            var _table$getState$colum, _table$getState$colum2;\n            return (_table$getState$colum = (_table$getState$colum2 = table.getState().columnVisibility) == null ? void 0 : _table$getState$colum2[column.id]) != null ? _table$getState$colum : true;\n        };\n        column.getCanHide = ()=>{\n            var _column$columnDef$ena, _table$options$enable;\n            return ((_column$columnDef$ena = column.columnDef.enableHiding) != null ? _column$columnDef$ena : true) && ((_table$options$enable = table.options.enableHiding) != null ? _table$options$enable : true);\n        };\n        column.getToggleVisibilityHandler = ()=>{\n            return (e)=>{\n                column.toggleVisibility == null || column.toggleVisibility(e.target.checked);\n            };\n        };\n    },\n    createRow: (row, table)=>{\n        row._getAllVisibleCells = memo(()=>[\n                row.getAllCells(),\n                table.getState().columnVisibility\n            ], (cells)=>{\n            return cells.filter((cell)=>cell.column.getIsVisible());\n        }, {\n            key:  false && 0,\n            debug: ()=>{\n                var _table$options$debugA;\n                return (_table$options$debugA = table.options.debugAll) != null ? _table$options$debugA : table.options.debugRows;\n            }\n        });\n        row.getVisibleCells = memo(()=>[\n                row.getLeftVisibleCells(),\n                row.getCenterVisibleCells(),\n                row.getRightVisibleCells()\n            ], (left, center, right)=>[\n                ...left,\n                ...center,\n                ...right\n            ], {\n            key:  true && \"row.getVisibleCells\",\n            debug: ()=>{\n                var _table$options$debugA2;\n                return (_table$options$debugA2 = table.options.debugAll) != null ? _table$options$debugA2 : table.options.debugRows;\n            }\n        });\n    },\n    createTable: (table)=>{\n        const makeVisibleColumnsMethod = (key, getColumns)=>{\n            return memo(()=>[\n                    getColumns(),\n                    getColumns().filter((d)=>d.getIsVisible()).map((d)=>d.id).join(\"_\")\n                ], (columns)=>{\n                return columns.filter((d)=>d.getIsVisible == null ? void 0 : d.getIsVisible());\n            }, {\n                key,\n                debug: ()=>{\n                    var _table$options$debugA3;\n                    return (_table$options$debugA3 = table.options.debugAll) != null ? _table$options$debugA3 : table.options.debugColumns;\n                }\n            });\n        };\n        table.getVisibleFlatColumns = makeVisibleColumnsMethod(\"getVisibleFlatColumns\", ()=>table.getAllFlatColumns());\n        table.getVisibleLeafColumns = makeVisibleColumnsMethod(\"getVisibleLeafColumns\", ()=>table.getAllLeafColumns());\n        table.getLeftVisibleLeafColumns = makeVisibleColumnsMethod(\"getLeftVisibleLeafColumns\", ()=>table.getLeftLeafColumns());\n        table.getRightVisibleLeafColumns = makeVisibleColumnsMethod(\"getRightVisibleLeafColumns\", ()=>table.getRightLeafColumns());\n        table.getCenterVisibleLeafColumns = makeVisibleColumnsMethod(\"getCenterVisibleLeafColumns\", ()=>table.getCenterLeafColumns());\n        table.setColumnVisibility = (updater)=>table.options.onColumnVisibilityChange == null ? void 0 : table.options.onColumnVisibilityChange(updater);\n        table.resetColumnVisibility = (defaultState)=>{\n            var _table$initialState$c;\n            table.setColumnVisibility(defaultState ? {} : (_table$initialState$c = table.initialState.columnVisibility) != null ? _table$initialState$c : {});\n        };\n        table.toggleAllColumnsVisible = (value)=>{\n            var _value;\n            value = (_value = value) != null ? _value : !table.getIsAllColumnsVisible();\n            table.setColumnVisibility(table.getAllLeafColumns().reduce((obj, column)=>({\n                    ...obj,\n                    [column.id]: !value ? !(column.getCanHide != null && column.getCanHide()) : value\n                }), {}));\n        };\n        table.getIsAllColumnsVisible = ()=>!table.getAllLeafColumns().some((column)=>!(column.getIsVisible != null && column.getIsVisible()));\n        table.getIsSomeColumnsVisible = ()=>table.getAllLeafColumns().some((column)=>column.getIsVisible == null ? void 0 : column.getIsVisible());\n        table.getToggleAllColumnsVisibilityHandler = ()=>{\n            return (e)=>{\n                var _target;\n                table.toggleAllColumnsVisible((_target = e.target) == null ? void 0 : _target.checked);\n            };\n        };\n    }\n};\nconst features = [\n    Headers,\n    Visibility,\n    Ordering,\n    Pinning,\n    Filters,\n    Sorting,\n    Grouping,\n    Expanding,\n    Pagination,\n    RowSelection,\n    ColumnSizing\n];\n//\nfunction createTable(options) {\n    var _options$initialState;\n    if (options.debugAll || options.debugTable) {\n        console.info(\"Creating Table Instance...\");\n    }\n    let table = {\n        _features: features\n    };\n    const defaultOptions = table._features.reduce((obj, feature)=>{\n        return Object.assign(obj, feature.getDefaultOptions == null ? void 0 : feature.getDefaultOptions(table));\n    }, {});\n    const mergeOptions = (options)=>{\n        if (table.options.mergeOptions) {\n            return table.options.mergeOptions(defaultOptions, options);\n        }\n        return {\n            ...defaultOptions,\n            ...options\n        };\n    };\n    const coreInitialState = {};\n    let initialState = {\n        ...coreInitialState,\n        ...(_options$initialState = options.initialState) != null ? _options$initialState : {}\n    };\n    table._features.forEach((feature)=>{\n        var _feature$getInitialSt;\n        initialState = (_feature$getInitialSt = feature.getInitialState == null ? void 0 : feature.getInitialState(initialState)) != null ? _feature$getInitialSt : initialState;\n    });\n    const queued = [];\n    let queuedTimeout = false;\n    const coreInstance = {\n        _features: features,\n        options: {\n            ...defaultOptions,\n            ...options\n        },\n        initialState,\n        _queue: (cb)=>{\n            queued.push(cb);\n            if (!queuedTimeout) {\n                queuedTimeout = true;\n                // Schedule a microtask to run the queued callbacks after\n                // the current call stack (render, etc) has finished.\n                Promise.resolve().then(()=>{\n                    while(queued.length){\n                        queued.shift()();\n                    }\n                    queuedTimeout = false;\n                }).catch((error)=>setTimeout(()=>{\n                        throw error;\n                    }));\n            }\n        },\n        reset: ()=>{\n            table.setState(table.initialState);\n        },\n        setOptions: (updater)=>{\n            const newOptions = functionalUpdate(updater, table.options);\n            table.options = mergeOptions(newOptions);\n        },\n        getState: ()=>{\n            return table.options.state;\n        },\n        setState: (updater)=>{\n            table.options.onStateChange == null || table.options.onStateChange(updater);\n        },\n        _getRowId: (row, index, parent)=>{\n            var _table$options$getRow;\n            return (_table$options$getRow = table.options.getRowId == null ? void 0 : table.options.getRowId(row, index, parent)) != null ? _table$options$getRow : `${parent ? [\n                parent.id,\n                index\n            ].join(\".\") : index}`;\n        },\n        getCoreRowModel: ()=>{\n            if (!table._getCoreRowModel) {\n                table._getCoreRowModel = table.options.getCoreRowModel(table);\n            }\n            return table._getCoreRowModel();\n        },\n        // The final calls start at the bottom of the model,\n        // expanded rows, which then work their way up\n        getRowModel: ()=>{\n            return table.getPaginationRowModel();\n        },\n        getRow: (id, searchAll)=>{\n            const row = (searchAll ? table.getCoreRowModel() : table.getRowModel()).rowsById[id];\n            if (!row) {\n                if (true) {\n                    throw new Error(`getRow expected an ID, but got ${id}`);\n                }\n                throw new Error();\n            }\n            return row;\n        },\n        _getDefaultColumnDef: memo(()=>[\n                table.options.defaultColumn\n            ], (defaultColumn)=>{\n            var _defaultColumn;\n            defaultColumn = (_defaultColumn = defaultColumn) != null ? _defaultColumn : {};\n            return {\n                header: (props)=>{\n                    const resolvedColumnDef = props.header.column.columnDef;\n                    if (resolvedColumnDef.accessorKey) {\n                        return resolvedColumnDef.accessorKey;\n                    }\n                    if (resolvedColumnDef.accessorFn) {\n                        return resolvedColumnDef.id;\n                    }\n                    return null;\n                },\n                // footer: props => props.header.column.id,\n                cell: (props)=>{\n                    var _props$renderValue$to, _props$renderValue;\n                    return (_props$renderValue$to = (_props$renderValue = props.renderValue()) == null || _props$renderValue.toString == null ? void 0 : _props$renderValue.toString()) != null ? _props$renderValue$to : null;\n                },\n                ...table._features.reduce((obj, feature)=>{\n                    return Object.assign(obj, feature.getDefaultColumnDef == null ? void 0 : feature.getDefaultColumnDef());\n                }, {}),\n                ...defaultColumn\n            };\n        }, {\n            debug: ()=>{\n                var _table$options$debugA;\n                return (_table$options$debugA = table.options.debugAll) != null ? _table$options$debugA : table.options.debugColumns;\n            },\n            key:  true && \"getDefaultColumnDef\"\n        }),\n        _getColumnDefs: ()=>table.options.columns,\n        getAllColumns: memo(()=>[\n                table._getColumnDefs()\n            ], (columnDefs)=>{\n            const recurseColumns = function(columnDefs, parent, depth) {\n                if (depth === void 0) {\n                    depth = 0;\n                }\n                return columnDefs.map((columnDef)=>{\n                    const column = createColumn(table, columnDef, depth, parent);\n                    const groupingColumnDef = columnDef;\n                    column.columns = groupingColumnDef.columns ? recurseColumns(groupingColumnDef.columns, column, depth + 1) : [];\n                    return column;\n                });\n            };\n            return recurseColumns(columnDefs);\n        }, {\n            key:  true && \"getAllColumns\",\n            debug: ()=>{\n                var _table$options$debugA2;\n                return (_table$options$debugA2 = table.options.debugAll) != null ? _table$options$debugA2 : table.options.debugColumns;\n            }\n        }),\n        getAllFlatColumns: memo(()=>[\n                table.getAllColumns()\n            ], (allColumns)=>{\n            return allColumns.flatMap((column)=>{\n                return column.getFlatColumns();\n            });\n        }, {\n            key:  true && \"getAllFlatColumns\",\n            debug: ()=>{\n                var _table$options$debugA3;\n                return (_table$options$debugA3 = table.options.debugAll) != null ? _table$options$debugA3 : table.options.debugColumns;\n            }\n        }),\n        _getAllFlatColumnsById: memo(()=>[\n                table.getAllFlatColumns()\n            ], (flatColumns)=>{\n            return flatColumns.reduce((acc, column)=>{\n                acc[column.id] = column;\n                return acc;\n            }, {});\n        }, {\n            key:  true && \"getAllFlatColumnsById\",\n            debug: ()=>{\n                var _table$options$debugA4;\n                return (_table$options$debugA4 = table.options.debugAll) != null ? _table$options$debugA4 : table.options.debugColumns;\n            }\n        }),\n        getAllLeafColumns: memo(()=>[\n                table.getAllColumns(),\n                table._getOrderColumnsFn()\n            ], (allColumns, orderColumns)=>{\n            let leafColumns = allColumns.flatMap((column)=>column.getLeafColumns());\n            return orderColumns(leafColumns);\n        }, {\n            key:  true && \"getAllLeafColumns\",\n            debug: ()=>{\n                var _table$options$debugA5;\n                return (_table$options$debugA5 = table.options.debugAll) != null ? _table$options$debugA5 : table.options.debugColumns;\n            }\n        }),\n        getColumn: (columnId)=>{\n            const column = table._getAllFlatColumnsById()[columnId];\n            if ( true && !column) {\n                console.error(`[Table] Column with id '${columnId}' does not exist.`);\n            }\n            return column;\n        }\n    };\n    Object.assign(table, coreInstance);\n    for(let index = 0; index < table._features.length; index++){\n        const feature = table._features[index];\n        feature == null || feature.createTable == null || feature.createTable(table);\n    }\n    return table;\n}\nfunction createCell(table, row, column, columnId) {\n    const getRenderValue = ()=>{\n        var _cell$getValue;\n        return (_cell$getValue = cell.getValue()) != null ? _cell$getValue : table.options.renderFallbackValue;\n    };\n    const cell = {\n        id: `${row.id}_${column.id}`,\n        row,\n        column,\n        getValue: ()=>row.getValue(columnId),\n        renderValue: getRenderValue,\n        getContext: memo(()=>[\n                table,\n                column,\n                row,\n                cell\n            ], (table, column, row, cell)=>({\n                table,\n                column,\n                row,\n                cell: cell,\n                getValue: cell.getValue,\n                renderValue: cell.renderValue\n            }), {\n            key:  true && \"cell.getContext\",\n            debug: ()=>table.options.debugAll\n        })\n    };\n    table._features.forEach((feature)=>{\n        feature.createCell == null || feature.createCell(cell, column, row, table);\n    }, {});\n    return cell;\n}\nconst createRow = (table, id, original, rowIndex, depth, subRows, parentId)=>{\n    let row = {\n        id,\n        index: rowIndex,\n        original,\n        depth,\n        parentId,\n        _valuesCache: {},\n        _uniqueValuesCache: {},\n        getValue: (columnId)=>{\n            if (row._valuesCache.hasOwnProperty(columnId)) {\n                return row._valuesCache[columnId];\n            }\n            const column = table.getColumn(columnId);\n            if (!(column != null && column.accessorFn)) {\n                return undefined;\n            }\n            row._valuesCache[columnId] = column.accessorFn(row.original, rowIndex);\n            return row._valuesCache[columnId];\n        },\n        getUniqueValues: (columnId)=>{\n            if (row._uniqueValuesCache.hasOwnProperty(columnId)) {\n                return row._uniqueValuesCache[columnId];\n            }\n            const column = table.getColumn(columnId);\n            if (!(column != null && column.accessorFn)) {\n                return undefined;\n            }\n            if (!column.columnDef.getUniqueValues) {\n                row._uniqueValuesCache[columnId] = [\n                    row.getValue(columnId)\n                ];\n                return row._uniqueValuesCache[columnId];\n            }\n            row._uniqueValuesCache[columnId] = column.columnDef.getUniqueValues(row.original, rowIndex);\n            return row._uniqueValuesCache[columnId];\n        },\n        renderValue: (columnId)=>{\n            var _row$getValue;\n            return (_row$getValue = row.getValue(columnId)) != null ? _row$getValue : table.options.renderFallbackValue;\n        },\n        subRows: subRows != null ? subRows : [],\n        getLeafRows: ()=>flattenBy(row.subRows, (d)=>d.subRows),\n        getParentRow: ()=>row.parentId ? table.getRow(row.parentId, true) : undefined,\n        getParentRows: ()=>{\n            let parentRows = [];\n            let currentRow = row;\n            while(true){\n                const parentRow = currentRow.getParentRow();\n                if (!parentRow) break;\n                parentRows.push(parentRow);\n                currentRow = parentRow;\n            }\n            return parentRows.reverse();\n        },\n        getAllCells: memo(()=>[\n                table.getAllLeafColumns()\n            ], (leafColumns)=>{\n            return leafColumns.map((column)=>{\n                return createCell(table, row, column, column.id);\n            });\n        }, {\n            key:  true && \"row.getAllCells\",\n            debug: ()=>{\n                var _table$options$debugA;\n                return (_table$options$debugA = table.options.debugAll) != null ? _table$options$debugA : table.options.debugRows;\n            }\n        }),\n        _getAllCellsByColumnId: memo(()=>[\n                row.getAllCells()\n            ], (allCells)=>{\n            return allCells.reduce((acc, cell)=>{\n                acc[cell.column.id] = cell;\n                return acc;\n            }, {});\n        }, {\n            key:  false && 0,\n            debug: ()=>{\n                var _table$options$debugA2;\n                return (_table$options$debugA2 = table.options.debugAll) != null ? _table$options$debugA2 : table.options.debugRows;\n            }\n        })\n    };\n    for(let i = 0; i < table._features.length; i++){\n        const feature = table._features[i];\n        feature == null || feature.createRow == null || feature.createRow(row, table);\n    }\n    return row;\n};\n// type Person = {\n//   firstName: string\n//   lastName: string\n//   age: number\n//   visits: number\n//   status: string\n//   progress: number\n//   createdAt: Date\n//   nested: {\n//     foo: [\n//       {\n//         bar: 'bar'\n//       }\n//     ]\n//     bar: { subBar: boolean }[]\n//     baz: {\n//       foo: 'foo'\n//       bar: {\n//         baz: 'baz'\n//       }\n//     }\n//   }\n// }\n// const test: DeepKeys<Person> = 'nested.foo.0.bar'\n// const test2: DeepKeys<Person> = 'nested.bar'\n// const helper = createColumnHelper<Person>()\n// helper.accessor('nested.foo', {\n//   cell: info => info.getValue(),\n// })\n// helper.accessor('nested.foo.0.bar', {\n//   cell: info => info.getValue(),\n// })\n// helper.accessor('nested.bar', {\n//   cell: info => info.getValue(),\n// })\nfunction createColumnHelper() {\n    return {\n        accessor: (accessor, column)=>{\n            return typeof accessor === \"function\" ? {\n                ...column,\n                accessorFn: accessor\n            } : {\n                ...column,\n                accessorKey: accessor\n            };\n        },\n        display: (column)=>column,\n        group: (column)=>column\n    };\n}\nfunction getCoreRowModel() {\n    return (table)=>memo(()=>[\n                table.options.data\n            ], (data)=>{\n            const rowModel = {\n                rows: [],\n                flatRows: [],\n                rowsById: {}\n            };\n            const accessRows = function(originalRows, depth, parentRow) {\n                if (depth === void 0) {\n                    depth = 0;\n                }\n                const rows = [];\n                for(let i = 0; i < originalRows.length; i++){\n                    // This could be an expensive check at scale, so we should move it somewhere else, but where?\n                    // if (!id) {\n                    //   if (process.env.NODE_ENV !== 'production') {\n                    //     throw new Error(`getRowId expected an ID, but got ${id}`)\n                    //   }\n                    // }\n                    // Make the row\n                    const row = createRow(table, table._getRowId(originalRows[i], i, parentRow), originalRows[i], i, depth, undefined, parentRow == null ? void 0 : parentRow.id);\n                    // Keep track of every row in a flat array\n                    rowModel.flatRows.push(row);\n                    // Also keep track of every row by its ID\n                    rowModel.rowsById[row.id] = row;\n                    // Push table row into parent\n                    rows.push(row);\n                    // Get the original subrows\n                    if (table.options.getSubRows) {\n                        var _row$originalSubRows;\n                        row.originalSubRows = table.options.getSubRows(originalRows[i], i);\n                        // Then recursively access them\n                        if ((_row$originalSubRows = row.originalSubRows) != null && _row$originalSubRows.length) {\n                            row.subRows = accessRows(row.originalSubRows, depth + 1, row);\n                        }\n                    }\n                }\n                return rows;\n            };\n            rowModel.rows = accessRows(data);\n            return rowModel;\n        }, {\n            key:  true && \"getRowModel\",\n            debug: ()=>{\n                var _table$options$debugA;\n                return (_table$options$debugA = table.options.debugAll) != null ? _table$options$debugA : table.options.debugTable;\n            },\n            onChange: ()=>{\n                table._autoResetPageIndex();\n            }\n        });\n}\nfunction filterRows(rows, filterRowImpl, table) {\n    if (table.options.filterFromLeafRows) {\n        return filterRowModelFromLeafs(rows, filterRowImpl, table);\n    }\n    return filterRowModelFromRoot(rows, filterRowImpl, table);\n}\nfunction filterRowModelFromLeafs(rowsToFilter, filterRow, table) {\n    var _table$options$maxLea;\n    const newFilteredFlatRows = [];\n    const newFilteredRowsById = {};\n    const maxDepth = (_table$options$maxLea = table.options.maxLeafRowFilterDepth) != null ? _table$options$maxLea : 100;\n    const recurseFilterRows = function(rowsToFilter, depth) {\n        if (depth === void 0) {\n            depth = 0;\n        }\n        const rows = [];\n        // Filter from children up first\n        for(let i = 0; i < rowsToFilter.length; i++){\n            var _row$subRows;\n            let row = rowsToFilter[i];\n            const newRow = createRow(table, row.id, row.original, row.index, row.depth, undefined, row.parentId);\n            newRow.columnFilters = row.columnFilters;\n            if ((_row$subRows = row.subRows) != null && _row$subRows.length && depth < maxDepth) {\n                newRow.subRows = recurseFilterRows(row.subRows, depth + 1);\n                row = newRow;\n                if (filterRow(row) && !newRow.subRows.length) {\n                    rows.push(row);\n                    newFilteredRowsById[row.id] = row;\n                    newFilteredFlatRows.push(row);\n                    continue;\n                }\n                if (filterRow(row) || newRow.subRows.length) {\n                    rows.push(row);\n                    newFilteredRowsById[row.id] = row;\n                    newFilteredFlatRows.push(row);\n                    continue;\n                }\n            } else {\n                row = newRow;\n                if (filterRow(row)) {\n                    rows.push(row);\n                    newFilteredRowsById[row.id] = row;\n                    newFilteredFlatRows.push(row);\n                }\n            }\n        }\n        return rows;\n    };\n    return {\n        rows: recurseFilterRows(rowsToFilter),\n        flatRows: newFilteredFlatRows,\n        rowsById: newFilteredRowsById\n    };\n}\nfunction filterRowModelFromRoot(rowsToFilter, filterRow, table) {\n    var _table$options$maxLea2;\n    const newFilteredFlatRows = [];\n    const newFilteredRowsById = {};\n    const maxDepth = (_table$options$maxLea2 = table.options.maxLeafRowFilterDepth) != null ? _table$options$maxLea2 : 100;\n    // Filters top level and nested rows\n    const recurseFilterRows = function(rowsToFilter, depth) {\n        if (depth === void 0) {\n            depth = 0;\n        }\n        // Filter from parents downward first\n        const rows = [];\n        // Apply the filter to any subRows\n        for(let i = 0; i < rowsToFilter.length; i++){\n            let row = rowsToFilter[i];\n            const pass = filterRow(row);\n            if (pass) {\n                var _row$subRows2;\n                if ((_row$subRows2 = row.subRows) != null && _row$subRows2.length && depth < maxDepth) {\n                    const newRow = createRow(table, row.id, row.original, row.index, row.depth, undefined, row.parentId);\n                    newRow.subRows = recurseFilterRows(row.subRows, depth + 1);\n                    row = newRow;\n                }\n                rows.push(row);\n                newFilteredFlatRows.push(row);\n                newFilteredRowsById[row.id] = row;\n            }\n        }\n        return rows;\n    };\n    return {\n        rows: recurseFilterRows(rowsToFilter),\n        flatRows: newFilteredFlatRows,\n        rowsById: newFilteredRowsById\n    };\n}\nfunction getFilteredRowModel() {\n    return (table)=>memo(()=>[\n                table.getPreFilteredRowModel(),\n                table.getState().columnFilters,\n                table.getState().globalFilter\n            ], (rowModel, columnFilters, globalFilter)=>{\n            if (!rowModel.rows.length || !(columnFilters != null && columnFilters.length) && !globalFilter) {\n                for(let i = 0; i < rowModel.flatRows.length; i++){\n                    rowModel.flatRows[i].columnFilters = {};\n                    rowModel.flatRows[i].columnFiltersMeta = {};\n                }\n                return rowModel;\n            }\n            const resolvedColumnFilters = [];\n            const resolvedGlobalFilters = [];\n            (columnFilters != null ? columnFilters : []).forEach((d)=>{\n                var _filterFn$resolveFilt;\n                const column = table.getColumn(d.id);\n                if (!column) {\n                    return;\n                }\n                const filterFn = column.getFilterFn();\n                if (!filterFn) {\n                    if (true) {\n                        console.warn(`Could not find a valid 'column.filterFn' for column with the ID: ${column.id}.`);\n                    }\n                    return;\n                }\n                resolvedColumnFilters.push({\n                    id: d.id,\n                    filterFn,\n                    resolvedValue: (_filterFn$resolveFilt = filterFn.resolveFilterValue == null ? void 0 : filterFn.resolveFilterValue(d.value)) != null ? _filterFn$resolveFilt : d.value\n                });\n            });\n            const filterableIds = columnFilters.map((d)=>d.id);\n            const globalFilterFn = table.getGlobalFilterFn();\n            const globallyFilterableColumns = table.getAllLeafColumns().filter((column)=>column.getCanGlobalFilter());\n            if (globalFilter && globalFilterFn && globallyFilterableColumns.length) {\n                filterableIds.push(\"__global__\");\n                globallyFilterableColumns.forEach((column)=>{\n                    var _globalFilterFn$resol;\n                    resolvedGlobalFilters.push({\n                        id: column.id,\n                        filterFn: globalFilterFn,\n                        resolvedValue: (_globalFilterFn$resol = globalFilterFn.resolveFilterValue == null ? void 0 : globalFilterFn.resolveFilterValue(globalFilter)) != null ? _globalFilterFn$resol : globalFilter\n                    });\n                });\n            }\n            let currentColumnFilter;\n            let currentGlobalFilter;\n            // Flag the prefiltered row model with each filter state\n            for(let j = 0; j < rowModel.flatRows.length; j++){\n                const row = rowModel.flatRows[j];\n                row.columnFilters = {};\n                if (resolvedColumnFilters.length) {\n                    for(let i = 0; i < resolvedColumnFilters.length; i++){\n                        currentColumnFilter = resolvedColumnFilters[i];\n                        const id = currentColumnFilter.id;\n                        // Tag the row with the column filter state\n                        row.columnFilters[id] = currentColumnFilter.filterFn(row, id, currentColumnFilter.resolvedValue, (filterMeta)=>{\n                            row.columnFiltersMeta[id] = filterMeta;\n                        });\n                    }\n                }\n                if (resolvedGlobalFilters.length) {\n                    for(let i = 0; i < resolvedGlobalFilters.length; i++){\n                        currentGlobalFilter = resolvedGlobalFilters[i];\n                        const id = currentGlobalFilter.id;\n                        // Tag the row with the first truthy global filter state\n                        if (currentGlobalFilter.filterFn(row, id, currentGlobalFilter.resolvedValue, (filterMeta)=>{\n                            row.columnFiltersMeta[id] = filterMeta;\n                        })) {\n                            row.columnFilters.__global__ = true;\n                            break;\n                        }\n                    }\n                    if (row.columnFilters.__global__ !== true) {\n                        row.columnFilters.__global__ = false;\n                    }\n                }\n            }\n            const filterRowsImpl = (row)=>{\n                // Horizontally filter rows through each column\n                for(let i = 0; i < filterableIds.length; i++){\n                    if (row.columnFilters[filterableIds[i]] === false) {\n                        return false;\n                    }\n                }\n                return true;\n            };\n            // Filter final rows using all of the active filters\n            return filterRows(rowModel.rows, filterRowsImpl, table);\n        }, {\n            key:  true && \"getFilteredRowModel\",\n            debug: ()=>{\n                var _table$options$debugA;\n                return (_table$options$debugA = table.options.debugAll) != null ? _table$options$debugA : table.options.debugTable;\n            },\n            onChange: ()=>{\n                table._autoResetPageIndex();\n            }\n        });\n}\nfunction getFacetedRowModel() {\n    return (table, columnId)=>memo(()=>[\n                table.getPreFilteredRowModel(),\n                table.getState().columnFilters,\n                table.getState().globalFilter,\n                table.getFilteredRowModel()\n            ], (preRowModel, columnFilters, globalFilter)=>{\n            if (!preRowModel.rows.length || !(columnFilters != null && columnFilters.length) && !globalFilter) {\n                return preRowModel;\n            }\n            const filterableIds = [\n                ...columnFilters.map((d)=>d.id).filter((d)=>d !== columnId),\n                globalFilter ? \"__global__\" : undefined\n            ].filter(Boolean);\n            const filterRowsImpl = (row)=>{\n                // Horizontally filter rows through each column\n                for(let i = 0; i < filterableIds.length; i++){\n                    if (row.columnFilters[filterableIds[i]] === false) {\n                        return false;\n                    }\n                }\n                return true;\n            };\n            return filterRows(preRowModel.rows, filterRowsImpl, table);\n        }, {\n            key:  true && \"getFacetedRowModel_\" + columnId,\n            debug: ()=>{\n                var _table$options$debugA;\n                return (_table$options$debugA = table.options.debugAll) != null ? _table$options$debugA : table.options.debugTable;\n            },\n            onChange: ()=>{}\n        });\n}\nfunction getFacetedUniqueValues() {\n    return (table, columnId)=>memo(()=>{\n            var _table$getColumn;\n            return [\n                (_table$getColumn = table.getColumn(columnId)) == null ? void 0 : _table$getColumn.getFacetedRowModel()\n            ];\n        }, (facetedRowModel)=>{\n            if (!facetedRowModel) return new Map();\n            let facetedUniqueValues = new Map();\n            for(let i = 0; i < facetedRowModel.flatRows.length; i++){\n                const values = facetedRowModel.flatRows[i].getUniqueValues(columnId);\n                for(let j = 0; j < values.length; j++){\n                    const value = values[j];\n                    if (facetedUniqueValues.has(value)) {\n                        var _facetedUniqueValues$;\n                        facetedUniqueValues.set(value, ((_facetedUniqueValues$ = facetedUniqueValues.get(value)) != null ? _facetedUniqueValues$ : 0) + 1);\n                    } else {\n                        facetedUniqueValues.set(value, 1);\n                    }\n                }\n            }\n            return facetedUniqueValues;\n        }, {\n            key:  true && \"getFacetedUniqueValues_\" + columnId,\n            debug: ()=>{\n                var _table$options$debugA;\n                return (_table$options$debugA = table.options.debugAll) != null ? _table$options$debugA : table.options.debugTable;\n            },\n            onChange: ()=>{}\n        });\n}\nfunction getFacetedMinMaxValues() {\n    return (table, columnId)=>memo(()=>{\n            var _table$getColumn;\n            return [\n                (_table$getColumn = table.getColumn(columnId)) == null ? void 0 : _table$getColumn.getFacetedRowModel()\n            ];\n        }, (facetedRowModel)=>{\n            var _facetedRowModel$flat;\n            if (!facetedRowModel) return undefined;\n            const firstValue = (_facetedRowModel$flat = facetedRowModel.flatRows[0]) == null ? void 0 : _facetedRowModel$flat.getUniqueValues(columnId);\n            if (typeof firstValue === \"undefined\") {\n                return undefined;\n            }\n            let facetedMinMaxValues = [\n                firstValue,\n                firstValue\n            ];\n            for(let i = 0; i < facetedRowModel.flatRows.length; i++){\n                const values = facetedRowModel.flatRows[i].getUniqueValues(columnId);\n                for(let j = 0; j < values.length; j++){\n                    const value = values[j];\n                    if (value < facetedMinMaxValues[0]) {\n                        facetedMinMaxValues[0] = value;\n                    } else if (value > facetedMinMaxValues[1]) {\n                        facetedMinMaxValues[1] = value;\n                    }\n                }\n            }\n            return facetedMinMaxValues;\n        }, {\n            key:  true && \"getFacetedMinMaxValues_\" + columnId,\n            debug: ()=>{\n                var _table$options$debugA;\n                return (_table$options$debugA = table.options.debugAll) != null ? _table$options$debugA : table.options.debugTable;\n            },\n            onChange: ()=>{}\n        });\n}\nfunction getSortedRowModel() {\n    return (table)=>memo(()=>[\n                table.getState().sorting,\n                table.getPreSortedRowModel()\n            ], (sorting, rowModel)=>{\n            if (!rowModel.rows.length || !(sorting != null && sorting.length)) {\n                return rowModel;\n            }\n            const sortingState = table.getState().sorting;\n            const sortedFlatRows = [];\n            // Filter out sortings that correspond to non existing columns\n            const availableSorting = sortingState.filter((sort)=>{\n                var _table$getColumn;\n                return (_table$getColumn = table.getColumn(sort.id)) == null ? void 0 : _table$getColumn.getCanSort();\n            });\n            const columnInfoById = {};\n            availableSorting.forEach((sortEntry)=>{\n                const column = table.getColumn(sortEntry.id);\n                if (!column) return;\n                columnInfoById[sortEntry.id] = {\n                    sortUndefined: column.columnDef.sortUndefined,\n                    invertSorting: column.columnDef.invertSorting,\n                    sortingFn: column.getSortingFn()\n                };\n            });\n            const sortData = (rows)=>{\n                // This will also perform a stable sorting using the row index\n                // if needed.\n                const sortedData = rows.map((row)=>({\n                        ...row\n                    }));\n                sortedData.sort((rowA, rowB)=>{\n                    for(let i = 0; i < availableSorting.length; i += 1){\n                        var _sortEntry$desc;\n                        const sortEntry = availableSorting[i];\n                        const columnInfo = columnInfoById[sortEntry.id];\n                        const isDesc = (_sortEntry$desc = sortEntry == null ? void 0 : sortEntry.desc) != null ? _sortEntry$desc : false;\n                        let sortInt = 0;\n                        // All sorting ints should always return in ascending order\n                        if (columnInfo.sortUndefined) {\n                            const aValue = rowA.getValue(sortEntry.id);\n                            const bValue = rowB.getValue(sortEntry.id);\n                            const aUndefined = aValue === undefined;\n                            const bUndefined = bValue === undefined;\n                            if (aUndefined || bUndefined) {\n                                sortInt = aUndefined && bUndefined ? 0 : aUndefined ? columnInfo.sortUndefined : -columnInfo.sortUndefined;\n                            }\n                        }\n                        if (sortInt === 0) {\n                            sortInt = columnInfo.sortingFn(rowA, rowB, sortEntry.id);\n                        }\n                        // If sorting is non-zero, take care of desc and inversion\n                        if (sortInt !== 0) {\n                            if (isDesc) {\n                                sortInt *= -1;\n                            }\n                            if (columnInfo.invertSorting) {\n                                sortInt *= -1;\n                            }\n                            return sortInt;\n                        }\n                    }\n                    return rowA.index - rowB.index;\n                });\n                // If there are sub-rows, sort them\n                sortedData.forEach((row)=>{\n                    var _row$subRows;\n                    sortedFlatRows.push(row);\n                    if ((_row$subRows = row.subRows) != null && _row$subRows.length) {\n                        row.subRows = sortData(row.subRows);\n                    }\n                });\n                return sortedData;\n            };\n            return {\n                rows: sortData(rowModel.rows),\n                flatRows: sortedFlatRows,\n                rowsById: rowModel.rowsById\n            };\n        }, {\n            key:  true && \"getSortedRowModel\",\n            debug: ()=>{\n                var _table$options$debugA;\n                return (_table$options$debugA = table.options.debugAll) != null ? _table$options$debugA : table.options.debugTable;\n            },\n            onChange: ()=>{\n                table._autoResetPageIndex();\n            }\n        });\n}\nfunction getGroupedRowModel() {\n    return (table)=>memo(()=>[\n                table.getState().grouping,\n                table.getPreGroupedRowModel()\n            ], (grouping, rowModel)=>{\n            if (!rowModel.rows.length || !grouping.length) {\n                return rowModel;\n            }\n            // Filter the grouping list down to columns that exist\n            const existingGrouping = grouping.filter((columnId)=>table.getColumn(columnId));\n            const groupedFlatRows = [];\n            const groupedRowsById = {};\n            // const onlyGroupedFlatRows: Row[] = [];\n            // const onlyGroupedRowsById: Record<RowId, Row> = {};\n            // const nonGroupedFlatRows: Row[] = [];\n            // const nonGroupedRowsById: Record<RowId, Row> = {};\n            // Recursively group the data\n            const groupUpRecursively = function(rows, depth, parentId) {\n                if (depth === void 0) {\n                    depth = 0;\n                }\n                // Grouping depth has been been met\n                // Stop grouping and simply rewrite thd depth and row relationships\n                if (depth >= existingGrouping.length) {\n                    return rows.map((row)=>{\n                        row.depth = depth;\n                        groupedFlatRows.push(row);\n                        groupedRowsById[row.id] = row;\n                        if (row.subRows) {\n                            row.subRows = groupUpRecursively(row.subRows, depth + 1, row.id);\n                        }\n                        return row;\n                    });\n                }\n                const columnId = existingGrouping[depth];\n                // Group the rows together for this level\n                const rowGroupsMap = groupBy(rows, columnId);\n                // Peform aggregations for each group\n                const aggregatedGroupedRows = Array.from(rowGroupsMap.entries()).map((_ref, index)=>{\n                    let [groupingValue, groupedRows] = _ref;\n                    let id = `${columnId}:${groupingValue}`;\n                    id = parentId ? `${parentId}>${id}` : id;\n                    // First, Recurse to group sub rows before aggregation\n                    const subRows = groupUpRecursively(groupedRows, depth + 1, id);\n                    // Flatten the leaf rows of the rows in this group\n                    const leafRows = depth ? flattenBy(groupedRows, (row)=>row.subRows) : groupedRows;\n                    const row = createRow(table, id, leafRows[0].original, index, depth, undefined, parentId);\n                    Object.assign(row, {\n                        groupingColumnId: columnId,\n                        groupingValue,\n                        subRows,\n                        leafRows,\n                        getValue: (columnId)=>{\n                            // Don't aggregate columns that are in the grouping\n                            if (existingGrouping.includes(columnId)) {\n                                if (row._valuesCache.hasOwnProperty(columnId)) {\n                                    return row._valuesCache[columnId];\n                                }\n                                if (groupedRows[0]) {\n                                    var _groupedRows$0$getVal;\n                                    row._valuesCache[columnId] = (_groupedRows$0$getVal = groupedRows[0].getValue(columnId)) != null ? _groupedRows$0$getVal : undefined;\n                                }\n                                return row._valuesCache[columnId];\n                            }\n                            if (row._groupingValuesCache.hasOwnProperty(columnId)) {\n                                return row._groupingValuesCache[columnId];\n                            }\n                            // Aggregate the values\n                            const column = table.getColumn(columnId);\n                            const aggregateFn = column == null ? void 0 : column.getAggregationFn();\n                            if (aggregateFn) {\n                                row._groupingValuesCache[columnId] = aggregateFn(columnId, leafRows, groupedRows);\n                                return row._groupingValuesCache[columnId];\n                            }\n                        }\n                    });\n                    subRows.forEach((subRow)=>{\n                        groupedFlatRows.push(subRow);\n                        groupedRowsById[subRow.id] = subRow;\n                    // if (subRow.getIsGrouped?.()) {\n                    //   onlyGroupedFlatRows.push(subRow);\n                    //   onlyGroupedRowsById[subRow.id] = subRow;\n                    // } else {\n                    //   nonGroupedFlatRows.push(subRow);\n                    //   nonGroupedRowsById[subRow.id] = subRow;\n                    // }\n                    });\n                    return row;\n                });\n                return aggregatedGroupedRows;\n            };\n            const groupedRows = groupUpRecursively(rowModel.rows, 0);\n            groupedRows.forEach((subRow)=>{\n                groupedFlatRows.push(subRow);\n                groupedRowsById[subRow.id] = subRow;\n            // if (subRow.getIsGrouped?.()) {\n            //   onlyGroupedFlatRows.push(subRow);\n            //   onlyGroupedRowsById[subRow.id] = subRow;\n            // } else {\n            //   nonGroupedFlatRows.push(subRow);\n            //   nonGroupedRowsById[subRow.id] = subRow;\n            // }\n            });\n            return {\n                rows: groupedRows,\n                flatRows: groupedFlatRows,\n                rowsById: groupedRowsById\n            };\n        }, {\n            key:  true && \"getGroupedRowModel\",\n            debug: ()=>{\n                var _table$options$debugA;\n                return (_table$options$debugA = table.options.debugAll) != null ? _table$options$debugA : table.options.debugTable;\n            },\n            onChange: ()=>{\n                table._queue(()=>{\n                    table._autoResetExpanded();\n                    table._autoResetPageIndex();\n                });\n            }\n        });\n}\nfunction groupBy(rows, columnId) {\n    const groupMap = new Map();\n    return rows.reduce((map, row)=>{\n        const resKey = `${row.getGroupingValue(columnId)}`;\n        const previous = map.get(resKey);\n        if (!previous) {\n            map.set(resKey, [\n                row\n            ]);\n        } else {\n            previous.push(row);\n        }\n        return map;\n    }, groupMap);\n}\nfunction getExpandedRowModel() {\n    return (table)=>memo(()=>[\n                table.getState().expanded,\n                table.getPreExpandedRowModel(),\n                table.options.paginateExpandedRows\n            ], (expanded, rowModel, paginateExpandedRows)=>{\n            if (!rowModel.rows.length || expanded !== true && !Object.keys(expanded != null ? expanded : {}).length) {\n                return rowModel;\n            }\n            if (!paginateExpandedRows) {\n                // Only expand rows at this point if they are being paginated\n                return rowModel;\n            }\n            return expandRows(rowModel);\n        }, {\n            key:  true && \"getExpandedRowModel\",\n            debug: ()=>{\n                var _table$options$debugA;\n                return (_table$options$debugA = table.options.debugAll) != null ? _table$options$debugA : table.options.debugTable;\n            }\n        });\n}\nfunction expandRows(rowModel) {\n    const expandedRows = [];\n    const handleRow = (row)=>{\n        var _row$subRows;\n        expandedRows.push(row);\n        if ((_row$subRows = row.subRows) != null && _row$subRows.length && row.getIsExpanded()) {\n            row.subRows.forEach(handleRow);\n        }\n    };\n    rowModel.rows.forEach(handleRow);\n    return {\n        rows: expandedRows,\n        flatRows: rowModel.flatRows,\n        rowsById: rowModel.rowsById\n    };\n}\nfunction getPaginationRowModel(opts) {\n    return (table)=>memo(()=>[\n                table.getState().pagination,\n                table.getPrePaginationRowModel(),\n                table.options.paginateExpandedRows ? undefined : table.getState().expanded\n            ], (pagination, rowModel)=>{\n            if (!rowModel.rows.length) {\n                return rowModel;\n            }\n            const { pageSize, pageIndex } = pagination;\n            let { rows, flatRows, rowsById } = rowModel;\n            const pageStart = pageSize * pageIndex;\n            const pageEnd = pageStart + pageSize;\n            rows = rows.slice(pageStart, pageEnd);\n            let paginatedRowModel;\n            if (!table.options.paginateExpandedRows) {\n                paginatedRowModel = expandRows({\n                    rows,\n                    flatRows,\n                    rowsById\n                });\n            } else {\n                paginatedRowModel = {\n                    rows,\n                    flatRows,\n                    rowsById\n                };\n            }\n            paginatedRowModel.flatRows = [];\n            const handleRow = (row)=>{\n                paginatedRowModel.flatRows.push(row);\n                if (row.subRows.length) {\n                    row.subRows.forEach(handleRow);\n                }\n            };\n            paginatedRowModel.rows.forEach(handleRow);\n            return paginatedRowModel;\n        }, {\n            key:  true && \"getPaginationRowModel\",\n            debug: ()=>{\n                var _table$options$debugA;\n                return (_table$options$debugA = table.options.debugAll) != null ? _table$options$debugA : table.options.debugTable;\n            }\n        });\n}\n //# sourceMappingURL=index.mjs.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQHRhbnN0YWNrL3RhYmxlLWNvcmUvYnVpbGQvbGliL2luZGV4Lm1qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFBQTs7Ozs7Ozs7O0NBU0MsR0FDRCx3QkFBd0I7QUFFeEIscURBQXFEO0FBRXJELEdBQUc7QUFFSCxTQUFTQSxpQkFBaUJDLE9BQU8sRUFBRUMsS0FBSztJQUN0QyxPQUFPLE9BQU9ELFlBQVksYUFBYUEsUUFBUUMsU0FBU0Q7QUFDMUQ7QUFDQSxTQUFTRTtBQUNQLEVBQUU7QUFDSjtBQUNBLFNBQVNDLGlCQUFpQkMsR0FBRyxFQUFFQyxRQUFRO0lBQ3JDLE9BQU9MLENBQUFBO1FBQ0xLLFNBQVNDLFFBQVEsQ0FBQ0MsQ0FBQUE7WUFDaEIsT0FBTztnQkFDTCxHQUFHQSxHQUFHO2dCQUNOLENBQUNILElBQUksRUFBRUwsaUJBQWlCQyxTQUFTTyxHQUFHLENBQUNILElBQUk7WUFDM0M7UUFDRjtJQUNGO0FBQ0Y7QUFDQSxTQUFTSSxXQUFXQyxDQUFDO0lBQ25CLE9BQU9BLGFBQWFDO0FBQ3RCO0FBQ0EsU0FBU0MsY0FBY0YsQ0FBQztJQUN0QixPQUFPRyxNQUFNQyxPQUFPLENBQUNKLE1BQU1BLEVBQUVLLEtBQUssQ0FBQ0MsQ0FBQUEsTUFBTyxPQUFPQSxRQUFRO0FBQzNEO0FBQ0EsU0FBU0MsVUFBVUMsR0FBRyxFQUFFQyxXQUFXO0lBQ2pDLE1BQU1DLE9BQU8sRUFBRTtJQUNmLE1BQU1DLFVBQVVDLENBQUFBO1FBQ2RBLE9BQU9DLE9BQU8sQ0FBQ0MsQ0FBQUE7WUFDYkosS0FBS0ssSUFBSSxDQUFDRDtZQUNWLE1BQU1FLFdBQVdQLFlBQVlLO1lBQzdCLElBQUlFLFlBQVksUUFBUUEsU0FBU0MsTUFBTSxFQUFFO2dCQUN2Q04sUUFBUUs7WUFDVjtRQUNGO0lBQ0Y7SUFDQUwsUUFBUUg7SUFDUixPQUFPRTtBQUNUO0FBQ0EsU0FBU1EsS0FB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QyxJQUFJQSxJQUFJNkIsT0FBTyxDQUFDeFUsTUFBTSxFQUFFO29CQUN0QjJTLElBQUk2QixPQUFPLENBQUM1VSxPQUFPLENBQUMrNUI7Z0JBQ3RCO1lBQ0Y7WUFDQUcsa0JBQWtCNVcsSUFBSSxDQUFDdGpCLE9BQU8sQ0FBQys1QjtZQUMvQixPQUFPRztRQUNULEdBQUc7WUFDRHA3QixLQUFLeUUsS0FBeUIsSUFBaUI7WUFDL0MzQyxPQUFPO2dCQUNMLElBQUltRDtnQkFDSixPQUFPLENBQUNBLHdCQUF3QjNCLE1BQU00QixPQUFPLENBQUNDLFFBQVEsS0FBSyxPQUFPRix3QkFBd0IzQixNQUFNNEIsT0FBTyxDQUFDNmUsVUFBVTtZQUNwSDtRQUNGO0FBQ0Y7QUFFc3JCLENBQ3RyQixrQ0FBa0MiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly92aXNpb24vLi9ub2RlX21vZHVsZXMvQHRhbnN0YWNrL3RhYmxlLWNvcmUvYnVpbGQvbGliL2luZGV4Lm1qcz81NTZiIl0sInNvdXJjZXNDb250ZW50IjpbIi8qKlxuICogdGFibGUtY29yZVxuICpcbiAqIENvcHlyaWdodCAoYykgVGFuU3RhY2tcbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UubWQgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS5cbiAqXG4gKiBAbGljZW5zZSBNSVRcbiAqL1xuLy8gSXMgdGhpcyB0eXBlIGEgdHVwbGU/XG5cbi8vIElmIHRoaXMgdHlwZSBpcyBhIHR1cGxlLCB3aGF0IGluZGljZXMgYXJlIGFsbG93ZWQ/XG5cbi8vL1xuXG5mdW5jdGlvbiBmdW5jdGlvbmFsVXBkYXRlKHVwZGF0ZXIsIGlucHV0KSB7XG4gIHJldHVybiB0eXBlb2YgdXBkYXRlciA9PT0gJ2Z1bmN0aW9uJyA/IHVwZGF0ZXIoaW5wdXQpIDogdXBkYXRlcjtcbn1cbmZ1bmN0aW9uIG5vb3AoKSB7XG4gIC8vXG59XG5mdW5jdGlvbiBtYWtlU3RhdGVVcGRhdGVyKGtleSwgaW5zdGFuY2UpIHtcbiAgcmV0dXJuIHVwZGF0ZXIgPT4ge1xuICAgIGluc3RhbmNlLnNldFN0YXRlKG9sZCA9PiB7XG4gICAgICByZXR1cm4ge1xuICAgICAgICAuLi5vbGQsXG4gICAgICAgIFtrZXldOiBmdW5jdGlvbmFsVXBkYXRlKHVwZGF0ZXIsIG9sZFtrZXldKVxuICAgICAgfTtcbiAgICB9KTtcbiAgfTtcbn1cbmZ1bmN0aW9uIGlzRnVuY3Rpb24oZCkge1xuICByZXR1cm4gZCBpbnN0YW5jZW9mIEZ1bmN0aW9uO1xufVxuZnVuY3Rpb24gaXNOdW1iZXJBcnJheShkKSB7XG4gIHJldHVybiBBcnJheS5pc0FycmF5KGQpICYmIGQuZXZlcnkodmFsID0+IHR5cGVvZiB2YWwgPT09ICdudW1iZXInKTtcbn1cbmZ1bmN0aW9uIGZsYXR0ZW5CeShhcnIsIGdldENoaWxkcmVuKSB7XG4gIGNvbnN0IGZsYXQgPSBbXTtcbiAgY29uc3QgcmVjdXJzZSA9IHN1YkFyciA9PiB7XG4gICAgc3ViQXJyLmZvckVhY2goaXRlbSA9PiB7XG4gICAgICBmbGF0LnB1c2goaXRlbSk7XG4gICAgICBjb25zdCBjaGlsZHJlbiA9IGdldENoaWxkcmVuKGl0ZW0pO1xuICAgICAgaWYgKGNoaWxkcmVuICE9IG51bGwgJiYgY2hpbGRyZW4ubGVuZ3RoKSB7XG4gICAgICAgIHJlY3Vyc2UoY2hpbGRyZW4pO1xuICAgICAgfVxuICAgIH0pO1xuICB9O1xuICByZWN1cnNlKGFycik7XG4gIHJldHVybiBmbGF0O1xufVxuZnVuY3Rpb24gbWVtbyhnZXREZXBzLCBmbiwgb3B0cykge1xuICBsZXQgZGVwcyA9IFtdO1xuICBsZXQgcmVzdWx0O1xuICByZXR1cm4gKCkgPT4ge1xuICAgIGxldCBkZXBUaW1lO1xuICAgIGlmIChvcHRzLmtleSAmJiBvcHRzLmRlYnVnKSBkZXBUaW1lID0gRGF0ZS5ub3coKTtcbiAgICBjb25zdCBuZXdEZXBzID0gZ2V0RGVwcygpO1xuICAgIGNvbnN0IGRlcHNDaGFuZ2VkID0gbmV3RGVwcy5sZW5ndGggIT09IGRlcHMubGVuZ3RoIHx8IG5ld0RlcHMuc29tZSgoZGVwLCBpbmRleCkgPT4gZGVwc1tpbmRleF0gIT09IGRlcCk7XG4gICAgaWYgKCFkZXBzQ2hhbmdlZCkge1xuICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG4gICAgZGVwcyA9IG5ld0RlcHM7XG4gICAgbGV0IHJlc3VsdFRpbWU7XG4gICAgaWYgKG9wdHMua2V5ICYmIG9wdHMuZGVidWcpIHJlc3VsdFRpbWUgPSBEYXRlLm5vdygpO1xuICAgIHJlc3VsdCA9IGZuKC4uLm5ld0RlcHMpO1xuICAgIG9wdHMgPT0gbnVsbCB8fCBvcHRzLm9uQ2hhbmdlID09IG51bGwgfHwgb3B0cy5vbkNoYW5nZShyZXN1bHQpO1xuICAgIGlmIChvcHRzLmtleSAmJiBvcHRzLmRlYnVnKSB7XG4gICAgICBpZiAob3B0cyAhPSBudWxsICYmIG9wdHMuZGVidWcoKSkge1xuICAgICAgICBjb25zdCBkZXBFbmRUaW1lID0gTWF0aC5yb3VuZCgoRGF0ZS5ub3coKSAtIGRlcFRpbWUpICogMTAwKSAvIDEwMDtcbiAgICAgICAgY29uc3QgcmVzdWx0RW5kVGltZSA9IE1hdGgucm91bmQoKERhdGUubm93KCkgLSByZXN1bHRUaW1lKSAqIDEwMCkgLyAxMDA7XG4gICAgICAgIGNvbnN0IHJlc3VsdEZwc1BlcmNlbnRhZ2UgPSByZXN1bHRFbmRUaW1lIC8gMTY7XG4gICAgICAgIGNvbnN0IHBhZCA9IChzdHIsIG51bSkgPT4ge1xuICAgICAgICAgIHN0ciA9IFN0cmluZyhzdHIpO1xuICAgICAgICAgIHdoaWxlIChzdHIubGVuZ3RoIDwgbnVtKSB7XG4gICAgICAgICAgICBzdHIgPSAnICcgKyBzdHI7XG4gICAgICAgICAgfVxuICAgICAgICAgIHJldHVybiBzdHI7XG4gICAgICAgIH07XG4gICAgICAgIGNvbnNvbGUuaW5mbyhgJWPij7EgJHtwYWQocmVzdWx0RW5kVGltZSwgNSl9IC8ke3BhZChkZXBFbmRUaW1lLCA1KX0gbXNgLCBgXG4gICAgICAgICAgICBmb250LXNpemU6IC42cmVtO1xuICAgICAgICAgICAgZm9udC13ZWlnaHQ6IGJvbGQ7XG4gICAgICAgICAgICBjb2xvcjogaHNsKCR7TWF0aC5tYXgoMCwgTWF0aC5taW4oMTIwIC0gMTIwICogcmVzdWx0RnBzUGVyY2VudGFnZSwgMTIwKSl9ZGVnIDEwMCUgMzElKTtgLCBvcHRzID09IG51bGwgPyB2b2lkIDAgOiBvcHRzLmtleSk7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiByZXN1bHQ7XG4gIH07XG59XG5cbmZ1bmN0aW9uIGNyZWF0ZUNvbHVtbih0YWJsZSwgY29sdW1uRGVmLCBkZXB0aCwgcGFyZW50KSB7XG4gIHZhciBfcmVmLCBfcmVzb2x2ZWRDb2x1bW5EZWYkaWQ7XG4gIGNvbnN0IGRlZmF1bHRDb2x1bW4gPSB0YWJsZS5fZ2V0RGVmYXVsdENvbHVtbkRlZigpO1xuICBjb25zdCByZXNvbHZlZENvbHVtbkRlZiA9IHtcbiAgICAuLi5kZWZhdWx0Q29sdW1uLFxuICAgIC4uLmNvbHVtbkRlZlxuICB9O1xuICBjb25zdCBhY2Nlc3NvcktleSA9IHJlc29sdmVkQ29sdW1uRGVmLmFjY2Vzc29yS2V5O1xuICBsZXQgaWQgPSAoX3JlZiA9IChfcmVzb2x2ZWRDb2x1bW5EZWYkaWQgPSByZXNvbHZlZENvbHVtbkRlZi5pZCkgIT0gbnVsbCA/IF9yZXNvbHZlZENvbHVtbkRlZiRpZCA6IGFjY2Vzc29yS2V5ID8gYWNjZXNzb3JLZXkucmVwbGFjZSgnLicsICdfJykgOiB1bmRlZmluZWQpICE9IG51bGwgPyBfcmVmIDogdHlwZW9mIHJlc29sdmVkQ29sdW1uRGVmLmhlYWRlciA9PT0gJ3N0cmluZycgPyByZXNvbHZlZENvbHVtbkRlZi5oZWFkZXIgOiB1bmRlZmluZWQ7XG4gIGxldCBhY2Nlc3NvckZuO1xuICBpZiAocmVzb2x2ZWRDb2x1bW5EZWYuYWNjZXNzb3JGbikge1xuICAgIGFjY2Vzc29yRm4gPSByZXNvbHZlZENvbHVtbkRlZi5hY2Nlc3NvckZuO1xuICB9IGVsc2UgaWYgKGFjY2Vzc29yS2V5KSB7XG4gICAgLy8gU3VwcG9ydCBkZWVwIGFjY2Vzc29yIGtleXNcbiAgICBpZiAoYWNjZXNzb3JLZXkuaW5jbHVkZXMoJy4nKSkge1xuICAgICAgYWNjZXNzb3JGbiA9IG9yaWdpbmFsUm93ID0+IHtcbiAgICAgICAgbGV0IHJlc3VsdCA9IG9yaWdpbmFsUm93O1xuICAgICAgICBmb3IgKGNvbnN0IGtleSBvZiBhY2Nlc3NvcktleS5zcGxpdCgnLicpKSB7XG4gICAgICAgICAgdmFyIF9yZXN1bHQ7XG4gICAgICAgICAgcmVzdWx0ID0gKF9yZXN1bHQgPSByZXN1bHQpID09IG51bGwgPyB2b2lkIDAgOiBfcmVzdWx0W2tleV07XG4gICAgICAgICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgJiYgcmVzdWx0ID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIGNvbnNvbGUud2FybihgXCIke2tleX1cIiBpbiBkZWVwbHkgbmVzdGVkIGtleSBcIiR7YWNjZXNzb3JLZXl9XCIgcmV0dXJuZWQgdW5kZWZpbmVkLmApO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgfTtcbiAgICB9IGVsc2Uge1xuICAgICAgYWNjZXNzb3JGbiA9IG9yaWdpbmFsUm93ID0+IG9yaWdpbmFsUm93W3Jlc29sdmVkQ29sdW1uRGVmLmFjY2Vzc29yS2V5XTtcbiAgICB9XG4gIH1cbiAgaWYgKCFpZCkge1xuICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IocmVzb2x2ZWRDb2x1bW5EZWYuYWNjZXNzb3JGbiA/IGBDb2x1bW5zIHJlcXVpcmUgYW4gaWQgd2hlbiB1c2luZyBhbiBhY2Nlc3NvckZuYCA6IGBDb2x1bW5zIHJlcXVpcmUgYW4gaWQgd2hlbiB1c2luZyBhIG5vbi1zdHJpbmcgaGVhZGVyYCk7XG4gICAgfVxuICAgIHRocm93IG5ldyBFcnJvcigpO1xuICB9XG4gIGxldCBjb2x1bW4gPSB7XG4gICAgaWQ6IGAke1N0cmluZyhpZCl9YCxcbiAgICBhY2Nlc3NvckZuLFxuICAgIHBhcmVudDogcGFyZW50LFxuICAgIGRlcHRoLFxuICAgIGNvbHVtbkRlZjogcmVzb2x2ZWRDb2x1bW5EZWYsXG4gICAgY29sdW1uczogW10sXG4gICAgZ2V0RmxhdENvbHVtbnM6IG1lbW8oKCkgPT4gW3RydWVdLCAoKSA9PiB7XG4gICAgICB2YXIgX2NvbHVtbiRjb2x1bW5zO1xuICAgICAgcmV0dXJuIFtjb2x1bW4sIC4uLigoX2NvbHVtbiRjb2x1bW5zID0gY29sdW1uLmNvbHVtbnMpID09IG51bGwgPyB2b2lkIDAgOiBfY29sdW1uJGNvbHVtbnMuZmxhdE1hcChkID0+IGQuZ2V0RmxhdENvbHVtbnMoKSkpXTtcbiAgICB9LCB7XG4gICAgICBrZXk6IHByb2Nlc3MuZW52Lk5PREVfRU5WID09PSAncHJvZHVjdGlvbicgJiYgJ2NvbHVtbi5nZXRGbGF0Q29sdW1ucycsXG4gICAgICBkZWJ1ZzogKCkgPT4ge1xuICAgICAgICB2YXIgX3RhYmxlJG9wdGlvbnMkZGVidWdBO1xuICAgICAgICByZXR1cm4gKF90YWJsZSRvcHRpb25zJGRlYnVnQSA9IHRhYmxlLm9wdGlvbnMuZGVidWdBbGwpICE9IG51bGwgPyBfdGFibGUkb3B0aW9ucyRkZWJ1Z0EgOiB0YWJsZS5vcHRpb25zLmRlYnVnQ29sdW1ucztcbiAgICAgIH1cbiAgICB9KSxcbiAgICBnZXRMZWFmQ29sdW1uczogbWVtbygoKSA9PiBbdGFibGUuX2dldE9yZGVyQ29sdW1uc0ZuKCldLCBvcmRlckNvbHVtbnMgPT4ge1xuICAgICAgdmFyIF9jb2x1bW4kY29sdW1uczI7XG4gICAgICBpZiAoKF9jb2x1bW4kY29sdW1uczIgPSBjb2x1bW4uY29sdW1ucykgIT0gbnVsbCAmJiBfY29sdW1uJGNvbHVtbnMyLmxlbmd0aCkge1xuICAgICAgICBsZXQgbGVhZkNvbHVtbnMgPSBjb2x1bW4uY29sdW1ucy5mbGF0TWFwKGNvbHVtbiA9PiBjb2x1bW4uZ2V0TGVhZkNvbHVtbnMoKSk7XG4gICAgICAgIHJldHVybiBvcmRlckNvbHVtbnMobGVhZkNvbHVtbnMpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIFtjb2x1bW5dO1xuICAgIH0sIHtcbiAgICAgIGtleTogcHJvY2Vzcy5lbnYuTk9ERV9FTlYgPT09ICdwcm9kdWN0aW9uJyAmJiAnY29sdW1uLmdldExlYWZDb2x1bW5zJyxcbiAgICAgIGRlYnVnOiAoKSA9PiB7XG4gICAgICAgIHZhciBfdGFibGUkb3B0aW9ucyRkZWJ1Z0EyO1xuICAgICAgICByZXR1cm4gKF90YWJsZSRvcHRpb25zJGRlYnVnQTIgPSB0YWJsZS5vcHRpb25zLmRlYnVnQWxsKSAhPSBudWxsID8gX3RhYmxlJG9wdGlvbnMkZGVidWdBMiA6IHRhYmxlLm9wdGlvbnMuZGVidWdDb2x1bW5zO1xuICAgICAgfVxuICAgIH0pXG4gIH07XG4gIGZvciAoY29uc3QgZmVhdHVyZSBvZiB0YWJsZS5fZmVhdHVyZXMpIHtcbiAgICBmZWF0dXJlLmNyZWF0ZUNvbHVtbiA9PSBudWxsIHx8IGZlYXR1cmUuY3JlYXRlQ29sdW1uKGNvbHVtbiwgdGFibGUpO1xuICB9XG5cbiAgLy8gWWVzLCB3ZSBoYXZlIHRvIGNvbnZlcnQgdGFibGUgdG8gdWtub3duLCBiZWNhdXNlIHdlIGtub3cgbW9yZSB0aGFuIHRoZSBjb21waWxlciBoZXJlLlxuICByZXR1cm4gY29sdW1uO1xufVxuXG4vL1xuXG5mdW5jdGlvbiBjcmVhdGVIZWFkZXIodGFibGUsIGNvbHVtbiwgb3B0aW9ucykge1xuICB2YXIgX29wdGlvbnMkaWQ7XG4gIGNvbnN0IGlkID0gKF9vcHRpb25zJGlkID0gb3B0aW9ucy5pZCkgIT0gbnVsbCA/IF9vcHRpb25zJGlkIDogY29sdW1uLmlkO1xuICBsZXQgaGVhZGVyID0ge1xuICAgIGlkLFxuICAgIGNvbHVtbixcbiAgICBpbmRleDogb3B0aW9ucy5pbmRleCxcbiAgICBpc1BsYWNlaG9sZGVyOiAhIW9wdGlvbnMuaXNQbGFjZWhvbGRlcixcbiAgICBwbGFjZWhvbGRlcklkOiBvcHRpb25zLnBsYWNlaG9sZGVySWQsXG4gICAgZGVwdGg6IG9wdGlvbnMuZGVwdGgsXG4gICAgc3ViSGVhZGVyczogW10sXG4gICAgY29sU3BhbjogMCxcbiAgICByb3dTcGFuOiAwLFxuICAgIGhlYWRlckdyb3VwOiBudWxsLFxuICAgIGdldExlYWZIZWFkZXJzOiAoKSA9PiB7XG4gICAgICBjb25zdCBsZWFmSGVhZGVycyA9IFtdO1xuICAgICAgY29uc3QgcmVjdXJzZUhlYWRlciA9IGggPT4ge1xuICAgICAgICBpZiAoaC5zdWJIZWFkZXJzICYmIGguc3ViSGVhZGVycy5sZW5ndGgpIHtcbiAgICAgICAgICBoLnN1YkhlYWRlcnMubWFwKHJlY3Vyc2VIZWFkZXIpO1xuICAgICAgICB9XG4gICAgICAgIGxlYWZIZWFkZXJzLnB1c2goaCk7XG4gICAgICB9O1xuICAgICAgcmVjdXJzZUhlYWRlcihoZWFkZXIpO1xuICAgICAgcmV0dXJuIGxlYWZIZWFkZXJzO1xuICAgIH0sXG4gICAgZ2V0Q29udGV4dDogKCkgPT4gKHtcbiAgICAgIHRhYmxlLFxuICAgICAgaGVhZGVyOiBoZWFkZXIsXG4gICAgICBjb2x1bW5cbiAgICB9KVxuICB9O1xuICB0YWJsZS5fZmVhdHVyZXMuZm9yRWFjaChmZWF0dXJlID0+IHtcbiAgICBmZWF0dXJlLmNyZWF0ZUhlYWRlciA9PSBudWxsIHx8IGZlYXR1cmUuY3JlYXRlSGVhZGVyKGhlYWRlciwgdGFibGUpO1xuICB9KTtcbiAgcmV0dXJuIGhlYWRlcjtcbn1cbmNvbnN0IEhlYWRlcnMgPSB7XG4gIGNyZWF0ZVRhYmxlOiB0YWJsZSA9PiB7XG4gICAgLy8gSGVhZGVyIEdyb3Vwc1xuXG4gICAgdGFibGUuZ2V0SGVhZGVyR3JvdXBzID0gbWVtbygoKSA9PiBbdGFibGUuZ2V0QWxsQ29sdW1ucygpLCB0YWJsZS5nZXRWaXNpYmxlTGVhZkNvbHVtbnMoKSwgdGFibGUuZ2V0U3RhdGUoKS5jb2x1bW5QaW5uaW5nLmxlZnQsIHRhYmxlLmdldFN0YXRlKCkuY29sdW1uUGlubmluZy5yaWdodF0sIChhbGxDb2x1bW5zLCBsZWFmQ29sdW1ucywgbGVmdCwgcmlnaHQpID0+IHtcbiAgICAgIHZhciBfbGVmdCRtYXAkZmlsdGVyLCBfcmlnaHQkbWFwJGZpbHRlcjtcbiAgICAgIGNvbnN0IGxlZnRDb2x1bW5zID0gKF9sZWZ0JG1hcCRmaWx0ZXIgPSBsZWZ0ID09IG51bGwgPyB2b2lkIDAgOiBsZWZ0Lm1hcChjb2x1bW5JZCA9PiBsZWFmQ29sdW1ucy5maW5kKGQgPT4gZC5pZCA9PT0gY29sdW1uSWQpKS5maWx0ZXIoQm9vbGVhbikpICE9IG51bGwgPyBfbGVmdCRtYXAkZmlsdGVyIDogW107XG4gICAgICBjb25zdCByaWdodENvbHVtbnMgPSAoX3JpZ2h0JG1hcCRmaWx0ZXIgPSByaWdodCA9PSBudWxsID8gdm9pZCAwIDogcmlnaHQubWFwKGNvbHVtbklkID0+IGxlYWZDb2x1bW5zLmZpbmQoZCA9PiBkLmlkID09PSBjb2x1bW5JZCkpLmZpbHRlcihCb29sZWFuKSkgIT0gbnVsbCA/IF9yaWdodCRtYXAkZmlsdGVyIDogW107XG4gICAgICBjb25zdCBjZW50ZXJDb2x1bW5zID0gbGVhZkNvbHVtbnMuZmlsdGVyKGNvbHVtbiA9PiAhKGxlZnQgIT0gbnVsbCAmJiBsZWZ0LmluY2x1ZGVzKGNvbHVtbi5pZCkpICYmICEocmlnaHQgIT0gbnVsbCAmJiByaWdodC5pbmNsdWRlcyhjb2x1bW4uaWQpKSk7XG4gICAgICBjb25zdCBoZWFkZXJHcm91cHMgPSBidWlsZEhlYWRlckdyb3VwcyhhbGxDb2x1bW5zLCBbLi4ubGVmdENvbHVtbnMsIC4uLmNlbnRlckNvbHVtbnMsIC4uLnJpZ2h0Q29sdW1uc10sIHRhYmxlKTtcbiAgICAgIHJldHVybiBoZWFkZXJHcm91cHM7XG4gICAgfSwge1xuICAgICAga2V5OiBwcm9jZXNzLmVudi5OT0RFX0VOViA9PT0gJ2RldmVsb3BtZW50JyAmJiAnZ2V0SGVhZGVyR3JvdXBzJyxcbiAgICAgIGRlYnVnOiAoKSA9PiB7XG4gICAgICAgIHZhciBfdGFibGUkb3B0aW9ucyRkZWJ1Z0E7XG4gICAgICAgIHJldHVybiAoX3RhYmxlJG9wdGlvbnMkZGVidWdBID0gdGFibGUub3B0aW9ucy5kZWJ1Z0FsbCkgIT0gbnVsbCA/IF90YWJsZSRvcHRpb25zJGRlYnVnQSA6IHRhYmxlLm9wdGlvbnMuZGVidWdIZWFkZXJzO1xuICAgICAgfVxuICAgIH0pO1xuICAgIHRhYmxlLmdldENlbnRlckhlYWRlckdyb3VwcyA9IG1lbW8oKCkgPT4gW3RhYmxlLmdldEFsbENvbHVtbnMoKSwgdGFibGUuZ2V0VmlzaWJsZUxlYWZDb2x1bW5zKCksIHRhYmxlLmdldFN0YXRlKCkuY29sdW1uUGlubmluZy5sZWZ0LCB0YWJsZS5nZXRTdGF0ZSgpLmNvbHVtblBpbm5pbmcucmlnaHRdLCAoYWxsQ29sdW1ucywgbGVhZkNvbHVtbnMsIGxlZnQsIHJpZ2h0KSA9PiB7XG4gICAgICBsZWFmQ29sdW1ucyA9IGxlYWZDb2x1bW5zLmZpbHRlcihjb2x1bW4gPT4gIShsZWZ0ICE9IG51bGwgJiYgbGVmdC5pbmNsdWRlcyhjb2x1bW4uaWQpKSAmJiAhKHJpZ2h0ICE9IG51bGwgJiYgcmlnaHQuaW5jbHVkZXMoY29sdW1uLmlkKSkpO1xuICAgICAgcmV0dXJuIGJ1aWxkSGVhZGVyR3JvdXBzKGFsbENvbHVtbnMsIGxlYWZDb2x1bW5zLCB0YWJsZSwgJ2NlbnRlcicpO1xuICAgIH0sIHtcbiAgICAgIGtleTogcHJvY2Vzcy5lbnYuTk9ERV9FTlYgPT09ICdkZXZlbG9wbWVudCcgJiYgJ2dldENlbnRlckhlYWRlckdyb3VwcycsXG4gICAgICBkZWJ1ZzogKCkgPT4ge1xuICAgICAgICB2YXIgX3RhYmxlJG9wdGlvbnMkZGVidWdBMjtcbiAgICAgICAgcmV0dXJuIChfdGFibGUkb3B0aW9ucyRkZWJ1Z0EyID0gdGFibGUub3B0aW9ucy5kZWJ1Z0FsbCkgIT0gbnVsbCA/IF90YWJsZSRvcHRpb25zJGRlYnVnQTIgOiB0YWJsZS5vcHRpb25zLmRlYnVnSGVhZGVycztcbiAgICAgIH1cbiAgICB9KTtcbiAgICB0YWJsZS5nZXRMZWZ0SGVhZGVyR3JvdXBzID0gbWVtbygoKSA9PiBbdGFibGUuZ2V0QWxsQ29sdW1ucygpLCB0YWJsZS5nZXRWaXNpYmxlTGVhZkNvbHVtbnMoKSwgdGFibGUuZ2V0U3RhdGUoKS5jb2x1bW5QaW5uaW5nLmxlZnRdLCAoYWxsQ29sdW1ucywgbGVhZkNvbHVtbnMsIGxlZnQpID0+IHtcbiAgICAgIHZhciBfbGVmdCRtYXAkZmlsdGVyMjtcbiAgICAgIGNvbnN0IG9yZGVyZWRMZWFmQ29sdW1ucyA9IChfbGVmdCRtYXAkZmlsdGVyMiA9IGxlZnQgPT0gbnVsbCA/IHZvaWQgMCA6IGxlZnQubWFwKGNvbHVtbklkID0+IGxlYWZDb2x1bW5zLmZpbmQoZCA9PiBkLmlkID09PSBjb2x1bW5JZCkpLmZpbHRlcihCb29sZWFuKSkgIT0gbnVsbCA/IF9sZWZ0JG1hcCRmaWx0ZXIyIDogW107XG4gICAgICByZXR1cm4gYnVpbGRIZWFkZXJHcm91cHMoYWxsQ29sdW1ucywgb3JkZXJlZExlYWZDb2x1bW5zLCB0YWJsZSwgJ2xlZnQnKTtcbiAgICB9LCB7XG4gICAgICBrZXk6IHByb2Nlc3MuZW52Lk5PREVfRU5WID09PSAnZGV2ZWxvcG1lbnQnICYmICdnZXRMZWZ0SGVhZGVyR3JvdXBzJyxcbiAgICAgIGRlYnVnOiAoKSA9PiB7XG4gICAgICAgIHZhciBfdGFibGUkb3B0aW9ucyRkZWJ1Z0EzO1xuICAgICAgICByZXR1cm4gKF90YWJsZSRvcHRpb25zJGRlYnVnQTMgPSB0YWJsZS5vcHRpb25zLmRlYnVnQWxsKSAhPSBudWxsID8gX3RhYmxlJG9wdGlvbnMkZGVidWdBMyA6IHRhYmxlLm9wdGlvbnMuZGVidWdIZWFkZXJzO1xuICAgICAgfVxuICAgIH0pO1xuICAgIHRhYmxlLmdldFJpZ2h0SGVhZGVyR3JvdXBzID0gbWVtbygoKSA9PiBbdGFibGUuZ2V0QWxsQ29sdW1ucygpLCB0YWJsZS5nZXRWaXNpYmxlTGVhZkNvbHVtbnMoKSwgdGFibGUuZ2V0U3RhdGUoKS5jb2x1bW5QaW5uaW5nLnJpZ2h0XSwgKGFsbENvbHVtbnMsIGxlYWZDb2x1bW5zLCByaWdodCkgPT4ge1xuICAgICAgdmFyIF9yaWdodCRtYXAkZmlsdGVyMjtcbiAgICAgIGNvbnN0IG9yZGVyZWRMZWFmQ29sdW1ucyA9IChfcmlnaHQkbWFwJGZpbHRlcjIgPSByaWdodCA9PSBudWxsID8gdm9pZCAwIDogcmlnaHQubWFwKGNvbHVtbklkID0+IGxlYWZDb2x1bW5zLmZpbmQoZCA9PiBkLmlkID09PSBjb2x1bW5JZCkpLmZpbHRlcihCb29sZWFuKSkgIT0gbnVsbCA/IF9yaWdodCRtYXAkZmlsdGVyMiA6IFtdO1xuICAgICAgcmV0dXJuIGJ1aWxkSGVhZGVyR3JvdXBzKGFsbENvbHVtbnMsIG9yZGVyZWRMZWFmQ29sdW1ucywgdGFibGUsICdyaWdodCcpO1xuICAgIH0sIHtcbiAgICAgIGtleTogcHJvY2Vzcy5lbnYuTk9ERV9FTlYgPT09ICdkZXZlbG9wbWVudCcgJiYgJ2dldFJpZ2h0SGVhZGVyR3JvdXBzJyxcbiAgICAgIGRlYnVnOiAoKSA9PiB7XG4gICAgICAgIHZhciBfdGFibGUkb3B0aW9ucyRkZWJ1Z0E0O1xuICAgICAgICByZXR1cm4gKF90YWJsZSRvcHRpb25zJGRlYnVnQTQgPSB0YWJsZS5vcHRpb25zLmRlYnVnQWxsKSAhPSBudWxsID8gX3RhYmxlJG9wdGlvbnMkZGVidWdBNCA6IHRhYmxlLm9wdGlvbnMuZGVidWdIZWFkZXJzO1xuICAgICAgfVxuICAgIH0pO1xuXG4gICAgLy8gRm9vdGVyIEdyb3Vwc1xuXG4gICAgdGFibGUuZ2V0Rm9vdGVyR3JvdXBzID0gbWVtbygoKSA9PiBbdGFibGUuZ2V0SGVhZGVyR3JvdXBzKCldLCBoZWFkZXJHcm91cHMgPT4ge1xuICAgICAgcmV0dXJuIFsuLi5oZWFkZXJHcm91cHNdLnJldmVyc2UoKTtcbiAgICB9LCB7XG4gICAgICBrZXk6IHByb2Nlc3MuZW52Lk5PREVfRU5WID09PSAnZGV2ZWxvcG1lbnQnICYmICdnZXRGb290ZXJHcm91cHMnLFxuICAgICAgZGVidWc6ICgpID0+IHtcbiAgICAgICAgdmFyIF90YWJsZSRvcHRpb25zJGRlYnVnQTU7XG4gICAgICAgIHJldHVybiAoX3RhYmxlJG9wdGlvbnMkZGVidWdBNSA9IHRhYmxlLm9wdGlvbnMuZGVidWdBbGwpICE9IG51bGwgPyBfdGFibGUkb3B0aW9ucyRkZWJ1Z0E1IDogdGFibGUub3B0aW9ucy5kZWJ1Z0hlYWRlcnM7XG4gICAgICB9XG4gICAgfSk7XG4gICAgdGFibGUuZ2V0TGVmdEZvb3Rlckdyb3VwcyA9IG1lbW8oKCkgPT4gW3RhYmxlLmdldExlZnRIZWFkZXJHcm91cHMoKV0sIGhlYWRlckdyb3VwcyA9PiB7XG4gICAgICByZXR1cm4gWy4uLmhlYWRlckdyb3Vwc10ucmV2ZXJzZSgpO1xuICAgIH0sIHtcbiAgICAgIGtleTogcHJvY2Vzcy5lbnYuTk9ERV9FTlYgPT09ICdkZXZlbG9wbWVudCcgJiYgJ2dldExlZnRGb290ZXJHcm91cHMnLFxuICAgICAgZGVidWc6ICgpID0+IHtcbiAgICAgICAgdmFyIF90YWJsZSRvcHRpb25zJGRlYnVnQTY7XG4gICAgICAgIHJldHVybiAoX3RhYmxlJG9wdGlvbnMkZGVidWdBNiA9IHRhYmxlLm9wdGlvbnMuZGVidWdBbGwpICE9IG51bGwgPyBfdGFibGUkb3B0aW9ucyRkZWJ1Z0E2IDogdGFibGUub3B0aW9ucy5kZWJ1Z0hlYWRlcnM7XG4gICAgICB9XG4gICAgfSk7XG4gICAgdGFibGUuZ2V0Q2VudGVyRm9vdGVyR3JvdXBzID0gbWVtbygoKSA9PiBbdGFibGUuZ2V0Q2VudGVySGVhZGVyR3JvdXBzKCldLCBoZWFkZXJHcm91cHMgPT4ge1xuICAgICAgcmV0dXJuIFsuLi5oZWFkZXJHcm91cHNdLnJldmVyc2UoKTtcbiAgICB9LCB7XG4gICAgICBrZXk6IHByb2Nlc3MuZW52Lk5PREVfRU5WID09PSAnZGV2ZWxvcG1lbnQnICYmICdnZXRDZW50ZXJGb290ZXJHcm91cHMnLFxuICAgICAgZGVidWc6ICgpID0+IHtcbiAgICAgICAgdmFyIF90YWJsZSRvcHRpb25zJGRlYnVnQTc7XG4gICAgICAgIHJldHVybiAoX3RhYmxlJG9wdGlvbnMkZGVidWdBNyA9IHRhYmxlLm9wdGlvbnMuZGVidWdBbGwpICE9IG51bGwgPyBfdGFibGUkb3B0aW9ucyRkZWJ1Z0E3IDogdGFibGUub3B0aW9ucy5kZWJ1Z0hlYWRlcnM7XG4gICAgICB9XG4gICAgfSk7XG4gICAgdGFibGUuZ2V0UmlnaHRGb290ZXJHcm91cHMgPSBtZW1vKCgpID0+IFt0YWJsZS5nZXRSaWdodEhlYWRlckdyb3VwcygpXSwgaGVhZGVyR3JvdXBzID0+IHtcbiAgICAgIHJldHVybiBbLi4uaGVhZGVyR3JvdXBzXS5yZXZlcnNlKCk7XG4gICAgfSwge1xuICAgICAga2V5OiBwcm9jZXNzLmVudi5OT0RFX0VOViA9PT0gJ2RldmVsb3BtZW50JyAmJiAnZ2V0UmlnaHRGb290ZXJHcm91cHMnLFxuICAgICAgZGVidWc6ICgpID0+IHtcbiAgICAgICAgdmFyIF90YWJsZSRvcHRpb25zJGRlYnVnQTg7XG4gICAgICAgIHJldHVybiAoX3RhYmxlJG9wdGlvbnMkZGVidWdBOCA9IHRhYmxlLm9wdGlvbnMuZGVidWdBbGwpICE9IG51bGwgPyBfdGFibGUkb3B0aW9ucyRkZWJ1Z0E4IDogdGFibGUub3B0aW9ucy5kZWJ1Z0hlYWRlcnM7XG4gICAgICB9XG4gICAgfSk7XG5cbiAgICAvLyBGbGF0IEhlYWRlcnNcblxuICAgIHRhYmxlLmdldEZsYXRIZWFkZXJzID0gbWVtbygoKSA9PiBbdGFibGUuZ2V0SGVhZGVyR3JvdXBzKCldLCBoZWFkZXJHcm91cHMgPT4ge1xuICAgICAgcmV0dXJuIGhlYWRlckdyb3Vwcy5tYXAoaGVhZGVyR3JvdXAgPT4ge1xuICAgICAgICByZXR1cm4gaGVhZGVyR3JvdXAuaGVhZGVycztcbiAgICAgIH0pLmZsYXQoKTtcbiAgICB9LCB7XG4gICAgICBrZXk6IHByb2Nlc3MuZW52Lk5PREVfRU5WID09PSAnZGV2ZWxvcG1lbnQnICYmICdnZXRGbGF0SGVhZGVycycsXG4gICAgICBkZWJ1ZzogKCkgPT4ge1xuICAgICAgICB2YXIgX3RhYmxlJG9wdGlvbnMkZGVidWdBOTtcbiAgICAgICAgcmV0dXJuIChfdGFibGUkb3B0aW9ucyRkZWJ1Z0E5ID0gdGFibGUub3B0aW9ucy5kZWJ1Z0FsbCkgIT0gbnVsbCA/IF90YWJsZSRvcHRpb25zJGRlYnVnQTkgOiB0YWJsZS5vcHRpb25zLmRlYnVnSGVhZGVycztcbiAgICAgIH1cbiAgICB9KTtcbiAgICB0YWJsZS5nZXRMZWZ0RmxhdEhlYWRlcnMgPSBtZW1vKCgpID0+IFt0YWJsZS5nZXRMZWZ0SGVhZGVyR3JvdXBzKCldLCBsZWZ0ID0+IHtcbiAgICAgIHJldHVybiBsZWZ0Lm1hcChoZWFkZXJHcm91cCA9PiB7XG4gICAgICAgIHJldHVybiBoZWFkZXJHcm91cC5oZWFkZXJzO1xuICAgICAgfSkuZmxhdCgpO1xuICAgIH0sIHtcbiAgICAgIGtleTogcHJvY2Vzcy5lbnYuTk9ERV9FTlYgPT09ICdkZXZlbG9wbWVudCcgJiYgJ2dldExlZnRGbGF0SGVhZGVycycsXG4gICAgICBkZWJ1ZzogKCkgPT4ge1xuICAgICAgICB2YXIgX3RhYmxlJG9wdGlvbnMkZGVidWdBMTA7XG4gICAgICAgIHJldHVybiAoX3RhYmxlJG9wdGlvbnMkZGVidWdBMTAgPSB0YWJsZS5vcHRpb25zLmRlYnVnQWxsKSAhPSBudWxsID8gX3RhYmxlJG9wdGlvbnMkZGVidWdBMTAgOiB0YWJsZS5vcHRpb25zLmRlYnVnSGVhZGVycztcbiAgICAgIH1cbiAgICB9KTtcbiAgICB0YWJsZS5nZXRDZW50ZXJGbGF0SGVhZGVycyA9IG1lbW8oKCkgPT4gW3RhYmxlLmdldENlbnRlckhlYWRlckdyb3VwcygpXSwgbGVmdCA9PiB7XG4gICAgICByZXR1cm4gbGVmdC5tYXAoaGVhZGVyR3JvdXAgPT4ge1xuICAgICAgICByZXR1cm4gaGVhZGVyR3JvdXAuaGVhZGVycztcbiAgICAgIH0pLmZsYXQoKTtcbiAgICB9LCB7XG4gICAgICBrZXk6IHByb2Nlc3MuZW52Lk5PREVfRU5WID09PSAnZGV2ZWxvcG1lbnQnICYmICdnZXRDZW50ZXJGbGF0SGVhZGVycycsXG4gICAgICBkZWJ1ZzogKCkgPT4ge1xuICAgICAgICB2YXIgX3RhYmxlJG9wdGlvbnMkZGVidWdBMTE7XG4gICAgICAgIHJldHVybiAoX3RhYmxlJG9wdGlvbnMkZGVidWdBMTEgPSB0YWJsZS5vcHRpb25zLmRlYnVnQWxsKSAhPSBudWxsID8gX3RhYmxlJG9wdGlvbnMkZGVidWdBMTEgOiB0YWJsZS5vcHRpb25zLmRlYnVnSGVhZGVycztcbiAgICAgIH1cbiAgICB9KTtcbiAgICB0YWJsZS5nZXRSaWdodEZsYXRIZWFkZXJzID0gbWVtbygoKSA9PiBbdGFibGUuZ2V0UmlnaHRIZWFkZXJHcm91cHMoKV0sIGxlZnQgPT4ge1xuICAgICAgcmV0dXJuIGxlZnQubWFwKGhlYWRlckdyb3VwID0+IHtcbiAgICAgICAgcmV0dXJuIGhlYWRlckdyb3VwLmhlYWRlcnM7XG4gICAgICB9KS5mbGF0KCk7XG4gICAgfSwge1xuICAgICAga2V5OiBwcm9jZXNzLmVudi5OT0RFX0VOViA9PT0gJ2RldmVsb3BtZW50JyAmJiAnZ2V0UmlnaHRGbGF0SGVhZGVycycsXG4gICAgICBkZWJ1ZzogKCkgPT4ge1xuICAgICAgICB2YXIgX3RhYmxlJG9wdGlvbnMkZGVidWdBMTI7XG4gICAgICAgIHJldHVybiAoX3RhYmxlJG9wdGlvbnMkZGVidWdBMTIgPSB0YWJsZS5vcHRpb25zLmRlYnVnQWxsKSAhPSBudWxsID8gX3RhYmxlJG9wdGlvbnMkZGVidWdBMTIgOiB0YWJsZS5vcHRpb25zLmRlYnVnSGVhZGVycztcbiAgICAgIH1cbiAgICB9KTtcblxuICAgIC8vIExlYWYgSGVhZGVyc1xuXG4gICAgdGFibGUuZ2V0Q2VudGVyTGVhZkhlYWRlcnMgPSBtZW1vKCgpID0+IFt0YWJsZS5nZXRDZW50ZXJGbGF0SGVhZGVycygpXSwgZmxhdEhlYWRlcnMgPT4ge1xuICAgICAgcmV0dXJuIGZsYXRIZWFkZXJzLmZpbHRlcihoZWFkZXIgPT4ge1xuICAgICAgICB2YXIgX2hlYWRlciRzdWJIZWFkZXJzO1xuICAgICAgICByZXR1cm4gISgoX2hlYWRlciRzdWJIZWFkZXJzID0gaGVhZGVyLnN1YkhlYWRlcnMpICE9IG51bGwgJiYgX2hlYWRlciRzdWJIZWFkZXJzLmxlbmd0aCk7XG4gICAgICB9KTtcbiAgICB9LCB7XG4gICAgICBrZXk6IHByb2Nlc3MuZW52Lk5PREVfRU5WID09PSAnZGV2ZWxvcG1lbnQnICYmICdnZXRDZW50ZXJMZWFmSGVhZGVycycsXG4gICAgICBkZWJ1ZzogKCkgPT4ge1xuICAgICAgICB2YXIgX3RhYmxlJG9wdGlvbnMkZGVidWdBMTM7XG4gICAgICAgIHJldHVybiAoX3RhYmxlJG9wdGlvbnMkZGVidWdBMTMgPSB0YWJsZS5vcHRpb25zLmRlYnVnQWxsKSAhPSBudWxsID8gX3RhYmxlJG9wdGlvbnMkZGVidWdBMTMgOiB0YWJsZS5vcHRpb25zLmRlYnVnSGVhZGVycztcbiAgICAgIH1cbiAgICB9KTtcbiAgICB0YWJsZS5nZXRMZWZ0TGVhZkhlYWRlcnMgPSBtZW1vKCgpID0+IFt0YWJsZS5nZXRMZWZ0RmxhdEhlYWRlcnMoKV0sIGZsYXRIZWFkZXJzID0+IHtcbiAgICAgIHJldHVybiBmbGF0SGVhZGVycy5maWx0ZXIoaGVhZGVyID0+IHtcbiAgICAgICAgdmFyIF9oZWFkZXIkc3ViSGVhZGVyczI7XG4gICAgICAgIHJldHVybiAhKChfaGVhZGVyJHN1YkhlYWRlcnMyID0gaGVhZGVyLnN1YkhlYWRlcnMpICE9IG51bGwgJiYgX2hlYWRlciRzdWJIZWFkZXJzMi5sZW5ndGgpO1xuICAgICAgfSk7XG4gICAgfSwge1xuICAgICAga2V5OiBwcm9jZXNzLmVudi5OT0RFX0VOViA9PT0gJ2RldmVsb3BtZW50JyAmJiAnZ2V0TGVmdExlYWZIZWFkZXJzJyxcbiAgICAgIGRlYnVnOiAoKSA9PiB7XG4gICAgICAgIHZhciBfdGFibGUkb3B0aW9ucyRkZWJ1Z0ExNDtcbiAgICAgICAgcmV0dXJuIChfdGFibGUkb3B0aW9ucyRkZWJ1Z0ExNCA9IHRhYmxlLm9wdGlvbnMuZGVidWdBbGwpICE9IG51bGwgPyBfdGFibGUkb3B0aW9ucyRkZWJ1Z0ExNCA6IHRhYmxlLm9wdGlvbnMuZGVidWdIZWFkZXJzO1xuICAgICAgfVxuICAgIH0pO1xuICAgIHRhYmxlLmdldFJpZ2h0TGVhZkhlYWRlcnMgPSBtZW1vKCgpID0+IFt0YWJsZS5nZXRSaWdodEZsYXRIZWFkZXJzKCldLCBmbGF0SGVhZGVycyA9PiB7XG4gICAgICByZXR1cm4gZmxhdEhlYWRlcnMuZmlsdGVyKGhlYWRlciA9PiB7XG4gICAgICAgIHZhciBfaGVhZGVyJHN1YkhlYWRlcnMzO1xuICAgICAgICByZXR1cm4gISgoX2hlYWRlciRzdWJIZWFkZXJzMyA9IGhlYWRlci5zdWJIZWFkZXJzKSAhPSBudWxsICYmIF9oZWFkZXIkc3ViSGVhZGVyczMubGVuZ3RoKTtcbiAgICAgIH0pO1xuICAgIH0sIHtcbiAgICAgIGtleTogcHJvY2Vzcy5lbnYuTk9ERV9FTlYgPT09ICdkZXZlbG9wbWVudCcgJiYgJ2dldFJpZ2h0TGVhZkhlYWRlcnMnLFxuICAgICAgZGVidWc6ICgpID0+IHtcbiAgICAgICAgdmFyIF90YWJsZSRvcHRpb25zJGRlYnVnQTE1O1xuICAgICAgICByZXR1cm4gKF90YWJsZSRvcHRpb25zJGRlYnVnQTE1ID0gdGFibGUub3B0aW9ucy5kZWJ1Z0FsbCkgIT0gbnVsbCA/IF90YWJsZSRvcHRpb25zJGRlYnVnQTE1IDogdGFibGUub3B0aW9ucy5kZWJ1Z0hlYWRlcnM7XG4gICAgICB9XG4gICAgfSk7XG4gICAgdGFibGUuZ2V0TGVhZkhlYWRlcnMgPSBtZW1vKCgpID0+IFt0YWJsZS5nZXRMZWZ0SGVhZGVyR3JvdXBzKCksIHRhYmxlLmdldENlbnRlckhlYWRlckdyb3VwcygpLCB0YWJsZS5nZXRSaWdodEhlYWRlckdyb3VwcygpXSwgKGxlZnQsIGNlbnRlciwgcmlnaHQpID0+IHtcbiAgICAgIHZhciBfbGVmdCQwJGhlYWRlcnMsIF9sZWZ0JCwgX2NlbnRlciQwJGhlYWRlcnMsIF9jZW50ZXIkLCBfcmlnaHQkMCRoZWFkZXJzLCBfcmlnaHQkO1xuICAgICAgcmV0dXJuIFsuLi4oKF9sZWZ0JDAkaGVhZGVycyA9IChfbGVmdCQgPSBsZWZ0WzBdKSA9PSBudWxsID8gdm9pZCAwIDogX2xlZnQkLmhlYWRlcnMpICE9IG51bGwgPyBfbGVmdCQwJGhlYWRlcnMgOiBbXSksIC4uLigoX2NlbnRlciQwJGhlYWRlcnMgPSAoX2NlbnRlciQgPSBjZW50ZXJbMF0pID09IG51bGwgPyB2b2lkIDAgOiBfY2VudGVyJC5oZWFkZXJzKSAhPSBudWxsID8gX2NlbnRlciQwJGhlYWRlcnMgOiBbXSksIC4uLigoX3JpZ2h0JDAkaGVhZGVycyA9IChfcmlnaHQkID0gcmlnaHRbMF0pID09IG51bGwgPyB2b2lkIDAgOiBfcmlnaHQkLmhlYWRlcnMpICE9IG51bGwgPyBfcmlnaHQkMCRoZWFkZXJzIDogW10pXS5tYXAoaGVhZGVyID0+IHtcbiAgICAgICAgcmV0dXJuIGhlYWRlci5nZXRMZWFmSGVhZGVycygpO1xuICAgICAgfSkuZmxhdCgpO1xuICAgIH0sIHtcbiAgICAgIGtleTogcHJvY2Vzcy5lbnYuTk9ERV9FTlYgPT09ICdkZXZlbG9wbWVudCcgJiYgJ2dldExlYWZIZWFkZXJzJyxcbiAgICAgIGRlYnVnOiAoKSA9PiB7XG4gICAgICAgIHZhciBfdGFibGUkb3B0aW9ucyRkZWJ1Z0ExNjtcbiAgICAgICAgcmV0dXJuIChfdGFibGUkb3B0aW9ucyRkZWJ1Z0ExNiA9IHRhYmxlLm9wdGlvbnMuZGVidWdBbGwpICE9IG51bGwgPyBfdGFibGUkb3B0aW9ucyRkZWJ1Z0ExNiA6IHRhYmxlLm9wdGlvbnMuZGVidWdIZWFkZXJzO1xuICAgICAgfVxuICAgIH0pO1xuICB9XG59O1xuZnVuY3Rpb24gYnVpbGRIZWFkZXJHcm91cHMoYWxsQ29sdW1ucywgY29sdW1uc1RvR3JvdXAsIHRhYmxlLCBoZWFkZXJGYW1pbHkpIHtcbiAgdmFyIF9oZWFkZXJHcm91cHMkMCRoZWFkZSwgX2hlYWRlckdyb3VwcyQ7XG4gIC8vIEZpbmQgdGhlIG1heCBkZXB0aCBvZiB0aGUgY29sdW1uczpcbiAgLy8gYnVpbGQgdGhlIGxlYWYgY29sdW1uIHJvd1xuICAvLyBidWlsZCBlYWNoIGJ1ZmZlciByb3cgZ29pbmcgdXBcbiAgLy8gICAgcGxhY2Vob2xkZXIgZm9yIG5vbi1leGlzdGVudCBsZXZlbFxuICAvLyAgICByZWFsIGNvbHVtbiBmb3IgZXhpc3RpbmcgbGV2ZWxcblxuICBsZXQgbWF4RGVwdGggPSAwO1xuICBjb25zdCBmaW5kTWF4RGVwdGggPSBmdW5jdGlvbiAoY29sdW1ucywgZGVwdGgpIHtcbiAgICBpZiAoZGVwdGggPT09IHZvaWQgMCkge1xuICAgICAgZGVwdGggPSAxO1xuICAgIH1cbiAgICBtYXhEZXB0aCA9IE1hdGgubWF4KG1heERlcHRoLCBkZXB0aCk7XG4gICAgY29sdW1ucy5maWx0ZXIoY29sdW1uID0+IGNvbHVtbi5nZXRJc1Zpc2libGUoKSkuZm9yRWFjaChjb2x1bW4gPT4ge1xuICAgICAgdmFyIF9jb2x1bW4kY29sdW1ucztcbiAgICAgIGlmICgoX2NvbHVtbiRjb2x1bW5zID0gY29sdW1uLmNvbHVtbnMpICE9IG51bGwgJiYgX2NvbHVtbiRjb2x1bW5zLmxlbmd0aCkge1xuICAgICAgICBmaW5kTWF4RGVwdGgoY29sdW1uLmNvbHVtbnMsIGRlcHRoICsgMSk7XG4gICAgICB9XG4gICAgfSwgMCk7XG4gIH07XG4gIGZpbmRNYXhEZXB0aChhbGxDb2x1bW5zKTtcbiAgbGV0IGhlYWRlckdyb3VwcyA9IFtdO1xuICBjb25zdCBjcmVhdGVIZWFkZXJHcm91cCA9IChoZWFkZXJzVG9Hcm91cCwgZGVwdGgpID0+IHtcbiAgICAvLyBUaGUgaGVhZGVyIGdyb3VwIHdlIGFyZSBjcmVhdGluZ1xuICAgIGNvbnN0IGhlYWRlckdyb3VwID0ge1xuICAgICAgZGVwdGgsXG4gICAgICBpZDogW2hlYWRlckZhbWlseSwgYCR7ZGVwdGh9YF0uZmlsdGVyKEJvb2xlYW4pLmpvaW4oJ18nKSxcbiAgICAgIGhlYWRlcnM6IFtdXG4gICAgfTtcblxuICAgIC8vIFRoZSBwYXJlbnQgY29sdW1ucyB3ZSdyZSBnb2luZyB0byBzY2FuIG5leHRcbiAgICBjb25zdCBwZW5kaW5nUGFyZW50SGVhZGVycyA9IFtdO1xuXG4gICAgLy8gU2NhbiBlYWNoIGNvbHVtbiBmb3IgcGFyZW50c1xuICAgIGhlYWRlcnNUb0dyb3VwLmZvckVhY2goaGVhZGVyVG9Hcm91cCA9PiB7XG4gICAgICAvLyBXaGF0IGlzIHRoZSBsYXRlc3QgKGxhc3QpIHBhcmVudCBjb2x1bW4/XG5cbiAgICAgIGNvbnN0IGxhdGVzdFBlbmRpbmdQYXJlbnRIZWFkZXIgPSBbLi4ucGVuZGluZ1BhcmVudEhlYWRlcnNdLnJldmVyc2UoKVswXTtcbiAgICAgIGNvbnN0IGlzTGVhZkhlYWRlciA9IGhlYWRlclRvR3JvdXAuY29sdW1uLmRlcHRoID09PSBoZWFkZXJHcm91cC5kZXB0aDtcbiAgICAgIGxldCBjb2x1bW47XG4gICAgICBsZXQgaXNQbGFjZWhvbGRlciA9IGZhbHNlO1xuICAgICAgaWYgKGlzTGVhZkhlYWRlciAmJiBoZWFkZXJUb0dyb3VwLmNvbHVtbi5wYXJlbnQpIHtcbiAgICAgICAgLy8gVGhlIHBhcmVudCBoZWFkZXIgaXMgbmV3XG4gICAgICAgIGNvbHVtbiA9IGhlYWRlclRvR3JvdXAuY29sdW1uLnBhcmVudDtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIC8vIFRoZSBwYXJlbnQgaGVhZGVyIGlzIHJlcGVhdGVkXG4gICAgICAgIGNvbHVtbiA9IGhlYWRlclRvR3JvdXAuY29sdW1uO1xuICAgICAgICBpc1BsYWNlaG9sZGVyID0gdHJ1ZTtcbiAgICAgIH1cbiAgICAgIGlmIChsYXRlc3RQZW5kaW5nUGFyZW50SGVhZGVyICYmIChsYXRlc3RQZW5kaW5nUGFyZW50SGVhZGVyID09IG51bGwgPyB2b2lkIDAgOiBsYXRlc3RQZW5kaW5nUGFyZW50SGVhZGVyLmNvbHVtbikgPT09IGNvbHVtbikge1xuICAgICAgICAvLyBUaGlzIGNvbHVtbiBpcyByZXBlYXRlZC4gQWRkIGl0IGFzIGEgc3ViIGhlYWRlciB0byB0aGUgbmV4dCBiYXRjaFxuICAgICAgICBsYXRlc3RQZW5kaW5nUGFyZW50SGVhZGVyLnN1YkhlYWRlcnMucHVzaChoZWFkZXJUb0dyb3VwKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIC8vIFRoaXMgaXMgYSBuZXcgaGVhZGVyLiBMZXQncyBjcmVhdGUgaXRcbiAgICAgICAgY29uc3QgaGVhZGVyID0gY3JlYXRlSGVhZGVyKHRhYmxlLCBjb2x1bW4sIHtcbiAgICAgICAgICBpZDogW2hlYWRlckZhbWlseSwgZGVwdGgsIGNvbHVtbi5pZCwgaGVhZGVyVG9Hcm91cCA9PSBudWxsID8gdm9pZCAwIDogaGVhZGVyVG9Hcm91cC5pZF0uZmlsdGVyKEJvb2xlYW4pLmpvaW4oJ18nKSxcbiAgICAgICAgICBpc1BsYWNlaG9sZGVyLFxuICAgICAgICAgIHBsYWNlaG9sZGVySWQ6IGlzUGxhY2Vob2xkZXIgPyBgJHtwZW5kaW5nUGFyZW50SGVhZGVycy5maWx0ZXIoZCA9PiBkLmNvbHVtbiA9PT0gY29sdW1uKS5sZW5ndGh9YCA6IHVuZGVmaW5lZCxcbiAgICAgICAgICBkZXB0aCxcbiAgICAgICAgICBpbmRleDogcGVuZGluZ1BhcmVudEhlYWRlcnMubGVuZ3RoXG4gICAgICAgIH0pO1xuXG4gICAgICAgIC8vIEFkZCB0aGUgaGVhZGVyVG9Hcm91cCBhcyBhIHN1YkhlYWRlciBvZiB0aGUgbmV3IGhlYWRlclxuICAgICAgICBoZWFkZXIuc3ViSGVhZGVycy5wdXNoKGhlYWRlclRvR3JvdXApO1xuICAgICAgICAvLyBBZGQgdGhlIG5ldyBoZWFkZXIgdG8gdGhlIHBlbmRpbmdQYXJlbnRIZWFkZXJzIHRvIGdldCBncm91cGVkXG4gICAgICAgIC8vIGluIHRoZSBuZXh0IGJhdGNoXG4gICAgICAgIHBlbmRpbmdQYXJlbnRIZWFkZXJzLnB1c2goaGVhZGVyKTtcbiAgICAgIH1cbiAgICAgIGhlYWRlckdyb3VwLmhlYWRlcnMucHVzaChoZWFkZXJUb0dyb3VwKTtcbiAgICAgIGhlYWRlclRvR3JvdXAuaGVhZGVyR3JvdXAgPSBoZWFkZXJHcm91cDtcbiAgICB9KTtcbiAgICBoZWFkZXJHcm91cHMucHVzaChoZWFkZXJHcm91cCk7XG4gICAgaWYgKGRlcHRoID4gMCkge1xuICAgICAgY3JlYXRlSGVhZGVyR3JvdXAocGVuZGluZ1BhcmVudEhlYWRlcnMsIGRlcHRoIC0gMSk7XG4gICAgfVxuICB9O1xuICBjb25zdCBib3R0b21IZWFkZXJzID0gY29sdW1uc1RvR3JvdXAubWFwKChjb2x1bW4sIGluZGV4KSA9PiBjcmVhdGVIZWFkZXIodGFibGUsIGNvbHVtbiwge1xuICAgIGRlcHRoOiBtYXhEZXB0aCxcbiAgICBpbmRleFxuICB9KSk7XG4gIGNyZWF0ZUhlYWRlckdyb3VwKGJvdHRvbUhlYWRlcnMsIG1heERlcHRoIC0gMSk7XG4gIGhlYWRlckdyb3Vwcy5yZXZlcnNlKCk7XG5cbiAgLy8gaGVhZGVyR3JvdXBzID0gaGVhZGVyR3JvdXBzLmZpbHRlcihoZWFkZXJHcm91cCA9PiB7XG4gIC8vICAgcmV0dXJuICFoZWFkZXJHcm91cC5oZWFkZXJzLmV2ZXJ5KGhlYWRlciA9PiBoZWFkZXIuaXNQbGFjZWhvbGRlcilcbiAgLy8gfSlcblxuICBjb25zdCByZWN1cnNlSGVhZGVyc0ZvclNwYW5zID0gaGVhZGVycyA9PiB7XG4gICAgY29uc3QgZmlsdGVyZWRIZWFkZXJzID0gaGVhZGVycy5maWx0ZXIoaGVhZGVyID0+IGhlYWRlci5jb2x1bW4uZ2V0SXNWaXNpYmxlKCkpO1xuICAgIHJldHVybiBmaWx0ZXJlZEhlYWRlcnMubWFwKGhlYWRlciA9PiB7XG4gICAgICBsZXQgY29sU3BhbiA9IDA7XG4gICAgICBsZXQgcm93U3BhbiA9IDA7XG4gICAgICBsZXQgY2hpbGRSb3dTcGFucyA9IFswXTtcbiAgICAgIGlmIChoZWFkZXIuc3ViSGVhZGVycyAmJiBoZWFkZXIuc3ViSGVhZGVycy5sZW5ndGgpIHtcbiAgICAgICAgY2hpbGRSb3dTcGFucyA9IFtdO1xuICAgICAgICByZWN1cnNlSGVhZGVyc0ZvclNwYW5zKGhlYWRlci5zdWJIZWFkZXJzKS5mb3JFYWNoKF9yZWYgPT4ge1xuICAgICAgICAgIGxldCB7XG4gICAgICAgICAgICBjb2xTcGFuOiBjaGlsZENvbFNwYW4sXG4gICAgICAgICAgICByb3dTcGFuOiBjaGlsZFJvd1NwYW5cbiAgICAgICAgICB9ID0gX3JlZjtcbiAgICAgICAgICBjb2xTcGFuICs9IGNoaWxkQ29sU3BhbjtcbiAgICAgICAgICBjaGlsZFJvd1NwYW5zLnB1c2goY2hpbGRSb3dTcGFuKTtcbiAgICAgICAgfSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBjb2xTcGFuID0gMTtcbiAgICAgIH1cbiAgICAgIGNvbnN0IG1pbkNoaWxkUm93U3BhbiA9IE1hdGgubWluKC4uLmNoaWxkUm93U3BhbnMpO1xuICAgICAgcm93U3BhbiA9IHJvd1NwYW4gKyBtaW5DaGlsZFJvd1NwYW47XG4gICAgICBoZWFkZXIuY29sU3BhbiA9IGNvbFNwYW47XG4gICAgICBoZWFkZXIucm93U3BhbiA9IHJvd1NwYW47XG4gICAgICByZXR1cm4ge1xuICAgICAgICBjb2xTcGFuLFxuICAgICAgICByb3dTcGFuXG4gICAgICB9O1xuICAgIH0pO1xuICB9O1xuICByZWN1cnNlSGVhZGVyc0ZvclNwYW5zKChfaGVhZGVyR3JvdXBzJDAkaGVhZGUgPSAoX2hlYWRlckdyb3VwcyQgPSBoZWFkZXJHcm91cHNbMF0pID09IG51bGwgPyB2b2lkIDAgOiBfaGVhZGVyR3JvdXBzJC5oZWFkZXJzKSAhPSBudWxsID8gX2hlYWRlckdyb3VwcyQwJGhlYWRlIDogW10pO1xuICByZXR1cm4gaGVhZGVyR3JvdXBzO1xufVxuXG4vL1xuXG4vL1xuXG5jb25zdCBkZWZhdWx0Q29sdW1uU2l6aW5nID0ge1xuICBzaXplOiAxNTAsXG4gIG1pblNpemU6IDIwLFxuICBtYXhTaXplOiBOdW1iZXIuTUFYX1NBRkVfSU5URUdFUlxufTtcbmNvbnN0IGdldERlZmF1bHRDb2x1bW5TaXppbmdJbmZvU3RhdGUgPSAoKSA9PiAoe1xuICBzdGFydE9mZnNldDogbnVsbCxcbiAgc3RhcnRTaXplOiBudWxsLFxuICBkZWx0YU9mZnNldDogbnVsbCxcbiAgZGVsdGFQZXJjZW50YWdlOiBudWxsLFxuICBpc1Jlc2l6aW5nQ29sdW1uOiBmYWxzZSxcbiAgY29sdW1uU2l6aW5nU3RhcnQ6IFtdXG59KTtcbmNvbnN0IENvbHVtblNpemluZyA9IHtcbiAgZ2V0RGVmYXVsdENvbHVtbkRlZjogKCkgPT4ge1xuICAgIHJldHVybiBkZWZhdWx0Q29sdW1uU2l6aW5nO1xuICB9LFxuICBnZXRJbml0aWFsU3RhdGU6IHN0YXRlID0+IHtcbiAgICByZXR1cm4ge1xuICAgICAgY29sdW1uU2l6aW5nOiB7fSxcbiAgICAgIGNvbHVtblNpemluZ0luZm86IGdldERlZmF1bHRDb2x1bW5TaXppbmdJbmZvU3RhdGUoKSxcbiAgICAgIC4uLnN0YXRlXG4gICAgfTtcbiAgfSxcbiAgZ2V0RGVmYXVsdE9wdGlvbnM6IHRhYmxlID0+IHtcbiAgICByZXR1cm4ge1xuICAgICAgY29sdW1uUmVzaXplTW9kZTogJ29uRW5kJyxcbiAgICAgIGNvbHVtblJlc2l6ZURpcmVjdGlvbjogJ2x0cicsXG4gICAgICBvbkNvbHVtblNpemluZ0NoYW5nZTogbWFrZVN0YXRlVXBkYXRlcignY29sdW1uU2l6aW5nJywgdGFibGUpLFxuICAgICAgb25Db2x1bW5TaXppbmdJbmZvQ2hhbmdlOiBtYWtlU3RhdGVVcGRhdGVyKCdjb2x1bW5TaXppbmdJbmZvJywgdGFibGUpXG4gICAgfTtcbiAgfSxcbiAgY3JlYXRlQ29sdW1uOiAoY29sdW1uLCB0YWJsZSkgPT4ge1xuICAgIGNvbHVtbi5nZXRTaXplID0gKCkgPT4ge1xuICAgICAgdmFyIF9jb2x1bW4kY29sdW1uRGVmJG1pbiwgX3JlZiwgX2NvbHVtbiRjb2x1bW5EZWYkbWF4O1xuICAgICAgY29uc3QgY29sdW1uU2l6ZSA9IHRhYmxlLmdldFN0YXRlKCkuY29sdW1uU2l6aW5nW2NvbHVtbi5pZF07XG4gICAgICByZXR1cm4gTWF0aC5taW4oTWF0aC5tYXgoKF9jb2x1bW4kY29sdW1uRGVmJG1pbiA9IGNvbHVtbi5jb2x1bW5EZWYubWluU2l6ZSkgIT0gbnVsbCA/IF9jb2x1bW4kY29sdW1uRGVmJG1pbiA6IGRlZmF1bHRDb2x1bW5TaXppbmcubWluU2l6ZSwgKF9yZWYgPSBjb2x1bW5TaXplICE9IG51bGwgPyBjb2x1bW5TaXplIDogY29sdW1uLmNvbHVtbkRlZi5zaXplKSAhPSBudWxsID8gX3JlZiA6IGRlZmF1bHRDb2x1bW5TaXppbmcuc2l6ZSksIChfY29sdW1uJGNvbHVtbkRlZiRtYXggPSBjb2x1bW4uY29sdW1uRGVmLm1heFNpemUpICE9IG51bGwgPyBfY29sdW1uJGNvbHVtbkRlZiRtYXggOiBkZWZhdWx0Q29sdW1uU2l6aW5nLm1heFNpemUpO1xuICAgIH07XG4gICAgY29sdW1uLmdldFN0YXJ0ID0gcG9zaXRpb24gPT4ge1xuICAgICAgY29uc3QgY29sdW1ucyA9ICFwb3NpdGlvbiA/IHRhYmxlLmdldFZpc2libGVMZWFmQ29sdW1ucygpIDogcG9zaXRpb24gPT09ICdsZWZ0JyA/IHRhYmxlLmdldExlZnRWaXNpYmxlTGVhZkNvbHVtbnMoKSA6IHRhYmxlLmdldFJpZ2h0VmlzaWJsZUxlYWZDb2x1bW5zKCk7XG4gICAgICBjb25zdCBpbmRleCA9IGNvbHVtbnMuZmluZEluZGV4KGQgPT4gZC5pZCA9PT0gY29sdW1uLmlkKTtcbiAgICAgIGlmIChpbmRleCA+IDApIHtcbiAgICAgICAgY29uc3QgcHJldlNpYmxpbmdDb2x1bW4gPSBjb2x1bW5zW2luZGV4IC0gMV07XG4gICAgICAgIHJldHVybiBwcmV2U2libGluZ0NvbHVtbi5nZXRTdGFydChwb3NpdGlvbikgKyBwcmV2U2libGluZ0NvbHVtbi5nZXRTaXplKCk7XG4gICAgICB9XG4gICAgICByZXR1cm4gMDtcbiAgICB9O1xuICAgIGNvbHVtbi5yZXNldFNpemUgPSAoKSA9PiB7XG4gICAgICB0YWJsZS5zZXRDb2x1bW5TaXppbmcoX3JlZjIgPT4ge1xuICAgICAgICBsZXQge1xuICAgICAgICAgIFtjb2x1bW4uaWRdOiBfLFxuICAgICAgICAgIC4uLnJlc3RcbiAgICAgICAgfSA9IF9yZWYyO1xuICAgICAgICByZXR1cm4gcmVzdDtcbiAgICAgIH0pO1xuICAgIH07XG4gICAgY29sdW1uLmdldENhblJlc2l6ZSA9ICgpID0+IHtcbiAgICAgIHZhciBfY29sdW1uJGNvbHVtbkRlZiRlbmEsIF90YWJsZSRvcHRpb25zJGVuYWJsZTtcbiAgICAgIHJldHVybiAoKF9jb2x1bW4kY29sdW1uRGVmJGVuYSA9IGNvbHVtbi5jb2x1bW5EZWYuZW5hYmxlUmVzaXppbmcpICE9IG51bGwgPyBfY29sdW1uJGNvbHVtbkRlZiRlbmEgOiB0cnVlKSAmJiAoKF90YWJsZSRvcHRpb25zJGVuYWJsZSA9IHRhYmxlLm9wdGlvbnMuZW5hYmxlQ29sdW1uUmVzaXppbmcpICE9IG51bGwgPyBfdGFibGUkb3B0aW9ucyRlbmFibGUgOiB0cnVlKTtcbiAgICB9O1xuICAgIGNvbHVtbi5nZXRJc1Jlc2l6aW5nID0gKCkgPT4ge1xuICAgICAgcmV0dXJuIHRhYmxlLmdldFN0YXRlKCkuY29sdW1uU2l6aW5nSW5mby5pc1Jlc2l6aW5nQ29sdW1uID09PSBjb2x1bW4uaWQ7XG4gICAgfTtcbiAgfSxcbiAgY3JlYXRlSGVhZGVyOiAoaGVhZGVyLCB0YWJsZSkgPT4ge1xuICAgIGhlYWRlci5nZXRTaXplID0gKCkgPT4ge1xuICAgICAgbGV0IHN1bSA9IDA7XG4gICAgICBjb25zdCByZWN1cnNlID0gaGVhZGVyID0+IHtcbiAgICAgICAgaWYgKGhlYWRlci5zdWJIZWFkZXJzLmxlbmd0aCkge1xuICAgICAgICAgIGhlYWRlci5zdWJIZWFkZXJzLmZvckVhY2gocmVjdXJzZSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdmFyIF9oZWFkZXIkY29sdW1uJGdldFNpejtcbiAgICAgICAgICBzdW0gKz0gKF9oZWFkZXIkY29sdW1uJGdldFNpeiA9IGhlYWRlci5jb2x1bW4uZ2V0U2l6ZSgpKSAhPSBudWxsID8gX2hlYWRlciRjb2x1bW4kZ2V0U2l6IDogMDtcbiAgICAgICAgfVxuICAgICAgfTtcbiAgICAgIHJlY3Vyc2UoaGVhZGVyKTtcbiAgICAgIHJldHVybiBzdW07XG4gICAgfTtcbiAgICBoZWFkZXIuZ2V0U3RhcnQgPSAoKSA9PiB7XG4gICAgICBpZiAoaGVhZGVyLmluZGV4ID4gMCkge1xuICAgICAgICBjb25zdCBwcmV2U2libGluZ0hlYWRlciA9IGhlYWRlci5oZWFkZXJHcm91cC5oZWFkZXJzW2hlYWRlci5pbmRleCAtIDFdO1xuICAgICAgICByZXR1cm4gcHJldlNpYmxpbmdIZWFkZXIuZ2V0U3RhcnQoKSArIHByZXZTaWJsaW5nSGVhZGVyLmdldFNpemUoKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiAwO1xuICAgIH07XG4gICAgaGVhZGVyLmdldFJlc2l6ZUhhbmRsZXIgPSAoKSA9PiB7XG4gICAgICBjb25zdCBjb2x1bW4gPSB0YWJsZS5nZXRDb2x1bW4oaGVhZGVyLmNvbHVtbi5pZCk7XG4gICAgICBjb25zdCBjYW5SZXNpemUgPSBjb2x1bW4gPT0gbnVsbCA/IHZvaWQgMCA6IGNvbHVtbi5nZXRDYW5SZXNpemUoKTtcbiAgICAgIHJldHVybiBlID0+IHtcbiAgICAgICAgaWYgKCFjb2x1bW4gfHwgIWNhblJlc2l6ZSkge1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBlLnBlcnNpc3QgPT0gbnVsbCB8fCBlLnBlcnNpc3QoKTtcbiAgICAgICAgaWYgKGlzVG91Y2hTdGFydEV2ZW50KGUpKSB7XG4gICAgICAgICAgLy8gbGV0cyBub3QgcmVzcG9uZCB0byBtdWx0aXBsZSB0b3VjaGVzIChlLmcuIDIgb3IgMyBmaW5nZXJzKVxuICAgICAgICAgIGlmIChlLnRvdWNoZXMgJiYgZS50b3VjaGVzLmxlbmd0aCA+IDEpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgY29uc3Qgc3RhcnRTaXplID0gaGVhZGVyLmdldFNpemUoKTtcbiAgICAgICAgY29uc3QgY29sdW1uU2l6aW5nU3RhcnQgPSBoZWFkZXIgPyBoZWFkZXIuZ2V0TGVhZkhlYWRlcnMoKS5tYXAoZCA9PiBbZC5jb2x1bW4uaWQsIGQuY29sdW1uLmdldFNpemUoKV0pIDogW1tjb2x1bW4uaWQsIGNvbHVtbi5nZXRTaXplKCldXTtcbiAgICAgICAgY29uc3QgY2xpZW50WCA9IGlzVG91Y2hTdGFydEV2ZW50KGUpID8gTWF0aC5yb3VuZChlLnRvdWNoZXNbMF0uY2xpZW50WCkgOiBlLmNsaWVudFg7XG4gICAgICAgIGNvbnN0IG5ld0NvbHVtblNpemluZyA9IHt9O1xuICAgICAgICBjb25zdCB1cGRhdGVPZmZzZXQgPSAoZXZlbnRUeXBlLCBjbGllbnRYUG9zKSA9PiB7XG4gICAgICAgICAgaWYgKHR5cGVvZiBjbGllbnRYUG9zICE9PSAnbnVtYmVyJykge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgIH1cbiAgICAgICAgICB0YWJsZS5zZXRDb2x1bW5TaXppbmdJbmZvKG9sZCA9PiB7XG4gICAgICAgICAgICB2YXIgX29sZCRzdGFydE9mZnNldCwgX29sZCRzdGFydFNpemU7XG4gICAgICAgICAgICBjb25zdCBkZWx0YURpcmVjdGlvbiA9IHRhYmxlLm9wdGlvbnMuY29sdW1uUmVzaXplRGlyZWN0aW9uID09PSAncnRsJyA/IC0xIDogMTtcbiAgICAgICAgICAgIGNvbnN0IGRlbHRhT2Zmc2V0ID0gKGNsaWVudFhQb3MgLSAoKF9vbGQkc3RhcnRPZmZzZXQgPSBvbGQgPT0gbnVsbCA/IHZvaWQgMCA6IG9sZC5zdGFydE9mZnNldCkgIT0gbnVsbCA/IF9vbGQkc3RhcnRPZmZzZXQgOiAwKSkgKiBkZWx0YURpcmVjdGlvbjtcbiAgICAgICAgICAgIGNvbnN0IGRlbHRhUGVyY2VudGFnZSA9IE1hdGgubWF4KGRlbHRhT2Zmc2V0IC8gKChfb2xkJHN0YXJ0U2l6ZSA9IG9sZCA9PSBudWxsID8gdm9pZCAwIDogb2xkLnN0YXJ0U2l6ZSkgIT0gbnVsbCA/IF9vbGQkc3RhcnRTaXplIDogMCksIC0wLjk5OTk5OSk7XG4gICAgICAgICAgICBvbGQuY29sdW1uU2l6aW5nU3RhcnQuZm9yRWFjaChfcmVmMyA9PiB7XG4gICAgICAgICAgICAgIGxldCBbY29sdW1uSWQsIGhlYWRlclNpemVdID0gX3JlZjM7XG4gICAgICAgICAgICAgIG5ld0NvbHVtblNpemluZ1tjb2x1bW5JZF0gPSBNYXRoLnJvdW5kKE1hdGgubWF4KGhlYWRlclNpemUgKyBoZWFkZXJTaXplICogZGVsdGFQZXJjZW50YWdlLCAwKSAqIDEwMCkgLyAxMDA7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgIC4uLm9sZCxcbiAgICAgICAgICAgICAgZGVsdGFPZmZzZXQsXG4gICAgICAgICAgICAgIGRlbHRhUGVyY2VudGFnZVxuICAgICAgICAgICAgfTtcbiAgICAgICAgICB9KTtcbiAgICAgICAgICBpZiAodGFibGUub3B0aW9ucy5jb2x1bW5SZXNpemVNb2RlID09PSAnb25DaGFuZ2UnIHx8IGV2ZW50VHlwZSA9PT0gJ2VuZCcpIHtcbiAgICAgICAgICAgIHRhYmxlLnNldENvbHVtblNpemluZyhvbGQgPT4gKHtcbiAgICAgICAgICAgICAgLi4ub2xkLFxuICAgICAgICAgICAgICAuLi5uZXdDb2x1bW5TaXppbmdcbiAgICAgICAgICAgIH0pKTtcbiAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICAgIGNvbnN0IG9uTW92ZSA9IGNsaWVudFhQb3MgPT4gdXBkYXRlT2Zmc2V0KCdtb3ZlJywgY2xpZW50WFBvcyk7XG4gICAgICAgIGNvbnN0IG9uRW5kID0gY2xpZW50WFBvcyA9PiB7XG4gICAgICAgICAgdXBkYXRlT2Zmc2V0KCdlbmQnLCBjbGllbnRYUG9zKTtcbiAgICAgICAgICB0YWJsZS5zZXRDb2x1bW5TaXppbmdJbmZvKG9sZCA9PiAoe1xuICAgICAgICAgICAgLi4ub2xkLFxuICAgICAgICAgICAgaXNSZXNpemluZ0NvbHVtbjogZmFsc2UsXG4gICAgICAgICAgICBzdGFydE9mZnNldDogbnVsbCxcbiAgICAgICAgICAgIHN0YXJ0U2l6ZTogbnVsbCxcbiAgICAgICAgICAgIGRlbHRhT2Zmc2V0OiBudWxsLFxuICAgICAgICAgICAgZGVsdGFQZXJjZW50YWdlOiBudWxsLFxuICAgICAgICAgICAgY29sdW1uU2l6aW5nU3RhcnQ6IFtdXG4gICAgICAgICAgfSkpO1xuICAgICAgICB9O1xuICAgICAgICBjb25zdCBtb3VzZUV2ZW50cyA9IHtcbiAgICAgICAgICBtb3ZlSGFuZGxlcjogZSA9PiBvbk1vdmUoZS5jbGllbnRYKSxcbiAgICAgICAgICB1cEhhbmRsZXI6IGUgPT4ge1xuICAgICAgICAgICAgZG9jdW1lbnQucmVtb3ZlRXZlbnRMaXN0ZW5lcignbW91c2Vtb3ZlJywgbW91c2VFdmVudHMubW92ZUhhbmRsZXIpO1xuICAgICAgICAgICAgZG9jdW1lbnQucmVtb3ZlRXZlbnRMaXN0ZW5lcignbW91c2V1cCcsIG1vdXNlRXZlbnRzLnVwSGFuZGxlcik7XG4gICAgICAgICAgICBvbkVuZChlLmNsaWVudFgpO1xuICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgICAgY29uc3QgdG91Y2hFdmVudHMgPSB7XG4gICAgICAgICAgbW92ZUhhbmRsZXI6IGUgPT4ge1xuICAgICAgICAgICAgaWYgKGUuY2FuY2VsYWJsZSkge1xuICAgICAgICAgICAgICBlLnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgICAgICAgIGUuc3RvcFByb3BhZ2F0aW9uKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBvbk1vdmUoZS50b3VjaGVzWzBdLmNsaWVudFgpO1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgIH0sXG4gICAgICAgICAgdXBIYW5kbGVyOiBlID0+IHtcbiAgICAgICAgICAgIHZhciBfZSR0b3VjaGVzJDtcbiAgICAgICAgICAgIGRvY3VtZW50LnJlbW92ZUV2ZW50TGlzdGVuZXIoJ3RvdWNobW92ZScsIHRvdWNoRXZlbnRzLm1vdmVIYW5kbGVyKTtcbiAgICAgICAgICAgIGRvY3VtZW50LnJlbW92ZUV2ZW50TGlzdGVuZXIoJ3RvdWNoZW5kJywgdG91Y2hFdmVudHMudXBIYW5kbGVyKTtcbiAgICAgICAgICAgIGlmIChlLmNhbmNlbGFibGUpIHtcbiAgICAgICAgICAgICAgZS5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICAgICAgICBlLnN0b3BQcm9wYWdhdGlvbigpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgb25FbmQoKF9lJHRvdWNoZXMkID0gZS50b3VjaGVzWzBdKSA9PSBudWxsID8gdm9pZCAwIDogX2UkdG91Y2hlcyQuY2xpZW50WCk7XG4gICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgICBjb25zdCBwYXNzaXZlSWZTdXBwb3J0ZWQgPSBwYXNzaXZlRXZlbnRTdXBwb3J0ZWQoKSA/IHtcbiAgICAgICAgICBwYXNzaXZlOiBmYWxzZVxuICAgICAgICB9IDogZmFsc2U7XG4gICAgICAgIGlmIChpc1RvdWNoU3RhcnRFdmVudChlKSkge1xuICAgICAgICAgIGRvY3VtZW50LmFkZEV2ZW50TGlzdGVuZXIoJ3RvdWNobW92ZScsIHRvdWNoRXZlbnRzLm1vdmVIYW5kbGVyLCBwYXNzaXZlSWZTdXBwb3J0ZWQpO1xuICAgICAgICAgIGRvY3VtZW50LmFkZEV2ZW50TGlzdGVuZXIoJ3RvdWNoZW5kJywgdG91Y2hFdmVudHMudXBIYW5kbGVyLCBwYXNzaXZlSWZTdXBwb3J0ZWQpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGRvY3VtZW50LmFkZEV2ZW50TGlzdGVuZXIoJ21vdXNlbW92ZScsIG1vdXNlRXZlbnRzLm1vdmVIYW5kbGVyLCBwYXNzaXZlSWZTdXBwb3J0ZWQpO1xuICAgICAgICAgIGRvY3VtZW50LmFkZEV2ZW50TGlzdGVuZXIoJ21vdXNldXAnLCBtb3VzZUV2ZW50cy51cEhhbmRsZXIsIHBhc3NpdmVJZlN1cHBvcnRlZCk7XG4gICAgICAgIH1cbiAgICAgICAgdGFibGUuc2V0Q29sdW1uU2l6aW5nSW5mbyhvbGQgPT4gKHtcbiAgICAgICAgICAuLi5vbGQsXG4gICAgICAgICAgc3RhcnRPZmZzZXQ6IGNsaWVudFgsXG4gICAgICAgICAgc3RhcnRTaXplLFxuICAgICAgICAgIGRlbHRhT2Zmc2V0OiAwLFxuICAgICAgICAgIGRlbHRhUGVyY2VudGFnZTogMCxcbiAgICAgICAgICBjb2x1bW5TaXppbmdTdGFydCxcbiAgICAgICAgICBpc1Jlc2l6aW5nQ29sdW1uOiBjb2x1bW4uaWRcbiAgICAgICAgfSkpO1xuICAgICAgfTtcbiAgICB9O1xuICB9LFxuICBjcmVhdGVUYWJsZTogdGFibGUgPT4ge1xuICAgIHRhYmxlLnNldENvbHVtblNpemluZyA9IHVwZGF0ZXIgPT4gdGFibGUub3B0aW9ucy5vbkNvbHVtblNpemluZ0NoYW5nZSA9PSBudWxsID8gdm9pZCAwIDogdGFibGUub3B0aW9ucy5vbkNvbHVtblNpemluZ0NoYW5nZSh1cGRhdGVyKTtcbiAgICB0YWJsZS5zZXRDb2x1bW5TaXppbmdJbmZvID0gdXBkYXRlciA9PiB0YWJsZS5vcHRpb25zLm9uQ29sdW1uU2l6aW5nSW5mb0NoYW5nZSA9PSBudWxsID8gdm9pZCAwIDogdGFibGUub3B0aW9ucy5vbkNvbHVtblNpemluZ0luZm9DaGFuZ2UodXBkYXRlcik7XG4gICAgdGFibGUucmVzZXRDb2x1bW5TaXppbmcgPSBkZWZhdWx0U3RhdGUgPT4ge1xuICAgICAgdmFyIF90YWJsZSRpbml0aWFsU3RhdGUkYztcbiAgICAgIHRhYmxlLnNldENvbHVtblNpemluZyhkZWZhdWx0U3RhdGUgPyB7fSA6IChfdGFibGUkaW5pdGlhbFN0YXRlJGMgPSB0YWJsZS5pbml0aWFsU3RhdGUuY29sdW1uU2l6aW5nKSAhPSBudWxsID8gX3RhYmxlJGluaXRpYWxTdGF0ZSRjIDoge30pO1xuICAgIH07XG4gICAgdGFibGUucmVzZXRIZWFkZXJTaXplSW5mbyA9IGRlZmF1bHRTdGF0ZSA9PiB7XG4gICAgICB2YXIgX3RhYmxlJGluaXRpYWxTdGF0ZSRjMjtcbiAgICAgIHRhYmxlLnNldENvbHVtblNpemluZ0luZm8oZGVmYXVsdFN0YXRlID8gZ2V0RGVmYXVsdENvbHVtblNpemluZ0luZm9TdGF0ZSgpIDogKF90YWJsZSRpbml0aWFsU3RhdGUkYzIgPSB0YWJsZS5pbml0aWFsU3RhdGUuY29sdW1uU2l6aW5nSW5mbykgIT0gbnVsbCA/IF90YWJsZSRpbml0aWFsU3RhdGUkYzIgOiBnZXREZWZhdWx0Q29sdW1uU2l6aW5nSW5mb1N0YXRlKCkpO1xuICAgIH07XG4gICAgdGFibGUuZ2V0VG90YWxTaXplID0gKCkgPT4ge1xuICAgICAgdmFyIF90YWJsZSRnZXRIZWFkZXJHcm91cCwgX3RhYmxlJGdldEhlYWRlckdyb3VwMjtcbiAgICAgIHJldHVybiAoX3RhYmxlJGdldEhlYWRlckdyb3VwID0gKF90YWJsZSRnZXRIZWFkZXJHcm91cDIgPSB0YWJsZS5nZXRIZWFkZXJHcm91cHMoKVswXSkgPT0gbnVsbCA/IHZvaWQgMCA6IF90YWJsZSRnZXRIZWFkZXJHcm91cDIuaGVhZGVycy5yZWR1Y2UoKHN1bSwgaGVhZGVyKSA9PiB7XG4gICAgICAgIHJldHVybiBzdW0gKyBoZWFkZXIuZ2V0U2l6ZSgpO1xuICAgICAgfSwgMCkpICE9IG51bGwgPyBfdGFibGUkZ2V0SGVhZGVyR3JvdXAgOiAwO1xuICAgIH07XG4gICAgdGFibGUuZ2V0TGVmdFRvdGFsU2l6ZSA9ICgpID0+IHtcbiAgICAgIHZhciBfdGFibGUkZ2V0TGVmdEhlYWRlckcsIF90YWJsZSRnZXRMZWZ0SGVhZGVyRzI7XG4gICAgICByZXR1cm4gKF90YWJsZSRnZXRMZWZ0SGVhZGVyRyA9IChfdGFibGUkZ2V0TGVmdEhlYWRlckcyID0gdGFibGUuZ2V0TGVmdEhlYWRlckdyb3VwcygpWzBdKSA9PSBudWxsID8gdm9pZCAwIDogX3RhYmxlJGdldExlZnRIZWFkZXJHMi5oZWFkZXJzLnJlZHVjZSgoc3VtLCBoZWFkZXIpID0+IHtcbiAgICAgICAgcmV0dXJuIHN1bSArIGhlYWRlci5nZXRTaXplKCk7XG4gICAgICB9LCAwKSkgIT0gbnVsbCA/IF90YWJsZSRnZXRMZWZ0SGVhZGVyRyA6IDA7XG4gICAgfTtcbiAgICB0YWJsZS5nZXRDZW50ZXJUb3RhbFNpemUgPSAoKSA9PiB7XG4gICAgICB2YXIgX3RhYmxlJGdldENlbnRlckhlYWRlLCBfdGFibGUkZ2V0Q2VudGVySGVhZGUyO1xuICAgICAgcmV0dXJuIChfdGFibGUkZ2V0Q2VudGVySGVhZGUgPSAoX3RhYmxlJGdldENlbnRlckhlYWRlMiA9IHRhYmxlLmdldENlbnRlckhlYWRlckdyb3VwcygpWzBdKSA9PSBudWxsID8gdm9pZCAwIDogX3RhYmxlJGdldENlbnRlckhlYWRlMi5oZWFkZXJzLnJlZHVjZSgoc3VtLCBoZWFkZXIpID0+IHtcbiAgICAgICAgcmV0dXJuIHN1bSArIGhlYWRlci5nZXRTaXplKCk7XG4gICAgICB9LCAwKSkgIT0gbnVsbCA/IF90YWJsZSRnZXRDZW50ZXJIZWFkZSA6IDA7XG4gICAgfTtcbiAgICB0YWJsZS5nZXRSaWdodFRvdGFsU2l6ZSA9ICgpID0+IHtcbiAgICAgIHZhciBfdGFibGUkZ2V0UmlnaHRIZWFkZXIsIF90YWJsZSRnZXRSaWdodEhlYWRlcjI7XG4gICAgICByZXR1cm4gKF90YWJsZSRnZXRSaWdodEhlYWRlciA9IChfdGFibGUkZ2V0UmlnaHRIZWFkZXIyID0gdGFibGUuZ2V0UmlnaHRIZWFkZXJHcm91cHMoKVswXSkgPT0gbnVsbCA/IHZvaWQgMCA6IF90YWJsZSRnZXRSaWdodEhlYWRlcjIuaGVhZGVycy5yZWR1Y2UoKHN1bSwgaGVhZGVyKSA9PiB7XG4gICAgICAgIHJldHVybiBzdW0gKyBoZWFkZXIuZ2V0U2l6ZSgpO1xuICAgICAgfSwgMCkpICE9IG51bGwgPyBfdGFibGUkZ2V0UmlnaHRIZWFkZXIgOiAwO1xuICAgIH07XG4gIH1cbn07XG5sZXQgcGFzc2l2ZVN1cHBvcnRlZCA9IG51bGw7XG5mdW5jdGlvbiBwYXNzaXZlRXZlbnRTdXBwb3J0ZWQoKSB7XG4gIGlmICh0eXBlb2YgcGFzc2l2ZVN1cHBvcnRlZCA9PT0gJ2Jvb2xlYW4nKSByZXR1cm4gcGFzc2l2ZVN1cHBvcnRlZDtcbiAgbGV0IHN1cHBvcnRlZCA9IGZhbHNlO1xuICB0cnkge1xuICAgIGNvbnN0IG9wdGlvbnMgPSB7XG4gICAgICBnZXQgcGFzc2l2ZSgpIHtcbiAgICAgICAgc3VwcG9ydGVkID0gdHJ1ZTtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuICAgIH07XG4gICAgY29uc3Qgbm9vcCA9ICgpID0+IHt9O1xuICAgIHdpbmRvdy5hZGRFdmVudExpc3RlbmVyKCd0ZXN0Jywgbm9vcCwgb3B0aW9ucyk7XG4gICAgd2luZG93LnJlbW92ZUV2ZW50TGlzdGVuZXIoJ3Rlc3QnLCBub29wKTtcbiAgfSBjYXRjaCAoZXJyKSB7XG4gICAgc3VwcG9ydGVkID0gZmFsc2U7XG4gIH1cbiAgcGFzc2l2ZVN1cHBvcnRlZCA9IHN1cHBvcnRlZDtcbiAgcmV0dXJuIHBhc3NpdmVTdXBwb3J0ZWQ7XG59XG5mdW5jdGlvbiBpc1RvdWNoU3RhcnRFdmVudChlKSB7XG4gIHJldHVybiBlLnR5cGUgPT09ICd0b3VjaHN0YXJ0Jztcbn1cblxuLy9cblxuY29uc3QgRXhwYW5kaW5nID0ge1xuICBnZXRJbml0aWFsU3RhdGU6IHN0YXRlID0+IHtcbiAgICByZXR1cm4ge1xuICAgICAgZXhwYW5kZWQ6IHt9LFxuICAgICAgLi4uc3RhdGVcbiAgICB9O1xuICB9LFxuICBnZXREZWZhdWx0T3B0aW9uczogdGFibGUgPT4ge1xuICAgIHJldHVybiB7XG4gICAgICBvbkV4cGFuZGVkQ2hhbmdlOiBtYWtlU3RhdGVVcGRhdGVyKCdleHBhbmRlZCcsIHRhYmxlKSxcbiAgICAgIHBhZ2luYXRlRXhwYW5kZWRSb3dzOiB0cnVlXG4gICAgfTtcbiAgfSxcbiAgY3JlYXRlVGFibGU6IHRhYmxlID0+IHtcbiAgICBsZXQgcmVnaXN0ZXJlZCA9IGZhbHNlO1xuICAgIGxldCBxdWV1ZWQgPSBmYWxzZTtcbiAgICB0YWJsZS5fYXV0b1Jlc2V0RXhwYW5kZWQgPSAoKSA9PiB7XG4gICAgICB2YXIgX3JlZiwgX3RhYmxlJG9wdGlvbnMkYXV0b1JlO1xuICAgICAgaWYgKCFyZWdpc3RlcmVkKSB7XG4gICAgICAgIHRhYmxlLl9xdWV1ZSgoKSA9PiB7XG4gICAgICAgICAgcmVnaXN0ZXJlZCA9IHRydWU7XG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBpZiAoKF9yZWYgPSAoX3RhYmxlJG9wdGlvbnMkYXV0b1JlID0gdGFibGUub3B0aW9ucy5hdXRvUmVzZXRBbGwpICE9IG51bGwgPyBfdGFibGUkb3B0aW9ucyRhdXRvUmUgOiB0YWJsZS5vcHRpb25zLmF1dG9SZXNldEV4cGFuZGVkKSAhPSBudWxsID8gX3JlZiA6ICF0YWJsZS5vcHRpb25zLm1hbnVhbEV4cGFuZGluZykge1xuICAgICAgICBpZiAocXVldWVkKSByZXR1cm47XG4gICAgICAgIHF1ZXVlZCA9IHRydWU7XG4gICAgICAgIHRhYmxlLl9xdWV1ZSgoKSA9PiB7XG4gICAgICAgICAgdGFibGUucmVzZXRFeHBhbmRlZCgpO1xuICAgICAgICAgIHF1ZXVlZCA9IGZhbHNlO1xuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICB9O1xuICAgIHRhYmxlLnNldEV4cGFuZGVkID0gdXBkYXRlciA9PiB0YWJsZS5vcHRpb25zLm9uRXhwYW5kZWRDaGFuZ2UgPT0gbnVsbCA/IHZvaWQgMCA6IHRhYmxlLm9wdGlvbnMub25FeHBhbmRlZENoYW5nZSh1cGRhdGVyKTtcbiAgICB0YWJsZS50b2dnbGVBbGxSb3dzRXhwYW5kZWQgPSBleHBhbmRlZCA9PiB7XG4gICAgICBpZiAoZXhwYW5kZWQgIT0gbnVsbCA/IGV4cGFuZGVkIDogIXRhYmxlLmdldElzQWxsUm93c0V4cGFuZGVkKCkpIHtcbiAgICAgICAgdGFibGUuc2V0RXhwYW5kZWQodHJ1ZSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0YWJsZS5zZXRFeHBhbmRlZCh7fSk7XG4gICAgICB9XG4gICAgfTtcbiAgICB0YWJsZS5yZXNldEV4cGFuZGVkID0gZGVmYXVsdFN0YXRlID0+IHtcbiAgICAgIHZhciBfdGFibGUkaW5pdGlhbFN0YXRlJGUsIF90YWJsZSRpbml0aWFsU3RhdGU7XG4gICAgICB0YWJsZS5zZXRFeHBhbmRlZChkZWZhdWx0U3RhdGUgPyB7fSA6IChfdGFibGUkaW5pdGlhbFN0YXRlJGUgPSAoX3RhYmxlJGluaXRpYWxTdGF0ZSA9IHRhYmxlLmluaXRpYWxTdGF0ZSkgPT0gbnVsbCA/IHZvaWQgMCA6IF90YWJsZSRpbml0aWFsU3RhdGUuZXhwYW5kZWQpICE9IG51bGwgPyBfdGFibGUkaW5pdGlhbFN0YXRlJGUgOiB7fSk7XG4gICAgfTtcbiAgICB0YWJsZS5nZXRDYW5Tb21lUm93c0V4cGFuZCA9ICgpID0+IHtcbiAgICAgIHJldHVybiB0YWJsZS5nZXRQcmVQYWdpbmF0aW9uUm93TW9kZWwoKS5mbGF0Um93cy5zb21lKHJvdyA9PiByb3cuZ2V0Q2FuRXhwYW5kKCkpO1xuICAgIH07XG4gICAgdGFibGUuZ2V0VG9nZ2xlQWxsUm93c0V4cGFuZGVkSGFuZGxlciA9ICgpID0+IHtcbiAgICAgIHJldHVybiBlID0+IHtcbiAgICAgICAgZS5wZXJzaXN0ID09IG51bGwgfHwgZS5wZXJzaXN0KCk7XG4gICAgICAgIHRhYmxlLnRvZ2dsZUFsbFJvd3NFeHBhbmRlZCgpO1xuICAgICAgfTtcbiAgICB9O1xuICAgIHRhYmxlLmdldElzU29tZVJvd3NFeHBhbmRlZCA9ICgpID0+IHtcbiAgICAgIGNvbnN0IGV4cGFuZGVkID0gdGFibGUuZ2V0U3RhdGUoKS5leHBhbmRlZDtcbiAgICAgIHJldHVybiBleHBhbmRlZCA9PT0gdHJ1ZSB8fCBPYmplY3QudmFsdWVzKGV4cGFuZGVkKS5zb21lKEJvb2xlYW4pO1xuICAgIH07XG4gICAgdGFibGUuZ2V0SXNBbGxSb3dzRXhwYW5kZWQgPSAoKSA9PiB7XG4gICAgICBjb25zdCBleHBhbmRlZCA9IHRhYmxlLmdldFN0YXRlKCkuZXhwYW5kZWQ7XG5cbiAgICAgIC8vIElmIGV4cGFuZGVkIGlzIHRydWUsIHNhdmUgc29tZSBjeWNsZXMgYW5kIHJldHVybiB0cnVlXG4gICAgICBpZiAodHlwZW9mIGV4cGFuZGVkID09PSAnYm9vbGVhbicpIHtcbiAgICAgICAgcmV0dXJuIGV4cGFuZGVkID09PSB0cnVlO1xuICAgICAgfVxuICAgICAgaWYgKCFPYmplY3Qua2V5cyhleHBhbmRlZCkubGVuZ3RoKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cblxuICAgICAgLy8gSWYgYW55IHJvdyBpcyBub3QgZXhwYW5kZWQsIHJldHVybiBmYWxzZVxuICAgICAgaWYgKHRhYmxlLmdldFJvd01vZGVsKCkuZmxhdFJvd3Muc29tZShyb3cgPT4gIXJvdy5nZXRJc0V4cGFuZGVkKCkpKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cblxuICAgICAgLy8gVGhleSBtdXN0IGFsbCBiZSBleHBhbmRlZCA6c2hydWc6XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9O1xuICAgIHRhYmxlLmdldEV4cGFuZGVkRGVwdGggPSAoKSA9PiB7XG4gICAgICBsZXQgbWF4RGVwdGggPSAwO1xuICAgICAgY29uc3Qgcm93SWRzID0gdGFibGUuZ2V0U3RhdGUoKS5leHBhbmRlZCA9PT0gdHJ1ZSA/IE9iamVjdC5rZXlzKHRhYmxlLmdldFJvd01vZGVsKCkucm93c0J5SWQpIDogT2JqZWN0LmtleXModGFibGUuZ2V0U3RhdGUoKS5leHBhbmRlZCk7XG4gICAgICByb3dJZHMuZm9yRWFjaChpZCA9PiB7XG4gICAgICAgIGNvbnN0IHNwbGl0SWQgPSBpZC5zcGxpdCgnLicpO1xuICAgICAgICBtYXhEZXB0aCA9IE1hdGgubWF4KG1heERlcHRoLCBzcGxpdElkLmxlbmd0aCk7XG4gICAgICB9KTtcbiAgICAgIHJldHVybiBtYXhEZXB0aDtcbiAgICB9O1xuICAgIHRhYmxlLmdldFByZUV4cGFuZGVkUm93TW9kZWwgPSAoKSA9PiB0YWJsZS5nZXRTb3J0ZWRSb3dNb2RlbCgpO1xuICAgIHRhYmxlLmdldEV4cGFuZGVkUm93TW9kZWwgPSAoKSA9PiB7XG4gICAgICBpZiAoIXRhYmxlLl9nZXRFeHBhbmRlZFJvd01vZGVsICYmIHRhYmxlLm9wdGlvbnMuZ2V0RXhwYW5kZWRSb3dNb2RlbCkge1xuICAgICAgICB0YWJsZS5fZ2V0RXhwYW5kZWRSb3dNb2RlbCA9IHRhYmxlLm9wdGlvbnMuZ2V0RXhwYW5kZWRSb3dNb2RlbCh0YWJsZSk7XG4gICAgICB9XG4gICAgICBpZiAodGFibGUub3B0aW9ucy5tYW51YWxFeHBhbmRpbmcgfHwgIXRhYmxlLl9nZXRFeHBhbmRlZFJvd01vZGVsKSB7XG4gICAgICAgIHJldHVybiB0YWJsZS5nZXRQcmVFeHBhbmRlZFJvd01vZGVsKCk7XG4gICAgICB9XG4gICAgICByZXR1cm4gdGFibGUuX2dldEV4cGFuZGVkUm93TW9kZWwoKTtcbiAgICB9O1xuICB9LFxuICBjcmVhdGVSb3c6IChyb3csIHRhYmxlKSA9PiB7XG4gICAgcm93LnRvZ2dsZUV4cGFuZGVkID0gZXhwYW5kZWQgPT4ge1xuICAgICAgdGFibGUuc2V0RXhwYW5kZWQob2xkID0+IHtcbiAgICAgICAgdmFyIF9leHBhbmRlZDtcbiAgICAgICAgY29uc3QgZXhpc3RzID0gb2xkID09PSB0cnVlID8gdHJ1ZSA6ICEhKG9sZCAhPSBudWxsICYmIG9sZFtyb3cuaWRdKTtcbiAgICAgICAgbGV0IG9sZEV4cGFuZGVkID0ge307XG4gICAgICAgIGlmIChvbGQgPT09IHRydWUpIHtcbiAgICAgICAgICBPYmplY3Qua2V5cyh0YWJsZS5nZXRSb3dNb2RlbCgpLnJvd3NCeUlkKS5mb3JFYWNoKHJvd0lkID0+IHtcbiAgICAgICAgICAgIG9sZEV4cGFuZGVkW3Jvd0lkXSA9IHRydWU7XG4gICAgICAgICAgfSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgb2xkRXhwYW5kZWQgPSBvbGQ7XG4gICAgICAgIH1cbiAgICAgICAgZXhwYW5kZWQgPSAoX2V4cGFuZGVkID0gZXhwYW5kZWQpICE9IG51bGwgPyBfZXhwYW5kZWQgOiAhZXhpc3RzO1xuICAgICAgICBpZiAoIWV4aXN0cyAmJiBleHBhbmRlZCkge1xuICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAuLi5vbGRFeHBhbmRlZCxcbiAgICAgICAgICAgIFtyb3cuaWRdOiB0cnVlXG4gICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoZXhpc3RzICYmICFleHBhbmRlZCkge1xuICAgICAgICAgIGNvbnN0IHtcbiAgICAgICAgICAgIFtyb3cuaWRdOiBfLFxuICAgICAgICAgICAgLi4ucmVzdFxuICAgICAgICAgIH0gPSBvbGRFeHBhbmRlZDtcbiAgICAgICAgICByZXR1cm4gcmVzdDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gb2xkO1xuICAgICAgfSk7XG4gICAgfTtcbiAgICByb3cuZ2V0SXNFeHBhbmRlZCA9ICgpID0+IHtcbiAgICAgIHZhciBfdGFibGUkb3B0aW9ucyRnZXRJc1I7XG4gICAgICBjb25zdCBleHBhbmRlZCA9IHRhYmxlLmdldFN0YXRlKCkuZXhwYW5kZWQ7XG4gICAgICByZXR1cm4gISEoKF90YWJsZSRvcHRpb25zJGdldElzUiA9IHRhYmxlLm9wdGlvbnMuZ2V0SXNSb3dFeHBhbmRlZCA9PSBudWxsID8gdm9pZCAwIDogdGFibGUub3B0aW9ucy5nZXRJc1Jvd0V4cGFuZGVkKHJvdykpICE9IG51bGwgPyBfdGFibGUkb3B0aW9ucyRnZXRJc1IgOiBleHBhbmRlZCA9PT0gdHJ1ZSB8fCAoZXhwYW5kZWQgPT0gbnVsbCA/IHZvaWQgMCA6IGV4cGFuZGVkW3Jvdy5pZF0pKTtcbiAgICB9O1xuICAgIHJvdy5nZXRDYW5FeHBhbmQgPSAoKSA9PiB7XG4gICAgICB2YXIgX3RhYmxlJG9wdGlvbnMkZ2V0Um93LCBfdGFibGUkb3B0aW9ucyRlbmFibGUsIF9yb3ckc3ViUm93cztcbiAgICAgIHJldHVybiAoX3RhYmxlJG9wdGlvbnMkZ2V0Um93ID0gdGFibGUub3B0aW9ucy5nZXRSb3dDYW5FeHBhbmQgPT0gbnVsbCA/IHZvaWQgMCA6IHRhYmxlLm9wdGlvbnMuZ2V0Um93Q2FuRXhwYW5kKHJvdykpICE9IG51bGwgPyBfdGFibGUkb3B0aW9ucyRnZXRSb3cgOiAoKF90YWJsZSRvcHRpb25zJGVuYWJsZSA9IHRhYmxlLm9wdGlvbnMuZW5hYmxlRXhwYW5kaW5nKSAhPSBudWxsID8gX3RhYmxlJG9wdGlvbnMkZW5hYmxlIDogdHJ1ZSkgJiYgISEoKF9yb3ckc3ViUm93cyA9IHJvdy5zdWJSb3dzKSAhPSBudWxsICYmIF9yb3ckc3ViUm93cy5sZW5ndGgpO1xuICAgIH07XG4gICAgcm93LmdldElzQWxsUGFyZW50c0V4cGFuZGVkID0gKCkgPT4ge1xuICAgICAgbGV0IGlzRnVsbHlFeHBhbmRlZCA9IHRydWU7XG4gICAgICBsZXQgY3VycmVudFJvdyA9IHJvdztcbiAgICAgIHdoaWxlIChpc0Z1bGx5RXhwYW5kZWQgJiYgY3VycmVudFJvdy5wYXJlbnRJZCkge1xuICAgICAgICBjdXJyZW50Um93ID0gdGFibGUuZ2V0Um93KGN1cnJlbnRSb3cucGFyZW50SWQsIHRydWUpO1xuICAgICAgICBpc0Z1bGx5RXhwYW5kZWQgPSBjdXJyZW50Um93LmdldElzRXhwYW5kZWQoKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBpc0Z1bGx5RXhwYW5kZWQ7XG4gICAgfTtcbiAgICByb3cuZ2V0VG9nZ2xlRXhwYW5kZWRIYW5kbGVyID0gKCkgPT4ge1xuICAgICAgY29uc3QgY2FuRXhwYW5kID0gcm93LmdldENhbkV4cGFuZCgpO1xuICAgICAgcmV0dXJuICgpID0+IHtcbiAgICAgICAgaWYgKCFjYW5FeHBhbmQpIHJldHVybjtcbiAgICAgICAgcm93LnRvZ2dsZUV4cGFuZGVkKCk7XG4gICAgICB9O1xuICAgIH07XG4gIH1cbn07XG5cbmNvbnN0IGluY2x1ZGVzU3RyaW5nID0gKHJvdywgY29sdW1uSWQsIGZpbHRlclZhbHVlKSA9PiB7XG4gIHZhciBfcm93JGdldFZhbHVlO1xuICBjb25zdCBzZWFyY2ggPSBmaWx0ZXJWYWx1ZS50b0xvd2VyQ2FzZSgpO1xuICByZXR1cm4gQm9vbGVhbigoX3JvdyRnZXRWYWx1ZSA9IHJvdy5nZXRWYWx1ZShjb2x1bW5JZCkpID09IG51bGwgfHwgKF9yb3ckZ2V0VmFsdWUgPSBfcm93JGdldFZhbHVlLnRvU3RyaW5nKCkpID09IG51bGwgfHwgKF9yb3ckZ2V0VmFsdWUgPSBfcm93JGdldFZhbHVlLnRvTG93ZXJDYXNlKCkpID09IG51bGwgPyB2b2lkIDAgOiBfcm93JGdldFZhbHVlLmluY2x1ZGVzKHNlYXJjaCkpO1xufTtcbmluY2x1ZGVzU3RyaW5nLmF1dG9SZW1vdmUgPSB2YWwgPT4gdGVzdEZhbHNleSh2YWwpO1xuY29uc3QgaW5jbHVkZXNTdHJpbmdTZW5zaXRpdmUgPSAocm93LCBjb2x1bW5JZCwgZmlsdGVyVmFsdWUpID0+IHtcbiAgdmFyIF9yb3ckZ2V0VmFsdWUyO1xuICByZXR1cm4gQm9vbGVhbigoX3JvdyRnZXRWYWx1ZTIgPSByb3cuZ2V0VmFsdWUoY29sdW1uSWQpKSA9PSBudWxsIHx8IChfcm93JGdldFZhbHVlMiA9IF9yb3ckZ2V0VmFsdWUyLnRvU3RyaW5nKCkpID09IG51bGwgPyB2b2lkIDAgOiBfcm93JGdldFZhbHVlMi5pbmNsdWRlcyhmaWx0ZXJWYWx1ZSkpO1xufTtcbmluY2x1ZGVzU3RyaW5nU2Vuc2l0aXZlLmF1dG9SZW1vdmUgPSB2YWwgPT4gdGVzdEZhbHNleSh2YWwpO1xuY29uc3QgZXF1YWxzU3RyaW5nID0gKHJvdywgY29sdW1uSWQsIGZpbHRlclZhbHVlKSA9PiB7XG4gIHZhciBfcm93JGdldFZhbHVlMztcbiAgcmV0dXJuICgoX3JvdyRnZXRWYWx1ZTMgPSByb3cuZ2V0VmFsdWUoY29sdW1uSWQpKSA9PSBudWxsIHx8IChfcm93JGdldFZhbHVlMyA9IF9yb3ckZ2V0VmFsdWUzLnRvU3RyaW5nKCkpID09IG51bGwgPyB2b2lkIDAgOiBfcm93JGdldFZhbHVlMy50b0xvd2VyQ2FzZSgpKSA9PT0gKGZpbHRlclZhbHVlID09IG51bGwgPyB2b2lkIDAgOiBmaWx0ZXJWYWx1ZS50b0xvd2VyQ2FzZSgpKTtcbn07XG5lcXVhbHNTdHJpbmcuYXV0b1JlbW92ZSA9IHZhbCA9PiB0ZXN0RmFsc2V5KHZhbCk7XG5jb25zdCBhcnJJbmNsdWRlcyA9IChyb3csIGNvbHVtbklkLCBmaWx0ZXJWYWx1ZSkgPT4ge1xuICB2YXIgX3JvdyRnZXRWYWx1ZTQ7XG4gIHJldHVybiAoX3JvdyRnZXRWYWx1ZTQgPSByb3cuZ2V0VmFsdWUoY29sdW1uSWQpKSA9PSBudWxsID8gdm9pZCAwIDogX3JvdyRnZXRWYWx1ZTQuaW5jbHVkZXMoZmlsdGVyVmFsdWUpO1xufTtcbmFyckluY2x1ZGVzLmF1dG9SZW1vdmUgPSB2YWwgPT4gdGVzdEZhbHNleSh2YWwpIHx8ICEodmFsICE9IG51bGwgJiYgdmFsLmxlbmd0aCk7XG5jb25zdCBhcnJJbmNsdWRlc0FsbCA9IChyb3csIGNvbHVtbklkLCBmaWx0ZXJWYWx1ZSkgPT4ge1xuICByZXR1cm4gIWZpbHRlclZhbHVlLnNvbWUodmFsID0+IHtcbiAgICB2YXIgX3JvdyRnZXRWYWx1ZTU7XG4gICAgcmV0dXJuICEoKF9yb3ckZ2V0VmFsdWU1ID0gcm93LmdldFZhbHVlKGNvbHVtbklkKSkgIT0gbnVsbCAmJiBfcm93JGdldFZhbHVlNS5pbmNsdWRlcyh2YWwpKTtcbiAgfSk7XG59O1xuYXJySW5jbHVkZXNBbGwuYXV0b1JlbW92ZSA9IHZhbCA9PiB0ZXN0RmFsc2V5KHZhbCkgfHwgISh2YWwgIT0gbnVsbCAmJiB2YWwubGVuZ3RoKTtcbmNvbnN0IGFyckluY2x1ZGVzU29tZSA9IChyb3csIGNvbHVtbklkLCBmaWx0ZXJWYWx1ZSkgPT4ge1xuICByZXR1cm4gZmlsdGVyVmFsdWUuc29tZSh2YWwgPT4ge1xuICAgIHZhciBfcm93JGdldFZhbHVlNjtcbiAgICByZXR1cm4gKF9yb3ckZ2V0VmFsdWU2ID0gcm93LmdldFZhbHVlKGNvbHVtbklkKSkgPT0gbnVsbCA/IHZvaWQgMCA6IF9yb3ckZ2V0VmFsdWU2LmluY2x1ZGVzKHZhbCk7XG4gIH0pO1xufTtcbmFyckluY2x1ZGVzU29tZS5hdXRvUmVtb3ZlID0gdmFsID0+IHRlc3RGYWxzZXkodmFsKSB8fCAhKHZhbCAhPSBudWxsICYmIHZhbC5sZW5ndGgpO1xuY29uc3QgZXF1YWxzID0gKHJvdywgY29sdW1uSWQsIGZpbHRlclZhbHVlKSA9PiB7XG4gIHJldHVybiByb3cuZ2V0VmFsdWUoY29sdW1uSWQpID09PSBmaWx0ZXJWYWx1ZTtcbn07XG5lcXVhbHMuYXV0b1JlbW92ZSA9IHZhbCA9PiB0ZXN0RmFsc2V5KHZhbCk7XG5jb25zdCB3ZWFrRXF1YWxzID0gKHJvdywgY29sdW1uSWQsIGZpbHRlclZhbHVlKSA9PiB7XG4gIHJldHVybiByb3cuZ2V0VmFsdWUoY29sdW1uSWQpID09IGZpbHRlclZhbHVlO1xufTtcbndlYWtFcXVhbHMuYXV0b1JlbW92ZSA9IHZhbCA9PiB0ZXN0RmFsc2V5KHZhbCk7XG5jb25zdCBpbk51bWJlclJhbmdlID0gKHJvdywgY29sdW1uSWQsIGZpbHRlclZhbHVlKSA9PiB7XG4gIGxldCBbbWluLCBtYXhdID0gZmlsdGVyVmFsdWU7XG4gIGNvbnN0IHJvd1ZhbHVlID0gcm93LmdldFZhbHVlKGNvbHVtbklkKTtcbiAgcmV0dXJuIHJvd1ZhbHVlID49IG1pbiAmJiByb3dWYWx1ZSA8PSBtYXg7XG59O1xuaW5OdW1iZXJSYW5nZS5yZXNvbHZlRmlsdGVyVmFsdWUgPSB2YWwgPT4ge1xuICBsZXQgW3Vuc2FmZU1pbiwgdW5zYWZlTWF4XSA9IHZhbDtcbiAgbGV0IHBhcnNlZE1pbiA9IHR5cGVvZiB1bnNhZmVNaW4gIT09ICdudW1iZXInID8gcGFyc2VGbG9hdCh1bnNhZmVNaW4pIDogdW5zYWZlTWluO1xuICBsZXQgcGFyc2VkTWF4ID0gdHlwZW9mIHVuc2FmZU1heCAhPT0gJ251bWJlcicgPyBwYXJzZUZsb2F0KHVuc2FmZU1heCkgOiB1bnNhZmVNYXg7XG4gIGxldCBtaW4gPSB1bnNhZmVNaW4gPT09IG51bGwgfHwgTnVtYmVyLmlzTmFOKHBhcnNlZE1pbikgPyAtSW5maW5pdHkgOiBwYXJzZWRNaW47XG4gIGxldCBtYXggPSB1bnNhZmVNYXggPT09IG51bGwgfHwgTnVtYmVyLmlzTmFOKHBhcnNlZE1heCkgPyBJbmZpbml0eSA6IHBhcnNlZE1heDtcbiAgaWYgKG1pbiA+IG1heCkge1xuICAgIGNvbnN0IHRlbXAgPSBtaW47XG4gICAgbWluID0gbWF4O1xuICAgIG1heCA9IHRlbXA7XG4gIH1cbiAgcmV0dXJuIFttaW4sIG1heF07XG59O1xuaW5OdW1iZXJSYW5nZS5hdXRvUmVtb3ZlID0gdmFsID0+IHRlc3RGYWxzZXkodmFsKSB8fCB0ZXN0RmFsc2V5KHZhbFswXSkgJiYgdGVzdEZhbHNleSh2YWxbMV0pO1xuXG4vLyBFeHBvcnRcblxuY29uc3QgZmlsdGVyRm5zID0ge1xuICBpbmNsdWRlc1N0cmluZyxcbiAgaW5jbHVkZXNTdHJpbmdTZW5zaXRpdmUsXG4gIGVxdWFsc1N0cmluZyxcbiAgYXJySW5jbHVkZXMsXG4gIGFyckluY2x1ZGVzQWxsLFxuICBhcnJJbmNsdWRlc1NvbWUsXG4gIGVxdWFscyxcbiAgd2Vha0VxdWFscyxcbiAgaW5OdW1iZXJSYW5nZVxufTtcbi8vIFV0aWxzXG5cbmZ1bmN0aW9uIHRlc3RGYWxzZXkodmFsKSB7XG4gIHJldHVybiB2YWwgPT09IHVuZGVmaW5lZCB8fCB2YWwgPT09IG51bGwgfHwgdmFsID09PSAnJztcbn1cblxuLy9cblxuY29uc3QgRmlsdGVycyA9IHtcbiAgZ2V0RGVmYXVsdENvbHVtbkRlZjogKCkgPT4ge1xuICAgIHJldHVybiB7XG4gICAgICBmaWx0ZXJGbjogJ2F1dG8nXG4gICAgfTtcbiAgfSxcbiAgZ2V0SW5pdGlhbFN0YXRlOiBzdGF0ZSA9PiB7XG4gICAgcmV0dXJuIHtcbiAgICAgIGNvbHVtbkZpbHRlcnM6IFtdLFxuICAgICAgZ2xvYmFsRmlsdGVyOiB1bmRlZmluZWQsXG4gICAgICAvLyBmaWx0ZXJzUHJvZ3Jlc3M6IDEsXG4gICAgICAvLyBmYWNldFByb2dyZXNzOiB7fSxcbiAgICAgIC4uLnN0YXRlXG4gICAgfTtcbiAgfSxcbiAgZ2V0RGVmYXVsdE9wdGlvbnM6IHRhYmxlID0+IHtcbiAgICByZXR1cm4ge1xuICAgICAgb25Db2x1bW5GaWx0ZXJzQ2hhbmdlOiBtYWtlU3RhdGVVcGRhdGVyKCdjb2x1bW5GaWx0ZXJzJywgdGFibGUpLFxuICAgICAgb25HbG9iYWxGaWx0ZXJDaGFuZ2U6IG1ha2VTdGF0ZVVwZGF0ZXIoJ2dsb2JhbEZpbHRlcicsIHRhYmxlKSxcbiAgICAgIGZpbHRlckZyb21MZWFmUm93czogZmFsc2UsXG4gICAgICBtYXhMZWFmUm93RmlsdGVyRGVwdGg6IDEwMCxcbiAgICAgIGdsb2JhbEZpbHRlckZuOiAnYXV0bycsXG4gICAgICBnZXRDb2x1bW5DYW5HbG9iYWxGaWx0ZXI6IGNvbHVtbiA9PiB7XG4gICAgICAgIHZhciBfdGFibGUkZ2V0Q29yZVJvd01vZGU7XG4gICAgICAgIGNvbnN0IHZhbHVlID0gKF90YWJsZSRnZXRDb3JlUm93TW9kZSA9IHRhYmxlLmdldENvcmVSb3dNb2RlbCgpLmZsYXRSb3dzWzBdKSA9PSBudWxsIHx8IChfdGFibGUkZ2V0Q29yZVJvd01vZGUgPSBfdGFibGUkZ2V0Q29yZVJvd01vZGUuX2dldEFsbENlbGxzQnlDb2x1bW5JZCgpW2NvbHVtbi5pZF0pID09IG51bGwgPyB2b2lkIDAgOiBfdGFibGUkZ2V0Q29yZVJvd01vZGUuZ2V0VmFsdWUoKTtcbiAgICAgICAgcmV0dXJuIHR5cGVvZiB2YWx1ZSA9PT0gJ3N0cmluZycgfHwgdHlwZW9mIHZhbHVlID09PSAnbnVtYmVyJztcbiAgICAgIH1cbiAgICB9O1xuICB9LFxuICBjcmVhdGVDb2x1bW46IChjb2x1bW4sIHRhYmxlKSA9PiB7XG4gICAgY29sdW1uLmdldEF1dG9GaWx0ZXJGbiA9ICgpID0+IHtcbiAgICAgIGNvbnN0IGZpcnN0Um93ID0gdGFibGUuZ2V0Q29yZVJvd01vZGVsKCkuZmxhdFJvd3NbMF07XG4gICAgICBjb25zdCB2YWx1ZSA9IGZpcnN0Um93ID09IG51bGwgPyB2b2lkIDAgOiBmaXJzdFJvdy5nZXRWYWx1ZShjb2x1bW4uaWQpO1xuICAgICAgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgcmV0dXJuIGZpbHRlckZucy5pbmNsdWRlc1N0cmluZztcbiAgICAgIH1cbiAgICAgIGlmICh0eXBlb2YgdmFsdWUgPT09ICdudW1iZXInKSB7XG4gICAgICAgIHJldHVybiBmaWx0ZXJGbnMuaW5OdW1iZXJSYW5nZTtcbiAgICAgIH1cbiAgICAgIGlmICh0eXBlb2YgdmFsdWUgPT09ICdib29sZWFuJykge1xuICAgICAgICByZXR1cm4gZmlsdGVyRm5zLmVxdWFscztcbiAgICAgIH1cbiAgICAgIGlmICh2YWx1ZSAhPT0gbnVsbCAmJiB0eXBlb2YgdmFsdWUgPT09ICdvYmplY3QnKSB7XG4gICAgICAgIHJldHVybiBmaWx0ZXJGbnMuZXF1YWxzO1xuICAgICAgfVxuICAgICAgaWYgKEFycmF5LmlzQXJyYXkodmFsdWUpKSB7XG4gICAgICAgIHJldHVybiBmaWx0ZXJGbnMuYXJySW5jbHVkZXM7XG4gICAgICB9XG4gICAgICByZXR1cm4gZmlsdGVyRm5zLndlYWtFcXVhbHM7XG4gICAgfTtcbiAgICBjb2x1bW4uZ2V0RmlsdGVyRm4gPSAoKSA9PiB7XG4gICAgICB2YXIgX3RhYmxlJG9wdGlvbnMkZmlsdGVyLCBfdGFibGUkb3B0aW9ucyRmaWx0ZXIyO1xuICAgICAgcmV0dXJuIGlzRnVuY3Rpb24oY29sdW1uLmNvbHVtbkRlZi5maWx0ZXJGbikgPyBjb2x1bW4uY29sdW1uRGVmLmZpbHRlckZuIDogY29sdW1uLmNvbHVtbkRlZi5maWx0ZXJGbiA9PT0gJ2F1dG8nID8gY29sdW1uLmdldEF1dG9GaWx0ZXJGbigpIDogLy8gQHRzLWlnbm9yZVxuICAgICAgKF90YWJsZSRvcHRpb25zJGZpbHRlciA9IChfdGFibGUkb3B0aW9ucyRmaWx0ZXIyID0gdGFibGUub3B0aW9ucy5maWx0ZXJGbnMpID09IG51bGwgPyB2b2lkIDAgOiBfdGFibGUkb3B0aW9ucyRmaWx0ZXIyW2NvbHVtbi5jb2x1bW5EZWYuZmlsdGVyRm5dKSAhPSBudWxsID8gX3RhYmxlJG9wdGlvbnMkZmlsdGVyIDogZmlsdGVyRm5zW2NvbHVtbi5jb2x1bW5EZWYuZmlsdGVyRm5dO1xuICAgIH07XG4gICAgY29sdW1uLmdldENhbkZpbHRlciA9ICgpID0+IHtcbiAgICAgIHZhciBfY29sdW1uJGNvbHVtbkRlZiRlbmEsIF90YWJsZSRvcHRpb25zJGVuYWJsZSwgX3RhYmxlJG9wdGlvbnMkZW5hYmxlMjtcbiAgICAgIHJldHVybiAoKF9jb2x1bW4kY29sdW1uRGVmJGVuYSA9IGNvbHVtbi5jb2x1bW5EZWYuZW5hYmxlQ29sdW1uRmlsdGVyKSAhPSBudWxsID8gX2NvbHVtbiRjb2x1bW5EZWYkZW5hIDogdHJ1ZSkgJiYgKChfdGFibGUkb3B0aW9ucyRlbmFibGUgPSB0YWJsZS5vcHRpb25zLmVuYWJsZUNvbHVtbkZpbHRlcnMpICE9IG51bGwgPyBfdGFibGUkb3B0aW9ucyRlbmFibGUgOiB0cnVlKSAmJiAoKF90YWJsZSRvcHRpb25zJGVuYWJsZTIgPSB0YWJsZS5vcHRpb25zLmVuYWJsZUZpbHRlcnMpICE9IG51bGwgPyBfdGFibGUkb3B0aW9ucyRlbmFibGUyIDogdHJ1ZSkgJiYgISFjb2x1bW4uYWNjZXNzb3JGbjtcbiAgICB9O1xuICAgIGNvbHVtbi5nZXRDYW5HbG9iYWxGaWx0ZXIgPSAoKSA9PiB7XG4gICAgICB2YXIgX2NvbHVtbiRjb2x1bW5EZWYkZW5hMiwgX3RhYmxlJG9wdGlvbnMkZW5hYmxlMywgX3RhYmxlJG9wdGlvbnMkZW5hYmxlNCwgX3RhYmxlJG9wdGlvbnMkZ2V0Q29sO1xuICAgICAgcmV0dXJuICgoX2NvbHVtbiRjb2x1bW5EZWYkZW5hMiA9IGNvbHVtbi5jb2x1bW5EZWYuZW5hYmxlR2xvYmFsRmlsdGVyKSAhPSBudWxsID8gX2NvbHVtbiRjb2x1bW5EZWYkZW5hMiA6IHRydWUpICYmICgoX3RhYmxlJG9wdGlvbnMkZW5hYmxlMyA9IHRhYmxlLm9wdGlvbnMuZW5hYmxlR2xvYmFsRmlsdGVyKSAhPSBudWxsID8gX3RhYmxlJG9wdGlvbnMkZW5hYmxlMyA6IHRydWUpICYmICgoX3RhYmxlJG9wdGlvbnMkZW5hYmxlNCA9IHRhYmxlLm9wdGlvbnMuZW5hYmxlRmlsdGVycykgIT0gbnVsbCA/IF90YWJsZSRvcHRpb25zJGVuYWJsZTQgOiB0cnVlKSAmJiAoKF90YWJsZSRvcHRpb25zJGdldENvbCA9IHRhYmxlLm9wdGlvbnMuZ2V0Q29sdW1uQ2FuR2xvYmFsRmlsdGVyID09IG51bGwgPyB2b2lkIDAgOiB0YWJsZS5vcHRpb25zLmdldENvbHVtbkNhbkdsb2JhbEZpbHRlcihjb2x1bW4pKSAhPSBudWxsID8gX3RhYmxlJG9wdGlvbnMkZ2V0Q29sIDogdHJ1ZSkgJiYgISFjb2x1bW4uYWNjZXNzb3JGbjtcbiAgICB9O1xuICAgIGNvbHVtbi5nZXRJc0ZpbHRlcmVkID0gKCkgPT4gY29sdW1uLmdldEZpbHRlckluZGV4KCkgPiAtMTtcbiAgICBjb2x1bW4uZ2V0RmlsdGVyVmFsdWUgPSAoKSA9PiB7XG4gICAgICB2YXIgX3RhYmxlJGdldFN0YXRlJGNvbHVtO1xuICAgICAgcmV0dXJuIChfdGFibGUkZ2V0U3RhdGUkY29sdW0gPSB0YWJsZS5nZXRTdGF0ZSgpLmNvbHVtbkZpbHRlcnMpID09IG51bGwgfHwgKF90YWJsZSRnZXRTdGF0ZSRjb2x1bSA9IF90YWJsZSRnZXRTdGF0ZSRjb2x1bS5maW5kKGQgPT4gZC5pZCA9PT0gY29sdW1uLmlkKSkgPT0gbnVsbCA/IHZvaWQgMCA6IF90YWJsZSRnZXRTdGF0ZSRjb2x1bS52YWx1ZTtcbiAgICB9O1xuICAgIGNvbHVtbi5nZXRGaWx0ZXJJbmRleCA9ICgpID0+IHtcbiAgICAgIHZhciBfdGFibGUkZ2V0U3RhdGUkY29sdW0yLCBfdGFibGUkZ2V0U3RhdGUkY29sdW0zO1xuICAgICAgcmV0dXJuIChfdGFibGUkZ2V0U3RhdGUkY29sdW0yID0gKF90YWJsZSRnZXRTdGF0ZSRjb2x1bTMgPSB0YWJsZS5nZXRTdGF0ZSgpLmNvbHVtbkZpbHRlcnMpID09IG51bGwgPyB2b2lkIDAgOiBfdGFibGUkZ2V0U3RhdGUkY29sdW0zLmZpbmRJbmRleChkID0+IGQuaWQgPT09IGNvbHVtbi5pZCkpICE9IG51bGwgPyBfdGFibGUkZ2V0U3RhdGUkY29sdW0yIDogLTE7XG4gICAgfTtcbiAgICBjb2x1bW4uc2V0RmlsdGVyVmFsdWUgPSB2YWx1ZSA9PiB7XG4gICAgICB0YWJsZS5zZXRDb2x1bW5GaWx0ZXJzKG9sZCA9PiB7XG4gICAgICAgIGNvbnN0IGZpbHRlckZuID0gY29sdW1uLmdldEZpbHRlckZuKCk7XG4gICAgICAgIGNvbnN0IHByZXZpb3VzZmlsdGVyID0gb2xkID09IG51bGwgPyB2b2lkIDAgOiBvbGQuZmluZChkID0+IGQuaWQgPT09IGNvbHVtbi5pZCk7XG4gICAgICAgIGNvbnN0IG5ld0ZpbHRlciA9IGZ1bmN0aW9uYWxVcGRhdGUodmFsdWUsIHByZXZpb3VzZmlsdGVyID8gcHJldmlvdXNmaWx0ZXIudmFsdWUgOiB1bmRlZmluZWQpO1xuXG4gICAgICAgIC8vXG4gICAgICAgIGlmIChzaG91bGRBdXRvUmVtb3ZlRmlsdGVyKGZpbHRlckZuLCBuZXdGaWx0ZXIsIGNvbHVtbikpIHtcbiAgICAgICAgICB2YXIgX29sZCRmaWx0ZXI7XG4gICAgICAgICAgcmV0dXJuIChfb2xkJGZpbHRlciA9IG9sZCA9PSBudWxsID8gdm9pZCAwIDogb2xkLmZpbHRlcihkID0+IGQuaWQgIT09IGNvbHVtbi5pZCkpICE9IG51bGwgPyBfb2xkJGZpbHRlciA6IFtdO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IG5ld0ZpbHRlck9iaiA9IHtcbiAgICAgICAgICBpZDogY29sdW1uLmlkLFxuICAgICAgICAgIHZhbHVlOiBuZXdGaWx0ZXJcbiAgICAgICAgfTtcbiAgICAgICAgaWYgKHByZXZpb3VzZmlsdGVyKSB7XG4gICAgICAgICAgdmFyIF9vbGQkbWFwO1xuICAgICAgICAgIHJldHVybiAoX29sZCRtYXAgPSBvbGQgPT0gbnVsbCA/IHZvaWQgMCA6IG9sZC5tYXAoZCA9PiB7XG4gICAgICAgICAgICBpZiAoZC5pZCA9PT0gY29sdW1uLmlkKSB7XG4gICAgICAgICAgICAgIHJldHVybiBuZXdGaWx0ZXJPYmo7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gZDtcbiAgICAgICAgICB9KSkgIT0gbnVsbCA/IF9vbGQkbWFwIDogW107XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG9sZCAhPSBudWxsICYmIG9sZC5sZW5ndGgpIHtcbiAgICAgICAgICByZXR1cm4gWy4uLm9sZCwgbmV3RmlsdGVyT2JqXTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gW25ld0ZpbHRlck9ial07XG4gICAgICB9KTtcbiAgICB9O1xuICAgIGNvbHVtbi5fZ2V0RmFjZXRlZFJvd01vZGVsID0gdGFibGUub3B0aW9ucy5nZXRGYWNldGVkUm93TW9kZWwgJiYgdGFibGUub3B0aW9ucy5nZXRGYWNldGVkUm93TW9kZWwodGFibGUsIGNvbHVtbi5pZCk7XG4gICAgY29sdW1uLmdldEZhY2V0ZWRSb3dNb2RlbCA9ICgpID0+IHtcbiAgICAgIGlmICghY29sdW1uLl9nZXRGYWNldGVkUm93TW9kZWwpIHtcbiAgICAgICAgcmV0dXJuIHRhYmxlLmdldFByZUZpbHRlcmVkUm93TW9kZWwoKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBjb2x1bW4uX2dldEZhY2V0ZWRSb3dNb2RlbCgpO1xuICAgIH07XG4gICAgY29sdW1uLl9nZXRGYWNldGVkVW5pcXVlVmFsdWVzID0gdGFibGUub3B0aW9ucy5nZXRGYWNldGVkVW5pcXVlVmFsdWVzICYmIHRhYmxlLm9wdGlvbnMuZ2V0RmFjZXRlZFVuaXF1ZVZhbHVlcyh0YWJsZSwgY29sdW1uLmlkKTtcbiAgICBjb2x1bW4uZ2V0RmFjZXRlZFVuaXF1ZVZhbHVlcyA9ICgpID0+IHtcbiAgICAgIGlmICghY29sdW1uLl9nZXRGYWNldGVkVW5pcXVlVmFsdWVzKSB7XG4gICAgICAgIHJldHVybiBuZXcgTWFwKCk7XG4gICAgICB9XG4gICAgICByZXR1cm4gY29sdW1uLl9nZXRGYWNldGVkVW5pcXVlVmFsdWVzKCk7XG4gICAgfTtcbiAgICBjb2x1bW4uX2dldEZhY2V0ZWRNaW5NYXhWYWx1ZXMgPSB0YWJsZS5vcHRpb25zLmdldEZhY2V0ZWRNaW5NYXhWYWx1ZXMgJiYgdGFibGUub3B0aW9ucy5nZXRGYWNldGVkTWluTWF4VmFsdWVzKHRhYmxlLCBjb2x1bW4uaWQpO1xuICAgIGNvbHVtbi5nZXRGYWNldGVkTWluTWF4VmFsdWVzID0gKCkgPT4ge1xuICAgICAgaWYgKCFjb2x1bW4uX2dldEZhY2V0ZWRNaW5NYXhWYWx1ZXMpIHtcbiAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICAgIH1cbiAgICAgIHJldHVybiBjb2x1bW4uX2dldEZhY2V0ZWRNaW5NYXhWYWx1ZXMoKTtcbiAgICB9O1xuICAgIC8vICgpID0+IFtjb2x1bW4uZ2V0RmFjZXRlZFJvd01vZGVsKCldLFxuICAgIC8vIGZhY2V0ZWRSb3dNb2RlbCA9PiBnZXRSb3dNb2RlbE1pbk1heFZhbHVlcyhmYWNldGVkUm93TW9kZWwsIGNvbHVtbi5pZCksXG4gIH0sXG4gIGNyZWF0ZVJvdzogKHJvdywgdGFibGUpID0+IHtcbiAgICByb3cuY29sdW1uRmlsdGVycyA9IHt9O1xuICAgIHJvdy5jb2x1bW5GaWx0ZXJzTWV0YSA9IHt9O1xuICB9LFxuICBjcmVhdGVUYWJsZTogdGFibGUgPT4ge1xuICAgIHRhYmxlLmdldEdsb2JhbEF1dG9GaWx0ZXJGbiA9ICgpID0+IHtcbiAgICAgIHJldHVybiBmaWx0ZXJGbnMuaW5jbHVkZXNTdHJpbmc7XG4gICAgfTtcbiAgICB0YWJsZS5nZXRHbG9iYWxGaWx0ZXJGbiA9ICgpID0+IHtcbiAgICAgIHZhciBfdGFibGUkb3B0aW9ucyRmaWx0ZXIzLCBfdGFibGUkb3B0aW9ucyRmaWx0ZXI0O1xuICAgICAgY29uc3Qge1xuICAgICAgICBnbG9iYWxGaWx0ZXJGbjogZ2xvYmFsRmlsdGVyRm5cbiAgICAgIH0gPSB0YWJsZS5vcHRpb25zO1xuICAgICAgcmV0dXJuIGlzRnVuY3Rpb24oZ2xvYmFsRmlsdGVyRm4pID8gZ2xvYmFsRmlsdGVyRm4gOiBnbG9iYWxGaWx0ZXJGbiA9PT0gJ2F1dG8nID8gdGFibGUuZ2V0R2xvYmFsQXV0b0ZpbHRlckZuKCkgOiAvLyBAdHMtaWdub3JlXG4gICAgICAoX3RhYmxlJG9wdGlvbnMkZmlsdGVyMyA9IChfdGFibGUkb3B0aW9ucyRmaWx0ZXI0ID0gdGFibGUub3B0aW9ucy5maWx0ZXJGbnMpID09IG51bGwgPyB2b2lkIDAgOiBfdGFibGUkb3B0aW9ucyRmaWx0ZXI0W2dsb2JhbEZpbHRlckZuXSkgIT0gbnVsbCA/IF90YWJsZSRvcHRpb25zJGZpbHRlcjMgOiBmaWx0ZXJGbnNbZ2xvYmFsRmlsdGVyRm5dO1xuICAgIH07XG4gICAgdGFibGUuc2V0Q29sdW1uRmlsdGVycyA9IHVwZGF0ZXIgPT4ge1xuICAgICAgY29uc3QgbGVhZkNvbHVtbnMgPSB0YWJsZS5nZXRBbGxMZWFmQ29sdW1ucygpO1xuICAgICAgY29uc3QgdXBkYXRlRm4gPSBvbGQgPT4ge1xuICAgICAgICB2YXIgX2Z1bmN0aW9uYWxVcGRhdGU7XG4gICAgICAgIHJldHVybiAoX2Z1bmN0aW9uYWxVcGRhdGUgPSBmdW5jdGlvbmFsVXBkYXRlKHVwZGF0ZXIsIG9sZCkpID09IG51bGwgPyB2b2lkIDAgOiBfZnVuY3Rpb25hbFVwZGF0ZS5maWx0ZXIoZmlsdGVyID0+IHtcbiAgICAgICAgICBjb25zdCBjb2x1bW4gPSBsZWFmQ29sdW1ucy5maW5kKGQgPT4gZC5pZCA9PT0gZmlsdGVyLmlkKTtcbiAgICAgICAgICBpZiAoY29sdW1uKSB7XG4gICAgICAgICAgICBjb25zdCBmaWx0ZXJGbiA9IGNvbHVtbi5nZXRGaWx0ZXJGbigpO1xuICAgICAgICAgICAgaWYgKHNob3VsZEF1dG9SZW1vdmVGaWx0ZXIoZmlsdGVyRm4sIGZpbHRlci52YWx1ZSwgY29sdW1uKSkge1xuICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9KTtcbiAgICAgIH07XG4gICAgICB0YWJsZS5vcHRpb25zLm9uQ29sdW1uRmlsdGVyc0NoYW5nZSA9PSBudWxsIHx8IHRhYmxlLm9wdGlvbnMub25Db2x1bW5GaWx0ZXJzQ2hhbmdlKHVwZGF0ZUZuKTtcbiAgICB9O1xuICAgIHRhYmxlLnNldEdsb2JhbEZpbHRlciA9IHVwZGF0ZXIgPT4ge1xuICAgICAgdGFibGUub3B0aW9ucy5vbkdsb2JhbEZpbHRlckNoYW5nZSA9PSBudWxsIHx8IHRhYmxlLm9wdGlvbnMub25HbG9iYWxGaWx0ZXJDaGFuZ2UodXBkYXRlcik7XG4gICAgfTtcbiAgICB0YWJsZS5yZXNldEdsb2JhbEZpbHRlciA9IGRlZmF1bHRTdGF0ZSA9PiB7XG4gICAgICB0YWJsZS5zZXRHbG9iYWxGaWx0ZXIoZGVmYXVsdFN0YXRlID8gdW5kZWZpbmVkIDogdGFibGUuaW5pdGlhbFN0YXRlLmdsb2JhbEZpbHRlcik7XG4gICAgfTtcbiAgICB0YWJsZS5yZXNldENvbHVtbkZpbHRlcnMgPSBkZWZhdWx0U3RhdGUgPT4ge1xuICAgICAgdmFyIF90YWJsZSRpbml0aWFsU3RhdGUkYywgX3RhYmxlJGluaXRpYWxTdGF0ZTtcbiAgICAgIHRhYmxlLnNldENvbHVtbkZpbHRlcnMoZGVmYXVsdFN0YXRlID8gW10gOiAoX3RhYmxlJGluaXRpYWxTdGF0ZSRjID0gKF90YWJsZSRpbml0aWFsU3RhdGUgPSB0YWJsZS5pbml0aWFsU3RhdGUpID09IG51bGwgPyB2b2lkIDAgOiBfdGFibGUkaW5pdGlhbFN0YXRlLmNvbHVtbkZpbHRlcnMpICE9IG51bGwgPyBfdGFibGUkaW5pdGlhbFN0YXRlJGMgOiBbXSk7XG4gICAgfTtcbiAgICB0YWJsZS5nZXRQcmVGaWx0ZXJlZFJvd01vZGVsID0gKCkgPT4gdGFibGUuZ2V0Q29yZVJvd01vZGVsKCk7XG4gICAgdGFibGUuZ2V0RmlsdGVyZWRSb3dNb2RlbCA9ICgpID0+IHtcbiAgICAgIGlmICghdGFibGUuX2dldEZpbHRlcmVkUm93TW9kZWwgJiYgdGFibGUub3B0aW9ucy5nZXRGaWx0ZXJlZFJvd01vZGVsKSB7XG4gICAgICAgIHRhYmxlLl9nZXRGaWx0ZXJlZFJvd01vZGVsID0gdGFibGUub3B0aW9ucy5nZXRGaWx0ZXJlZFJvd01vZGVsKHRhYmxlKTtcbiAgICAgIH1cbiAgICAgIGlmICh0YWJsZS5vcHRpb25zLm1hbnVhbEZpbHRlcmluZyB8fCAhdGFibGUuX2dldEZpbHRlcmVkUm93TW9kZWwpIHtcbiAgICAgICAgcmV0dXJuIHRhYmxlLmdldFByZUZpbHRlcmVkUm93TW9kZWwoKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiB0YWJsZS5fZ2V0RmlsdGVyZWRSb3dNb2RlbCgpO1xuICAgIH07XG4gICAgdGFibGUuX2dldEdsb2JhbEZhY2V0ZWRSb3dNb2RlbCA9IHRhYmxlLm9wdGlvbnMuZ2V0RmFjZXRlZFJvd01vZGVsICYmIHRhYmxlLm9wdGlvbnMuZ2V0RmFjZXRlZFJvd01vZGVsKHRhYmxlLCAnX19nbG9iYWxfXycpO1xuICAgIHRhYmxlLmdldEdsb2JhbEZhY2V0ZWRSb3dNb2RlbCA9ICgpID0+IHtcbiAgICAgIGlmICh0YWJsZS5vcHRpb25zLm1hbnVhbEZpbHRlcmluZyB8fCAhdGFibGUuX2dldEdsb2JhbEZhY2V0ZWRSb3dNb2RlbCkge1xuICAgICAgICByZXR1cm4gdGFibGUuZ2V0UHJlRmlsdGVyZWRSb3dNb2RlbCgpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHRhYmxlLl9nZXRHbG9iYWxGYWNldGVkUm93TW9kZWwoKTtcbiAgICB9O1xuICAgIHRhYmxlLl9nZXRHbG9iYWxGYWNldGVkVW5pcXVlVmFsdWVzID0gdGFibGUub3B0aW9ucy5nZXRGYWNldGVkVW5pcXVlVmFsdWVzICYmIHRhYmxlLm9wdGlvbnMuZ2V0RmFjZXRlZFVuaXF1ZVZhbHVlcyh0YWJsZSwgJ19fZ2xvYmFsX18nKTtcbiAgICB0YWJsZS5nZXRHbG9iYWxGYWNldGVkVW5pcXVlVmFsdWVzID0gKCkgPT4ge1xuICAgICAgaWYgKCF0YWJsZS5fZ2V0R2xvYmFsRmFjZXRlZFVuaXF1ZVZhbHVlcykge1xuICAgICAgICByZXR1cm4gbmV3IE1hcCgpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHRhYmxlLl9nZXRHbG9iYWxGYWNldGVkVW5pcXVlVmFsdWVzKCk7XG4gICAgfTtcbiAgICB0YWJsZS5fZ2V0R2xvYmFsRmFjZXRlZE1pbk1heFZhbHVlcyA9IHRhYmxlLm9wdGlvbnMuZ2V0RmFjZXRlZE1pbk1heFZhbHVlcyAmJiB0YWJsZS5vcHRpb25zLmdldEZhY2V0ZWRNaW5NYXhWYWx1ZXModGFibGUsICdfX2dsb2JhbF9fJyk7XG4gICAgdGFibGUuZ2V0R2xvYmFsRmFjZXRlZE1pbk1heFZhbHVlcyA9ICgpID0+IHtcbiAgICAgIGlmICghdGFibGUuX2dldEdsb2JhbEZhY2V0ZWRNaW5NYXhWYWx1ZXMpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHRhYmxlLl9nZXRHbG9iYWxGYWNldGVkTWluTWF4VmFsdWVzKCk7XG4gICAgfTtcbiAgfVxufTtcbmZ1bmN0aW9uIHNob3VsZEF1dG9SZW1vdmVGaWx0ZXIoZmlsdGVyRm4sIHZhbHVlLCBjb2x1bW4pIHtcbiAgcmV0dXJuIChmaWx0ZXJGbiAmJiBmaWx0ZXJGbi5hdXRvUmVtb3ZlID8gZmlsdGVyRm4uYXV0b1JlbW92ZSh2YWx1ZSwgY29sdW1uKSA6IGZhbHNlKSB8fCB0eXBlb2YgdmFsdWUgPT09ICd1bmRlZmluZWQnIHx8IHR5cGVvZiB2YWx1ZSA9PT0gJ3N0cmluZycgJiYgIXZhbHVlO1xufVxuXG5jb25zdCBzdW0gPSAoY29sdW1uSWQsIF9sZWFmUm93cywgY2hpbGRSb3dzKSA9PiB7XG4gIC8vIEl0J3MgZmFzdGVyIHRvIGp1c3QgYWRkIHRoZSBhZ2dyZWdhdGlvbnMgdG9nZXRoZXIgaW5zdGVhZCBvZlxuICAvLyBwcm9jZXNzIGxlYWYgbm9kZXMgaW5kaXZpZHVhbGx5XG4gIHJldHVybiBjaGlsZFJvd3MucmVkdWNlKChzdW0sIG5leHQpID0+IHtcbiAgICBjb25zdCBuZXh0VmFsdWUgPSBuZXh0LmdldFZhbHVlKGNvbHVtbklkKTtcbiAgICByZXR1cm4gc3VtICsgKHR5cGVvZiBuZXh0VmFsdWUgPT09ICdudW1iZXInID8gbmV4dFZhbHVlIDogMCk7XG4gIH0sIDApO1xufTtcbmNvbnN0IG1pbiA9IChjb2x1bW5JZCwgX2xlYWZSb3dzLCBjaGlsZFJvd3MpID0+IHtcbiAgbGV0IG1pbjtcbiAgY2hpbGRSb3dzLmZvckVhY2gocm93ID0+IHtcbiAgICBjb25zdCB2YWx1ZSA9IHJvdy5nZXRWYWx1ZShjb2x1bW5JZCk7XG4gICAgaWYgKHZhbHVlICE9IG51bGwgJiYgKG1pbiA+IHZhbHVlIHx8IG1pbiA9PT0gdW5kZWZpbmVkICYmIHZhbHVlID49IHZhbHVlKSkge1xuICAgICAgbWluID0gdmFsdWU7XG4gICAgfVxuICB9KTtcbiAgcmV0dXJuIG1pbjtcbn07XG5jb25zdCBtYXggPSAoY29sdW1uSWQsIF9sZWFmUm93cywgY2hpbGRSb3dzKSA9PiB7XG4gIGxldCBtYXg7XG4gIGNoaWxkUm93cy5mb3JFYWNoKHJvdyA9PiB7XG4gICAgY29uc3QgdmFsdWUgPSByb3cuZ2V0VmFsdWUoY29sdW1uSWQpO1xuICAgIGlmICh2YWx1ZSAhPSBudWxsICYmIChtYXggPCB2YWx1ZSB8fCBtYXggPT09IHVuZGVmaW5lZCAmJiB2YWx1ZSA+PSB2YWx1ZSkpIHtcbiAgICAgIG1heCA9IHZhbHVlO1xuICAgIH1cbiAgfSk7XG4gIHJldHVybiBtYXg7XG59O1xuY29uc3QgZXh0ZW50ID0gKGNvbHVtbklkLCBfbGVhZlJvd3MsIGNoaWxkUm93cykgPT4ge1xuICBsZXQgbWluO1xuICBsZXQgbWF4O1xuICBjaGlsZFJvd3MuZm9yRWFjaChyb3cgPT4ge1xuICAgIGNvbnN0IHZhbHVlID0gcm93LmdldFZhbHVlKGNvbHVtbklkKTtcbiAgICBpZiAodmFsdWUgIT0gbnVsbCkge1xuICAgICAgaWYgKG1pbiA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIGlmICh2YWx1ZSA+PSB2YWx1ZSkgbWluID0gbWF4ID0gdmFsdWU7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBpZiAobWluID4gdmFsdWUpIG1pbiA9IHZhbHVlO1xuICAgICAgICBpZiAobWF4IDwgdmFsdWUpIG1heCA9IHZhbHVlO1xuICAgICAgfVxuICAgIH1cbiAgfSk7XG4gIHJldHVybiBbbWluLCBtYXhdO1xufTtcbmNvbnN0IG1lYW4gPSAoY29sdW1uSWQsIGxlYWZSb3dzKSA9PiB7XG4gIGxldCBjb3VudCA9IDA7XG4gIGxldCBzdW0gPSAwO1xuICBsZWFmUm93cy5mb3JFYWNoKHJvdyA9PiB7XG4gICAgbGV0IHZhbHVlID0gcm93LmdldFZhbHVlKGNvbHVtbklkKTtcbiAgICBpZiAodmFsdWUgIT0gbnVsbCAmJiAodmFsdWUgPSArdmFsdWUpID49IHZhbHVlKSB7XG4gICAgICArK2NvdW50LCBzdW0gKz0gdmFsdWU7XG4gICAgfVxuICB9KTtcbiAgaWYgKGNvdW50KSByZXR1cm4gc3VtIC8gY291bnQ7XG4gIHJldHVybjtcbn07XG5jb25zdCBtZWRpYW4gPSAoY29sdW1uSWQsIGxlYWZSb3dzKSA9PiB7XG4gIGlmICghbGVhZlJvd3MubGVuZ3RoKSB7XG4gICAgcmV0dXJuO1xuICB9XG4gIGNvbnN0IHZhbHVlcyA9IGxlYWZSb3dzLm1hcChyb3cgPT4gcm93LmdldFZhbHVlKGNvbHVtbklkKSk7XG4gIGlmICghaXNOdW1iZXJBcnJheSh2YWx1ZXMpKSB7XG4gICAgcmV0dXJuO1xuICB9XG4gIGlmICh2YWx1ZXMubGVuZ3RoID09PSAxKSB7XG4gICAgcmV0dXJuIHZhbHVlc1swXTtcbiAgfVxuICBjb25zdCBtaWQgPSBNYXRoLmZsb29yKHZhbHVlcy5sZW5ndGggLyAyKTtcbiAgY29uc3QgbnVtcyA9IHZhbHVlcy5zb3J0KChhLCBiKSA9PiBhIC0gYik7XG4gIHJldHVybiB2YWx1ZXMubGVuZ3RoICUgMiAhPT0gMCA/IG51bXNbbWlkXSA6IChudW1zW21pZCAtIDFdICsgbnVtc1ttaWRdKSAvIDI7XG59O1xuY29uc3QgdW5pcXVlID0gKGNvbHVtbklkLCBsZWFmUm93cykgPT4ge1xuICByZXR1cm4gQXJyYXkuZnJvbShuZXcgU2V0KGxlYWZSb3dzLm1hcChkID0+IGQuZ2V0VmFsdWUoY29sdW1uSWQpKSkudmFsdWVzKCkpO1xufTtcbmNvbnN0IHVuaXF1ZUNvdW50ID0gKGNvbHVtbklkLCBsZWFmUm93cykgPT4ge1xuICByZXR1cm4gbmV3IFNldChsZWFmUm93cy5tYXAoZCA9PiBkLmdldFZhbHVlKGNvbHVtbklkKSkpLnNpemU7XG59O1xuY29uc3QgY291bnQgPSAoX2NvbHVtbklkLCBsZWFmUm93cykgPT4ge1xuICByZXR1cm4gbGVhZlJvd3MubGVuZ3RoO1xufTtcbmNvbnN0IGFnZ3JlZ2F0aW9uRm5zID0ge1xuICBzdW0sXG4gIG1pbixcbiAgbWF4LFxuICBleHRlbnQsXG4gIG1lYW4sXG4gIG1lZGlhbixcbiAgdW5pcXVlLFxuICB1bmlxdWVDb3VudCxcbiAgY291bnRcbn07XG5cbi8vXG5cbmNvbnN0IEdyb3VwaW5nID0ge1xuICBnZXREZWZhdWx0Q29sdW1uRGVmOiAoKSA9PiB7XG4gICAgcmV0dXJuIHtcbiAgICAgIGFnZ3JlZ2F0ZWRDZWxsOiBwcm9wcyA9PiB7XG4gICAgICAgIHZhciBfdG9TdHJpbmcsIF9wcm9wcyRnZXRWYWx1ZTtcbiAgICAgICAgcmV0dXJuIChfdG9TdHJpbmcgPSAoX3Byb3BzJGdldFZhbHVlID0gcHJvcHMuZ2V0VmFsdWUoKSkgPT0gbnVsbCB8fCBfcHJvcHMkZ2V0VmFsdWUudG9TdHJpbmcgPT0gbnVsbCA/IHZvaWQgMCA6IF9wcm9wcyRnZXRWYWx1ZS50b1N0cmluZygpKSAhPSBudWxsID8gX3RvU3RyaW5nIDogbnVsbDtcbiAgICAgIH0sXG4gICAgICBhZ2dyZWdhdGlvbkZuOiAnYXV0bydcbiAgICB9O1xuICB9LFxuICBnZXRJbml0aWFsU3RhdGU6IHN0YXRlID0+IHtcbiAgICByZXR1cm4ge1xuICAgICAgZ3JvdXBpbmc6IFtdLFxuICAgICAgLi4uc3RhdGVcbiAgICB9O1xuICB9LFxuICBnZXREZWZhdWx0T3B0aW9uczogdGFibGUgPT4ge1xuICAgIHJldHVybiB7XG4gICAgICBvbkdyb3VwaW5nQ2hhbmdlOiBtYWtlU3RhdGVVcGRhdGVyKCdncm91cGluZycsIHRhYmxlKSxcbiAgICAgIGdyb3VwZWRDb2x1bW5Nb2RlOiAncmVvcmRlcidcbiAgICB9O1xuICB9LFxuICBjcmVhdGVDb2x1bW46IChjb2x1bW4sIHRhYmxlKSA9PiB7XG4gICAgY29sdW1uLnRvZ2dsZUdyb3VwaW5nID0gKCkgPT4ge1xuICAgICAgdGFibGUuc2V0R3JvdXBpbmcob2xkID0+IHtcbiAgICAgICAgLy8gRmluZCBhbnkgZXhpc3RpbmcgZ3JvdXBpbmcgZm9yIHRoaXMgY29sdW1uXG4gICAgICAgIGlmIChvbGQgIT0gbnVsbCAmJiBvbGQuaW5jbHVkZXMoY29sdW1uLmlkKSkge1xuICAgICAgICAgIHJldHVybiBvbGQuZmlsdGVyKGQgPT4gZCAhPT0gY29sdW1uLmlkKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gWy4uLihvbGQgIT0gbnVsbCA/IG9sZCA6IFtdKSwgY29sdW1uLmlkXTtcbiAgICAgIH0pO1xuICAgIH07XG4gICAgY29sdW1uLmdldENhbkdyb3VwID0gKCkgPT4ge1xuICAgICAgdmFyIF9yZWYsIF9yZWYyLCBfcmVmMywgX2NvbHVtbiRjb2x1bW5EZWYkZW5hO1xuICAgICAgcmV0dXJuIChfcmVmID0gKF9yZWYyID0gKF9yZWYzID0gKF9jb2x1bW4kY29sdW1uRGVmJGVuYSA9IGNvbHVtbi5jb2x1bW5EZWYuZW5hYmxlR3JvdXBpbmcpICE9IG51bGwgPyBfY29sdW1uJGNvbHVtbkRlZiRlbmEgOiB0cnVlKSAhPSBudWxsID8gX3JlZjMgOiB0YWJsZS5vcHRpb25zLmVuYWJsZUdyb3VwaW5nKSAhPSBudWxsID8gX3JlZjIgOiB0cnVlKSAhPSBudWxsID8gX3JlZiA6ICEhY29sdW1uLmFjY2Vzc29yRm47XG4gICAgfTtcbiAgICBjb2x1bW4uZ2V0SXNHcm91cGVkID0gKCkgPT4ge1xuICAgICAgdmFyIF90YWJsZSRnZXRTdGF0ZSRncm91cDtcbiAgICAgIHJldHVybiAoX3RhYmxlJGdldFN0YXRlJGdyb3VwID0gdGFibGUuZ2V0U3RhdGUoKS5ncm91cGluZykgPT0gbnVsbCA/IHZvaWQgMCA6IF90YWJsZSRnZXRTdGF0ZSRncm91cC5pbmNsdWRlcyhjb2x1bW4uaWQpO1xuICAgIH07XG4gICAgY29sdW1uLmdldEdyb3VwZWRJbmRleCA9ICgpID0+IHtcbiAgICAgIHZhciBfdGFibGUkZ2V0U3RhdGUkZ3JvdXAyO1xuICAgICAgcmV0dXJuIChfdGFibGUkZ2V0U3RhdGUkZ3JvdXAyID0gdGFibGUuZ2V0U3RhdGUoKS5ncm91cGluZykgPT0gbnVsbCA/IHZvaWQgMCA6IF90YWJsZSRnZXRTdGF0ZSRncm91cDIuaW5kZXhPZihjb2x1bW4uaWQpO1xuICAgIH07XG4gICAgY29sdW1uLmdldFRvZ2dsZUdyb3VwaW5nSGFuZGxlciA9ICgpID0+IHtcbiAgICAgIGNvbnN0IGNhbkdyb3VwID0gY29sdW1uLmdldENhbkdyb3VwKCk7XG4gICAgICByZXR1cm4gKCkgPT4ge1xuICAgICAgICBpZiAoIWNhbkdyb3VwKSByZXR1cm47XG4gICAgICAgIGNvbHVtbi50b2dnbGVHcm91cGluZygpO1xuICAgICAgfTtcbiAgICB9O1xuICAgIGNvbHVtbi5nZXRBdXRvQWdncmVnYXRpb25GbiA9ICgpID0+IHtcbiAgICAgIGNvbnN0IGZpcnN0Um93ID0gdGFibGUuZ2V0Q29yZVJvd01vZGVsKCkuZmxhdFJvd3NbMF07XG4gICAgICBjb25zdCB2YWx1ZSA9IGZpcnN0Um93ID09IG51bGwgPyB2b2lkIDAgOiBmaXJzdFJvdy5nZXRWYWx1ZShjb2x1bW4uaWQpO1xuICAgICAgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gJ251bWJlcicpIHtcbiAgICAgICAgcmV0dXJuIGFnZ3JlZ2F0aW9uRm5zLnN1bTtcbiAgICAgIH1cbiAgICAgIGlmIChPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwodmFsdWUpID09PSAnW29iamVjdCBEYXRlXScpIHtcbiAgICAgICAgcmV0dXJuIGFnZ3JlZ2F0aW9uRm5zLmV4dGVudDtcbiAgICAgIH1cbiAgICB9O1xuICAgIGNvbHVtbi5nZXRBZ2dyZWdhdGlvbkZuID0gKCkgPT4ge1xuICAgICAgdmFyIF90YWJsZSRvcHRpb25zJGFnZ3JlZywgX3RhYmxlJG9wdGlvbnMkYWdncmVnMjtcbiAgICAgIGlmICghY29sdW1uKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcigpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGlzRnVuY3Rpb24oY29sdW1uLmNvbHVtbkRlZi5hZ2dyZWdhdGlvbkZuKSA/IGNvbHVtbi5jb2x1bW5EZWYuYWdncmVnYXRpb25GbiA6IGNvbHVtbi5jb2x1bW5EZWYuYWdncmVnYXRpb25GbiA9PT0gJ2F1dG8nID8gY29sdW1uLmdldEF1dG9BZ2dyZWdhdGlvbkZuKCkgOiAoX3RhYmxlJG9wdGlvbnMkYWdncmVnID0gKF90YWJsZSRvcHRpb25zJGFnZ3JlZzIgPSB0YWJsZS5vcHRpb25zLmFnZ3JlZ2F0aW9uRm5zKSA9PSBudWxsID8gdm9pZCAwIDogX3RhYmxlJG9wdGlvbnMkYWdncmVnMltjb2x1bW4uY29sdW1uRGVmLmFnZ3JlZ2F0aW9uRm5dKSAhPSBudWxsID8gX3RhYmxlJG9wdGlvbnMkYWdncmVnIDogYWdncmVnYXRpb25GbnNbY29sdW1uLmNvbHVtbkRlZi5hZ2dyZWdhdGlvbkZuXTtcbiAgICB9O1xuICB9LFxuICBjcmVhdGVUYWJsZTogdGFibGUgPT4ge1xuICAgIHRhYmxlLnNldEdyb3VwaW5nID0gdXBkYXRlciA9PiB0YWJsZS5vcHRpb25zLm9uR3JvdXBpbmdDaGFuZ2UgPT0gbnVsbCA/IHZvaWQgMCA6IHRhYmxlLm9wdGlvbnMub25Hcm91cGluZ0NoYW5nZSh1cGRhdGVyKTtcbiAgICB0YWJsZS5yZXNldEdyb3VwaW5nID0gZGVmYXVsdFN0YXRlID0+IHtcbiAgICAgIHZhciBfdGFibGUkaW5pdGlhbFN0YXRlJGcsIF90YWJsZSRpbml0aWFsU3RhdGU7XG4gICAgICB0YWJsZS5zZXRHcm91cGluZyhkZWZhdWx0U3RhdGUgPyBbXSA6IChfdGFibGUkaW5pdGlhbFN0YXRlJGcgPSAoX3RhYmxlJGluaXRpYWxTdGF0ZSA9IHRhYmxlLmluaXRpYWxTdGF0ZSkgPT0gbnVsbCA/IHZvaWQgMCA6IF90YWJsZSRpbml0aWFsU3RhdGUuZ3JvdXBpbmcpICE9IG51bGwgPyBfdGFibGUkaW5pdGlhbFN0YXRlJGcgOiBbXSk7XG4gICAgfTtcbiAgICB0YWJsZS5nZXRQcmVHcm91cGVkUm93TW9kZWwgPSAoKSA9PiB0YWJsZS5nZXRGaWx0ZXJlZFJvd01vZGVsKCk7XG4gICAgdGFibGUuZ2V0R3JvdXBlZFJvd01vZGVsID0gKCkgPT4ge1xuICAgICAgaWYgKCF0YWJsZS5fZ2V0R3JvdXBlZFJvd01vZGVsICYmIHRhYmxlLm9wdGlvbnMuZ2V0R3JvdXBlZFJvd01vZGVsKSB7XG4gICAgICAgIHRhYmxlLl9nZXRHcm91cGVkUm93TW9kZWwgPSB0YWJsZS5vcHRpb25zLmdldEdyb3VwZWRSb3dNb2RlbCh0YWJsZSk7XG4gICAgICB9XG4gICAgICBpZiAodGFibGUub3B0aW9ucy5tYW51YWxHcm91cGluZyB8fCAhdGFibGUuX2dldEdyb3VwZWRSb3dNb2RlbCkge1xuICAgICAgICByZXR1cm4gdGFibGUuZ2V0UHJlR3JvdXBlZFJvd01vZGVsKCk7XG4gICAgICB9XG4gICAgICByZXR1cm4gdGFibGUuX2dldEdyb3VwZWRSb3dNb2RlbCgpO1xuICAgIH07XG4gIH0sXG4gIGNyZWF0ZVJvdzogKHJvdywgdGFibGUpID0+IHtcbiAgICByb3cuZ2V0SXNHcm91cGVkID0gKCkgPT4gISFyb3cuZ3JvdXBpbmdDb2x1bW5JZDtcbiAgICByb3cuZ2V0R3JvdXBpbmdWYWx1ZSA9IGNvbHVtbklkID0+IHtcbiAgICAgIGlmIChyb3cuX2dyb3VwaW5nVmFsdWVzQ2FjaGUuaGFzT3duUHJvcGVydHkoY29sdW1uSWQpKSB7XG4gICAgICAgIHJldHVybiByb3cuX2dyb3VwaW5nVmFsdWVzQ2FjaGVbY29sdW1uSWRdO1xuICAgICAgfVxuICAgICAgY29uc3QgY29sdW1uID0gdGFibGUuZ2V0Q29sdW1uKGNvbHVtbklkKTtcbiAgICAgIGlmICghKGNvbHVtbiAhPSBudWxsICYmIGNvbHVtbi5jb2x1bW5EZWYuZ2V0R3JvdXBpbmdWYWx1ZSkpIHtcbiAgICAgICAgcmV0dXJuIHJvdy5nZXRWYWx1ZShjb2x1bW5JZCk7XG4gICAgICB9XG4gICAgICByb3cuX2dyb3VwaW5nVmFsdWVzQ2FjaGVbY29sdW1uSWRdID0gY29sdW1uLmNvbHVtbkRlZi5nZXRHcm91cGluZ1ZhbHVlKHJvdy5vcmlnaW5hbCk7XG4gICAgICByZXR1cm4gcm93Ll9ncm91cGluZ1ZhbHVlc0NhY2hlW2NvbHVtbklkXTtcbiAgICB9O1xuICAgIHJvdy5fZ3JvdXBpbmdWYWx1ZXNDYWNoZSA9IHt9O1xuICB9LFxuICBjcmVhdGVDZWxsOiAoY2VsbCwgY29sdW1uLCByb3csIHRhYmxlKSA9PiB7XG4gICAgY2VsbC5nZXRJc0dyb3VwZWQgPSAoKSA9PiBjb2x1bW4uZ2V0SXNHcm91cGVkKCkgJiYgY29sdW1uLmlkID09PSByb3cuZ3JvdXBpbmdDb2x1bW5JZDtcbiAgICBjZWxsLmdldElzUGxhY2Vob2xkZXIgPSAoKSA9PiAhY2VsbC5nZXRJc0dyb3VwZWQoKSAmJiBjb2x1bW4uZ2V0SXNHcm91cGVkKCk7XG4gICAgY2VsbC5nZXRJc0FnZ3JlZ2F0ZWQgPSAoKSA9PiB7XG4gICAgICB2YXIgX3JvdyRzdWJSb3dzO1xuICAgICAgcmV0dXJuICFjZWxsLmdldElzR3JvdXBlZCgpICYmICFjZWxsLmdldElzUGxhY2Vob2xkZXIoKSAmJiAhISgoX3JvdyRzdWJSb3dzID0gcm93LnN1YlJvd3MpICE9IG51bGwgJiYgX3JvdyRzdWJSb3dzLmxlbmd0aCk7XG4gICAgfTtcbiAgfVxufTtcbmZ1bmN0aW9uIG9yZGVyQ29sdW1ucyhsZWFmQ29sdW1ucywgZ3JvdXBpbmcsIGdyb3VwZWRDb2x1bW5Nb2RlKSB7XG4gIGlmICghKGdyb3VwaW5nICE9IG51bGwgJiYgZ3JvdXBpbmcubGVuZ3RoKSB8fCAhZ3JvdXBlZENvbHVtbk1vZGUpIHtcbiAgICByZXR1cm4gbGVhZkNvbHVtbnM7XG4gIH1cbiAgY29uc3Qgbm9uR3JvdXBpbmdDb2x1bW5zID0gbGVhZkNvbHVtbnMuZmlsdGVyKGNvbCA9PiAhZ3JvdXBpbmcuaW5jbHVkZXMoY29sLmlkKSk7XG4gIGlmIChncm91cGVkQ29sdW1uTW9kZSA9PT0gJ3JlbW92ZScpIHtcbiAgICByZXR1cm4gbm9uR3JvdXBpbmdDb2x1bW5zO1xuICB9XG4gIGNvbnN0IGdyb3VwaW5nQ29sdW1ucyA9IGdyb3VwaW5nLm1hcChnID0+IGxlYWZDb2x1bW5zLmZpbmQoY29sID0+IGNvbC5pZCA9PT0gZykpLmZpbHRlcihCb29sZWFuKTtcbiAgcmV0dXJuIFsuLi5ncm91cGluZ0NvbHVtbnMsIC4uLm5vbkdyb3VwaW5nQ29sdW1uc107XG59XG5cbi8vXG5cbmNvbnN0IE9yZGVyaW5nID0ge1xuICBnZXRJbml0aWFsU3RhdGU6IHN0YXRlID0+IHtcbiAgICByZXR1cm4ge1xuICAgICAgY29sdW1uT3JkZXI6IFtdLFxuICAgICAgLi4uc3RhdGVcbiAgICB9O1xuICB9LFxuICBnZXREZWZhdWx0T3B0aW9uczogdGFibGUgPT4ge1xuICAgIHJldHVybiB7XG4gICAgICBvbkNvbHVtbk9yZGVyQ2hhbmdlOiBtYWtlU3RhdGVVcGRhdGVyKCdjb2x1bW5PcmRlcicsIHRhYmxlKVxuICAgIH07XG4gIH0sXG4gIGNyZWF0ZVRhYmxlOiB0YWJsZSA9PiB7XG4gICAgdGFibGUuc2V0Q29sdW1uT3JkZXIgPSB1cGRhdGVyID0+IHRhYmxlLm9wdGlvbnMub25Db2x1bW5PcmRlckNoYW5nZSA9PSBudWxsID8gdm9pZCAwIDogdGFibGUub3B0aW9ucy5vbkNvbHVtbk9yZGVyQ2hhbmdlKHVwZGF0ZXIpO1xuICAgIHRhYmxlLnJlc2V0Q29sdW1uT3JkZXIgPSBkZWZhdWx0U3RhdGUgPT4ge1xuICAgICAgdmFyIF90YWJsZSRpbml0aWFsU3RhdGUkYztcbiAgICAgIHRhYmxlLnNldENvbHVtbk9yZGVyKGRlZmF1bHRTdGF0ZSA/IFtdIDogKF90YWJsZSRpbml0aWFsU3RhdGUkYyA9IHRhYmxlLmluaXRpYWxTdGF0ZS5jb2x1bW5PcmRlcikgIT0gbnVsbCA/IF90YWJsZSRpbml0aWFsU3RhdGUkYyA6IFtdKTtcbiAgICB9O1xuICAgIHRhYmxlLl9nZXRPcmRlckNvbHVtbnNGbiA9IG1lbW8oKCkgPT4gW3RhYmxlLmdldFN0YXRlKCkuY29sdW1uT3JkZXIsIHRhYmxlLmdldFN0YXRlKCkuZ3JvdXBpbmcsIHRhYmxlLm9wdGlvbnMuZ3JvdXBlZENvbHVtbk1vZGVdLCAoY29sdW1uT3JkZXIsIGdyb3VwaW5nLCBncm91cGVkQ29sdW1uTW9kZSkgPT4gY29sdW1ucyA9PiB7XG4gICAgICAvLyBTb3J0IGdyb3VwZWQgY29sdW1ucyB0byB0aGUgc3RhcnQgb2YgdGhlIGNvbHVtbiBsaXN0XG4gICAgICAvLyBiZWZvcmUgdGhlIGhlYWRlcnMgYXJlIGJ1aWx0XG4gICAgICBsZXQgb3JkZXJlZENvbHVtbnMgPSBbXTtcblxuICAgICAgLy8gSWYgdGhlcmUgaXMgbm8gb3JkZXIsIHJldHVybiB0aGUgbm9ybWFsIGNvbHVtbnNcbiAgICAgIGlmICghKGNvbHVtbk9yZGVyICE9IG51bGwgJiYgY29sdW1uT3JkZXIubGVuZ3RoKSkge1xuICAgICAgICBvcmRlcmVkQ29sdW1ucyA9IGNvbHVtbnM7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBjb25zdCBjb2x1bW5PcmRlckNvcHkgPSBbLi4uY29sdW1uT3JkZXJdO1xuXG4gICAgICAgIC8vIElmIHRoZXJlIGlzIGFuIG9yZGVyLCBtYWtlIGEgY29weSBvZiB0aGUgY29sdW1uc1xuICAgICAgICBjb25zdCBjb2x1bW5zQ29weSA9IFsuLi5jb2x1bW5zXTtcblxuICAgICAgICAvLyBBbmQgbWFrZSBhIG5ldyBvcmRlcmVkIGFycmF5IG9mIHRoZSBjb2x1bW5zXG5cbiAgICAgICAgLy8gTG9vcCBvdmVyIHRoZSBjb2x1bW5zIGFuZCBwbGFjZSB0aGVtIGluIG9yZGVyIGludG8gdGhlIG5ldyBhcnJheVxuICAgICAgICB3aGlsZSAoY29sdW1uc0NvcHkubGVuZ3RoICYmIGNvbHVtbk9yZGVyQ29weS5sZW5ndGgpIHtcbiAgICAgICAgICBjb25zdCB0YXJnZXRDb2x1bW5JZCA9IGNvbHVtbk9yZGVyQ29weS5zaGlmdCgpO1xuICAgICAgICAgIGNvbnN0IGZvdW5kSW5kZXggPSBjb2x1bW5zQ29weS5maW5kSW5kZXgoZCA9PiBkLmlkID09PSB0YXJnZXRDb2x1bW5JZCk7XG4gICAgICAgICAgaWYgKGZvdW5kSW5kZXggPiAtMSkge1xuICAgICAgICAgICAgb3JkZXJlZENvbHVtbnMucHVzaChjb2x1bW5zQ29weS5zcGxpY2UoZm91bmRJbmRleCwgMSlbMF0pO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIC8vIElmIHRoZXJlIGFyZSBhbnkgY29sdW1ucyBsZWZ0LCBhZGQgdGhlbSB0byB0aGUgZW5kXG4gICAgICAgIG9yZGVyZWRDb2x1bW5zID0gWy4uLm9yZGVyZWRDb2x1bW5zLCAuLi5jb2x1bW5zQ29weV07XG4gICAgICB9XG4gICAgICByZXR1cm4gb3JkZXJDb2x1bW5zKG9yZGVyZWRDb2x1bW5zLCBncm91cGluZywgZ3JvdXBlZENvbHVtbk1vZGUpO1xuICAgIH0sIHtcbiAgICAgIGtleTogcHJvY2Vzcy5lbnYuTk9ERV9FTlYgPT09ICdkZXZlbG9wbWVudCcgJiYgJ2dldE9yZGVyQ29sdW1uc0ZuJ1xuICAgICAgLy8gZGVidWc6ICgpID0+IHRhYmxlLm9wdGlvbnMuZGVidWdBbGwgPz8gdGFibGUub3B0aW9ucy5kZWJ1Z1RhYmxlLFxuICAgIH0pO1xuICB9XG59O1xuXG4vL1xuXG5jb25zdCBkZWZhdWx0UGFnZUluZGV4ID0gMDtcbmNvbnN0IGRlZmF1bHRQYWdlU2l6ZSA9IDEwO1xuY29uc3QgZ2V0RGVmYXVsdFBhZ2luYXRpb25TdGF0ZSA9ICgpID0+ICh7XG4gIHBhZ2VJbmRleDogZGVmYXVsdFBhZ2VJbmRleCxcbiAgcGFnZVNpemU6IGRlZmF1bHRQYWdlU2l6ZVxufSk7XG5jb25zdCBQYWdpbmF0aW9uID0ge1xuICBnZXRJbml0aWFsU3RhdGU6IHN0YXRlID0+IHtcbiAgICByZXR1cm4ge1xuICAgICAgLi4uc3RhdGUsXG4gICAgICBwYWdpbmF0aW9uOiB7XG4gICAgICAgIC4uLmdldERlZmF1bHRQYWdpbmF0aW9uU3RhdGUoKSxcbiAgICAgICAgLi4uKHN0YXRlID09IG51bGwgPyB2b2lkIDAgOiBzdGF0ZS5wYWdpbmF0aW9uKVxuICAgICAgfVxuICAgIH07XG4gIH0sXG4gIGdldERlZmF1bHRPcHRpb25zOiB0YWJsZSA9PiB7XG4gICAgcmV0dXJuIHtcbiAgICAgIG9uUGFnaW5hdGlvbkNoYW5nZTogbWFrZVN0YXRlVXBkYXRlcigncGFnaW5hdGlvbicsIHRhYmxlKVxuICAgIH07XG4gIH0sXG4gIGNyZWF0ZVRhYmxlOiB0YWJsZSA9PiB7XG4gICAgbGV0IHJlZ2lzdGVyZWQgPSBmYWxzZTtcbiAgICBsZXQgcXVldWVkID0gZmFsc2U7XG4gICAgdGFibGUuX2F1dG9SZXNldFBhZ2VJbmRleCA9ICgpID0+IHtcbiAgICAgIHZhciBfcmVmLCBfdGFibGUkb3B0aW9ucyRhdXRvUmU7XG4gICAgICBpZiAoIXJlZ2lzdGVyZWQpIHtcbiAgICAgICAgdGFibGUuX3F1ZXVlKCgpID0+IHtcbiAgICAgICAgICByZWdpc3RlcmVkID0gdHJ1ZTtcbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIGlmICgoX3JlZiA9IChfdGFibGUkb3B0aW9ucyRhdXRvUmUgPSB0YWJsZS5vcHRpb25zLmF1dG9SZXNldEFsbCkgIT0gbnVsbCA/IF90YWJsZSRvcHRpb25zJGF1dG9SZSA6IHRhYmxlLm9wdGlvbnMuYXV0b1Jlc2V0UGFnZUluZGV4KSAhPSBudWxsID8gX3JlZiA6ICF0YWJsZS5vcHRpb25zLm1hbnVhbFBhZ2luYXRpb24pIHtcbiAgICAgICAgaWYgKHF1ZXVlZCkgcmV0dXJuO1xuICAgICAgICBxdWV1ZWQgPSB0cnVlO1xuICAgICAgICB0YWJsZS5fcXVldWUoKCkgPT4ge1xuICAgICAgICAgIHRhYmxlLnJlc2V0UGFnZUluZGV4KCk7XG4gICAgICAgICAgcXVldWVkID0gZmFsc2U7XG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgIH07XG4gICAgdGFibGUuc2V0UGFnaW5hdGlvbiA9IHVwZGF0ZXIgPT4ge1xuICAgICAgY29uc3Qgc2FmZVVwZGF0ZXIgPSBvbGQgPT4ge1xuICAgICAgICBsZXQgbmV3U3RhdGUgPSBmdW5jdGlvbmFsVXBkYXRlKHVwZGF0ZXIsIG9sZCk7XG4gICAgICAgIHJldHVybiBuZXdTdGF0ZTtcbiAgICAgIH07XG4gICAgICByZXR1cm4gdGFibGUub3B0aW9ucy5vblBhZ2luYXRpb25DaGFuZ2UgPT0gbnVsbCA/IHZvaWQgMCA6IHRhYmxlLm9wdGlvbnMub25QYWdpbmF0aW9uQ2hhbmdlKHNhZmVVcGRhdGVyKTtcbiAgICB9O1xuICAgIHRhYmxlLnJlc2V0UGFnaW5hdGlvbiA9IGRlZmF1bHRTdGF0ZSA9PiB7XG4gICAgICB2YXIgX3RhYmxlJGluaXRpYWxTdGF0ZSRwO1xuICAgICAgdGFibGUuc2V0UGFnaW5hdGlvbihkZWZhdWx0U3RhdGUgPyBnZXREZWZhdWx0UGFnaW5hdGlvblN0YXRlKCkgOiAoX3RhYmxlJGluaXRpYWxTdGF0ZSRwID0gdGFibGUuaW5pdGlhbFN0YXRlLnBhZ2luYXRpb24pICE9IG51bGwgPyBfdGFibGUkaW5pdGlhbFN0YXRlJHAgOiBnZXREZWZhdWx0UGFnaW5hdGlvblN0YXRlKCkpO1xuICAgIH07XG4gICAgdGFibGUuc2V0UGFnZUluZGV4ID0gdXBkYXRlciA9PiB7XG4gICAgICB0YWJsZS5zZXRQYWdpbmF0aW9uKG9sZCA9PiB7XG4gICAgICAgIGxldCBwYWdlSW5kZXggPSBmdW5jdGlvbmFsVXBkYXRlKHVwZGF0ZXIsIG9sZC5wYWdlSW5kZXgpO1xuICAgICAgICBjb25zdCBtYXhQYWdlSW5kZXggPSB0eXBlb2YgdGFibGUub3B0aW9ucy5wYWdlQ291bnQgPT09ICd1bmRlZmluZWQnIHx8IHRhYmxlLm9wdGlvbnMucGFnZUNvdW50ID09PSAtMSA/IE51bWJlci5NQVhfU0FGRV9JTlRFR0VSIDogdGFibGUub3B0aW9ucy5wYWdlQ291bnQgLSAxO1xuICAgICAgICBwYWdlSW5kZXggPSBNYXRoLm1heCgwLCBNYXRoLm1pbihwYWdlSW5kZXgsIG1heFBhZ2VJbmRleCkpO1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgIC4uLm9sZCxcbiAgICAgICAgICBwYWdlSW5kZXhcbiAgICAgICAgfTtcbiAgICAgIH0pO1xuICAgIH07XG4gICAgdGFibGUucmVzZXRQYWdlSW5kZXggPSBkZWZhdWx0U3RhdGUgPT4ge1xuICAgICAgdmFyIF90YWJsZSRpbml0aWFsU3RhdGUkcDIsIF90YWJsZSRpbml0aWFsU3RhdGU7XG4gICAgICB0YWJsZS5zZXRQYWdlSW5kZXgoZGVmYXVsdFN0YXRlID8gZGVmYXVsdFBhZ2VJbmRleCA6IChfdGFibGUkaW5pdGlhbFN0YXRlJHAyID0gKF90YWJsZSRpbml0aWFsU3RhdGUgPSB0YWJsZS5pbml0aWFsU3RhdGUpID09IG51bGwgfHwgKF90YWJsZSRpbml0aWFsU3RhdGUgPSBfdGFibGUkaW5pdGlhbFN0YXRlLnBhZ2luYXRpb24pID09IG51bGwgPyB2b2lkIDAgOiBfdGFibGUkaW5pdGlhbFN0YXRlLnBhZ2VJbmRleCkgIT0gbnVsbCA/IF90YWJsZSRpbml0aWFsU3RhdGUkcDIgOiBkZWZhdWx0UGFnZUluZGV4KTtcbiAgICB9O1xuICAgIHRhYmxlLnJlc2V0UGFnZVNpemUgPSBkZWZhdWx0U3RhdGUgPT4ge1xuICAgICAgdmFyIF90YWJsZSRpbml0aWFsU3RhdGUkcDMsIF90YWJsZSRpbml0aWFsU3RhdGUyO1xuICAgICAgdGFibGUuc2V0UGFnZVNpemUoZGVmYXVsdFN0YXRlID8gZGVmYXVsdFBhZ2VTaXplIDogKF90YWJsZSRpbml0aWFsU3RhdGUkcDMgPSAoX3RhYmxlJGluaXRpYWxTdGF0ZTIgPSB0YWJsZS5pbml0aWFsU3RhdGUpID09IG51bGwgfHwgKF90YWJsZSRpbml0aWFsU3RhdGUyID0gX3RhYmxlJGluaXRpYWxTdGF0ZTIucGFnaW5hdGlvbikgPT0gbnVsbCA/IHZvaWQgMCA6IF90YWJsZSRpbml0aWFsU3RhdGUyLnBhZ2VTaXplKSAhPSBudWxsID8gX3RhYmxlJGluaXRpYWxTdGF0ZSRwMyA6IGRlZmF1bHRQYWdlU2l6ZSk7XG4gICAgfTtcbiAgICB0YWJsZS5zZXRQYWdlU2l6ZSA9IHVwZGF0ZXIgPT4ge1xuICAgICAgdGFibGUuc2V0UGFnaW5hdGlvbihvbGQgPT4ge1xuICAgICAgICBjb25zdCBwYWdlU2l6ZSA9IE1hdGgubWF4KDEsIGZ1bmN0aW9uYWxVcGRhdGUodXBkYXRlciwgb2xkLnBhZ2VTaXplKSk7XG4gICAgICAgIGNvbnN0IHRvcFJvd0luZGV4ID0gb2xkLnBhZ2VTaXplICogb2xkLnBhZ2VJbmRleDtcbiAgICAgICAgY29uc3QgcGFnZUluZGV4ID0gTWF0aC5mbG9vcih0b3BSb3dJbmRleCAvIHBhZ2VTaXplKTtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAuLi5vbGQsXG4gICAgICAgICAgcGFnZUluZGV4LFxuICAgICAgICAgIHBhZ2VTaXplXG4gICAgICAgIH07XG4gICAgICB9KTtcbiAgICB9O1xuICAgIHRhYmxlLnNldFBhZ2VDb3VudCA9IHVwZGF0ZXIgPT4gdGFibGUuc2V0UGFnaW5hdGlvbihvbGQgPT4ge1xuICAgICAgdmFyIF90YWJsZSRvcHRpb25zJHBhZ2VDbztcbiAgICAgIGxldCBuZXdQYWdlQ291bnQgPSBmdW5jdGlvbmFsVXBkYXRlKHVwZGF0ZXIsIChfdGFibGUkb3B0aW9ucyRwYWdlQ28gPSB0YWJsZS5vcHRpb25zLnBhZ2VDb3VudCkgIT0gbnVsbCA/IF90YWJsZSRvcHRpb25zJHBhZ2VDbyA6IC0xKTtcbiAgICAgIGlmICh0eXBlb2YgbmV3UGFnZUNvdW50ID09PSAnbnVtYmVyJykge1xuICAgICAgICBuZXdQYWdlQ291bnQgPSBNYXRoLm1heCgtMSwgbmV3UGFnZUNvdW50KTtcbiAgICAgIH1cbiAgICAgIHJldHVybiB7XG4gICAgICAgIC4uLm9sZCxcbiAgICAgICAgcGFnZUNvdW50OiBuZXdQYWdlQ291bnRcbiAgICAgIH07XG4gICAgfSk7XG4gICAgdGFibGUuZ2V0UGFnZU9wdGlvbnMgPSBtZW1vKCgpID0+IFt0YWJsZS5nZXRQYWdlQ291bnQoKV0sIHBhZ2VDb3VudCA9PiB7XG4gICAgICBsZXQgcGFnZU9wdGlvbnMgPSBbXTtcbiAgICAgIGlmIChwYWdlQ291bnQgJiYgcGFnZUNvdW50ID4gMCkge1xuICAgICAgICBwYWdlT3B0aW9ucyA9IFsuLi5uZXcgQXJyYXkocGFnZUNvdW50KV0uZmlsbChudWxsKS5tYXAoKF8sIGkpID0+IGkpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHBhZ2VPcHRpb25zO1xuICAgIH0sIHtcbiAgICAgIGtleTogcHJvY2Vzcy5lbnYuTk9ERV9FTlYgPT09ICdkZXZlbG9wbWVudCcgJiYgJ2dldFBhZ2VPcHRpb25zJyxcbiAgICAgIGRlYnVnOiAoKSA9PiB7XG4gICAgICAgIHZhciBfdGFibGUkb3B0aW9ucyRkZWJ1Z0E7XG4gICAgICAgIHJldHVybiAoX3RhYmxlJG9wdGlvbnMkZGVidWdBID0gdGFibGUub3B0aW9ucy5kZWJ1Z0FsbCkgIT0gbnVsbCA/IF90YWJsZSRvcHRpb25zJGRlYnVnQSA6IHRhYmxlLm9wdGlvbnMuZGVidWdUYWJsZTtcbiAgICAgIH1cbiAgICB9KTtcbiAgICB0YWJsZS5nZXRDYW5QcmV2aW91c1BhZ2UgPSAoKSA9PiB0YWJsZS5nZXRTdGF0ZSgpLnBhZ2luYXRpb24ucGFnZUluZGV4ID4gMDtcbiAgICB0YWJsZS5nZXRDYW5OZXh0UGFnZSA9ICgpID0+IHtcbiAgICAgIGNvbnN0IHtcbiAgICAgICAgcGFnZUluZGV4XG4gICAgICB9ID0gdGFibGUuZ2V0U3RhdGUoKS5wYWdpbmF0aW9uO1xuICAgICAgY29uc3QgcGFnZUNvdW50ID0gdGFibGUuZ2V0UGFnZUNvdW50KCk7XG4gICAgICBpZiAocGFnZUNvdW50ID09PSAtMSkge1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgIH1cbiAgICAgIGlmIChwYWdlQ291bnQgPT09IDApIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHBhZ2VJbmRleCA8IHBhZ2VDb3VudCAtIDE7XG4gICAgfTtcbiAgICB0YWJsZS5wcmV2aW91c1BhZ2UgPSAoKSA9PiB7XG4gICAgICByZXR1cm4gdGFibGUuc2V0UGFnZUluZGV4KG9sZCA9PiBvbGQgLSAxKTtcbiAgICB9O1xuICAgIHRhYmxlLm5leHRQYWdlID0gKCkgPT4ge1xuICAgICAgcmV0dXJuIHRhYmxlLnNldFBhZ2VJbmRleChvbGQgPT4ge1xuICAgICAgICByZXR1cm4gb2xkICsgMTtcbiAgICAgIH0pO1xuICAgIH07XG4gICAgdGFibGUuZ2V0UHJlUGFnaW5hdGlvblJvd01vZGVsID0gKCkgPT4gdGFibGUuZ2V0RXhwYW5kZWRSb3dNb2RlbCgpO1xuICAgIHRhYmxlLmdldFBhZ2luYXRpb25Sb3dNb2RlbCA9ICgpID0+IHtcbiAgICAgIGlmICghdGFibGUuX2dldFBhZ2luYXRpb25Sb3dNb2RlbCAmJiB0YWJsZS5vcHRpb25zLmdldFBhZ2luYXRpb25Sb3dNb2RlbCkge1xuICAgICAgICB0YWJsZS5fZ2V0UGFnaW5hdGlvblJvd01vZGVsID0gdGFibGUub3B0aW9ucy5nZXRQYWdpbmF0aW9uUm93TW9kZWwodGFibGUpO1xuICAgICAgfVxuICAgICAgaWYgKHRhYmxlLm9wdGlvbnMubWFudWFsUGFnaW5hdGlvbiB8fCAhdGFibGUuX2dldFBhZ2luYXRpb25Sb3dNb2RlbCkge1xuICAgICAgICByZXR1cm4gdGFibGUuZ2V0UHJlUGFnaW5hdGlvblJvd01vZGVsKCk7XG4gICAgICB9XG4gICAgICByZXR1cm4gdGFibGUuX2dldFBhZ2luYXRpb25Sb3dNb2RlbCgpO1xuICAgIH07XG4gICAgdGFibGUuZ2V0UGFnZUNvdW50ID0gKCkgPT4ge1xuICAgICAgdmFyIF90YWJsZSRvcHRpb25zJHBhZ2VDbzI7XG4gICAgICByZXR1cm4gKF90YWJsZSRvcHRpb25zJHBhZ2VDbzIgPSB0YWJsZS5vcHRpb25zLnBhZ2VDb3VudCkgIT0gbnVsbCA/IF90YWJsZSRvcHRpb25zJHBhZ2VDbzIgOiBNYXRoLmNlaWwodGFibGUuZ2V0UHJlUGFnaW5hdGlvblJvd01vZGVsKCkucm93cy5sZW5ndGggLyB0YWJsZS5nZXRTdGF0ZSgpLnBhZ2luYXRpb24ucGFnZVNpemUpO1xuICAgIH07XG4gIH1cbn07XG5cbi8vXG5cbmNvbnN0IGdldERlZmF1bHRDb2x1bW5QaW5uaW5nU3RhdGUgPSAoKSA9PiAoe1xuICBsZWZ0OiBbXSxcbiAgcmlnaHQ6IFtdXG59KTtcbmNvbnN0IGdldERlZmF1bHRSb3dQaW5uaW5nU3RhdGUgPSAoKSA9PiAoe1xuICB0b3A6IFtdLFxuICBib3R0b206IFtdXG59KTtcbmNvbnN0IFBpbm5pbmcgPSB7XG4gIGdldEluaXRpYWxTdGF0ZTogc3RhdGUgPT4ge1xuICAgIHJldHVybiB7XG4gICAgICBjb2x1bW5QaW5uaW5nOiBnZXREZWZhdWx0Q29sdW1uUGlubmluZ1N0YXRlKCksXG4gICAgICByb3dQaW5uaW5nOiBnZXREZWZhdWx0Um93UGlubmluZ1N0YXRlKCksXG4gICAgICAuLi5zdGF0ZVxuICAgIH07XG4gIH0sXG4gIGdldERlZmF1bHRPcHRpb25zOiB0YWJsZSA9PiB7XG4gICAgcmV0dXJuIHtcbiAgICAgIG9uQ29sdW1uUGlubmluZ0NoYW5nZTogbWFrZVN0YXRlVXBkYXRlcignY29sdW1uUGlubmluZycsIHRhYmxlKSxcbiAgICAgIG9uUm93UGlubmluZ0NoYW5nZTogbWFrZVN0YXRlVXBkYXRlcigncm93UGlubmluZycsIHRhYmxlKVxuICAgIH07XG4gIH0sXG4gIGNyZWF0ZUNvbHVtbjogKGNvbHVtbiwgdGFibGUpID0+IHtcbiAgICBjb2x1bW4ucGluID0gcG9zaXRpb24gPT4ge1xuICAgICAgY29uc3QgY29sdW1uSWRzID0gY29sdW1uLmdldExlYWZDb2x1bW5zKCkubWFwKGQgPT4gZC5pZCkuZmlsdGVyKEJvb2xlYW4pO1xuICAgICAgdGFibGUuc2V0Q29sdW1uUGlubmluZyhvbGQgPT4ge1xuICAgICAgICB2YXIgX29sZCRsZWZ0MywgX29sZCRyaWdodDM7XG4gICAgICAgIGlmIChwb3NpdGlvbiA9PT0gJ3JpZ2h0Jykge1xuICAgICAgICAgIHZhciBfb2xkJGxlZnQsIF9vbGQkcmlnaHQ7XG4gICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIGxlZnQ6ICgoX29sZCRsZWZ0ID0gb2xkID09IG51bGwgPyB2b2lkIDAgOiBvbGQubGVmdCkgIT0gbnVsbCA/IF9vbGQkbGVmdCA6IFtdKS5maWx0ZXIoZCA9PiAhKGNvbHVtbklkcyAhPSBudWxsICYmIGNvbHVtbklkcy5pbmNsdWRlcyhkKSkpLFxuICAgICAgICAgICAgcmlnaHQ6IFsuLi4oKF9vbGQkcmlnaHQgPSBvbGQgPT0gbnVsbCA/IHZvaWQgMCA6IG9sZC5yaWdodCkgIT0gbnVsbCA/IF9vbGQkcmlnaHQgOiBbXSkuZmlsdGVyKGQgPT4gIShjb2x1bW5JZHMgIT0gbnVsbCAmJiBjb2x1bW5JZHMuaW5jbHVkZXMoZCkpKSwgLi4uY29sdW1uSWRzXVxuICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHBvc2l0aW9uID09PSAnbGVmdCcpIHtcbiAgICAgICAgICB2YXIgX29sZCRsZWZ0MiwgX29sZCRyaWdodDI7XG4gICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIGxlZnQ6IFsuLi4oKF9vbGQkbGVmdDIgPSBvbGQgPT0gbnVsbCA/IHZvaWQgMCA6IG9sZC5sZWZ0KSAhPSBudWxsID8gX29sZCRsZWZ0MiA6IFtdKS5maWx0ZXIoZCA9PiAhKGNvbHVtbklkcyAhPSBudWxsICYmIGNvbHVtbklkcy5pbmNsdWRlcyhkKSkpLCAuLi5jb2x1bW5JZHNdLFxuICAgICAgICAgICAgcmlnaHQ6ICgoX29sZCRyaWdodDIgPSBvbGQgPT0gbnVsbCA/IHZvaWQgMCA6IG9sZC5yaWdodCkgIT0gbnVsbCA/IF9vbGQkcmlnaHQyIDogW10pLmZpbHRlcihkID0+ICEoY29sdW1uSWRzICE9IG51bGwgJiYgY29sdW1uSWRzLmluY2x1ZGVzKGQpKSlcbiAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgbGVmdDogKChfb2xkJGxlZnQzID0gb2xkID09IG51bGwgPyB2b2lkIDAgOiBvbGQubGVmdCkgIT0gbnVsbCA/IF9vbGQkbGVmdDMgOiBbXSkuZmlsdGVyKGQgPT4gIShjb2x1bW5JZHMgIT0gbnVsbCAmJiBjb2x1bW5JZHMuaW5jbHVkZXMoZCkpKSxcbiAgICAgICAgICByaWdodDogKChfb2xkJHJpZ2h0MyA9IG9sZCA9PSBudWxsID8gdm9pZCAwIDogb2xkLnJpZ2h0KSAhPSBudWxsID8gX29sZCRyaWdodDMgOiBbXSkuZmlsdGVyKGQgPT4gIShjb2x1bW5JZHMgIT0gbnVsbCAmJiBjb2x1bW5JZHMuaW5jbHVkZXMoZCkpKVxuICAgICAgICB9O1xuICAgICAgfSk7XG4gICAgfTtcbiAgICBjb2x1bW4uZ2V0Q2FuUGluID0gKCkgPT4ge1xuICAgICAgY29uc3QgbGVhZkNvbHVtbnMgPSBjb2x1bW4uZ2V0TGVhZkNvbHVtbnMoKTtcbiAgICAgIHJldHVybiBsZWFmQ29sdW1ucy5zb21lKGQgPT4ge1xuICAgICAgICB2YXIgX2QkY29sdW1uRGVmJGVuYWJsZVBpLCBfcmVmLCBfdGFibGUkb3B0aW9ucyRlbmFibGU7XG4gICAgICAgIHJldHVybiAoKF9kJGNvbHVtbkRlZiRlbmFibGVQaSA9IGQuY29sdW1uRGVmLmVuYWJsZVBpbm5pbmcpICE9IG51bGwgPyBfZCRjb2x1bW5EZWYkZW5hYmxlUGkgOiB0cnVlKSAmJiAoKF9yZWYgPSAoX3RhYmxlJG9wdGlvbnMkZW5hYmxlID0gdGFibGUub3B0aW9ucy5lbmFibGVDb2x1bW5QaW5uaW5nKSAhPSBudWxsID8gX3RhYmxlJG9wdGlvbnMkZW5hYmxlIDogdGFibGUub3B0aW9ucy5lbmFibGVQaW5uaW5nKSAhPSBudWxsID8gX3JlZiA6IHRydWUpO1xuICAgICAgfSk7XG4gICAgfTtcbiAgICBjb2x1bW4uZ2V0SXNQaW5uZWQgPSAoKSA9PiB7XG4gICAgICBjb25zdCBsZWFmQ29sdW1uSWRzID0gY29sdW1uLmdldExlYWZDb2x1bW5zKCkubWFwKGQgPT4gZC5pZCk7XG4gICAgICBjb25zdCB7XG4gICAgICAgIGxlZnQsXG4gICAgICAgIHJpZ2h0XG4gICAgICB9ID0gdGFibGUuZ2V0U3RhdGUoKS5jb2x1bW5QaW5uaW5nO1xuICAgICAgY29uc3QgaXNMZWZ0ID0gbGVhZkNvbHVtbklkcy5zb21lKGQgPT4gbGVmdCA9PSBudWxsID8gdm9pZCAwIDogbGVmdC5pbmNsdWRlcyhkKSk7XG4gICAgICBjb25zdCBpc1JpZ2h0ID0gbGVhZkNvbHVtbklkcy5zb21lKGQgPT4gcmlnaHQgPT0gbnVsbCA/IHZvaWQgMCA6IHJpZ2h0LmluY2x1ZGVzKGQpKTtcbiAgICAgIHJldHVybiBpc0xlZnQgPyAnbGVmdCcgOiBpc1JpZ2h0ID8gJ3JpZ2h0JyA6IGZhbHNlO1xuICAgIH07XG4gICAgY29sdW1uLmdldFBpbm5lZEluZGV4ID0gKCkgPT4ge1xuICAgICAgdmFyIF90YWJsZSRnZXRTdGF0ZSRjb2x1bSwgX3RhYmxlJGdldFN0YXRlJGNvbHVtMjtcbiAgICAgIGNvbnN0IHBvc2l0aW9uID0gY29sdW1uLmdldElzUGlubmVkKCk7XG4gICAgICByZXR1cm4gcG9zaXRpb24gPyAoX3RhYmxlJGdldFN0YXRlJGNvbHVtID0gKF90YWJsZSRnZXRTdGF0ZSRjb2x1bTIgPSB0YWJsZS5nZXRTdGF0ZSgpLmNvbHVtblBpbm5pbmcpID09IG51bGwgfHwgKF90YWJsZSRnZXRTdGF0ZSRjb2x1bTIgPSBfdGFibGUkZ2V0U3RhdGUkY29sdW0yW3Bvc2l0aW9uXSkgPT0gbnVsbCA/IHZvaWQgMCA6IF90YWJsZSRnZXRTdGF0ZSRjb2x1bTIuaW5kZXhPZihjb2x1bW4uaWQpKSAhPSBudWxsID8gX3RhYmxlJGdldFN0YXRlJGNvbHVtIDogLTEgOiAwO1xuICAgIH07XG4gIH0sXG4gIGNyZWF0ZVJvdzogKHJvdywgdGFibGUpID0+IHtcbiAgICByb3cucGluID0gKHBvc2l0aW9uLCBpbmNsdWRlTGVhZlJvd3MsIGluY2x1ZGVQYXJlbnRSb3dzKSA9PiB7XG4gICAgICBjb25zdCBsZWFmUm93SWRzID0gaW5jbHVkZUxlYWZSb3dzID8gcm93LmdldExlYWZSb3dzKCkubWFwKF9yZWYyID0+IHtcbiAgICAgICAgbGV0IHtcbiAgICAgICAgICBpZFxuICAgICAgICB9ID0gX3JlZjI7XG4gICAgICAgIHJldHVybiBpZDtcbiAgICAgIH0pIDogW107XG4gICAgICBjb25zdCBwYXJlbnRSb3dJZHMgPSBpbmNsdWRlUGFyZW50Um93cyA/IHJvdy5nZXRQYXJlbnRSb3dzKCkubWFwKF9yZWYzID0+IHtcbiAgICAgICAgbGV0IHtcbiAgICAgICAgICBpZFxuICAgICAgICB9ID0gX3JlZjM7XG4gICAgICAgIHJldHVybiBpZDtcbiAgICAgIH0pIDogW107XG4gICAgICBjb25zdCByb3dJZHMgPSBuZXcgU2V0KFsuLi5wYXJlbnRSb3dJZHMsIHJvdy5pZCwgLi4ubGVhZlJvd0lkc10pO1xuICAgICAgdGFibGUuc2V0Um93UGlubmluZyhvbGQgPT4ge1xuICAgICAgICB2YXIgX29sZCR0b3AzLCBfb2xkJGJvdHRvbTM7XG4gICAgICAgIGlmIChwb3NpdGlvbiA9PT0gJ2JvdHRvbScpIHtcbiAgICAgICAgICB2YXIgX29sZCR0b3AsIF9vbGQkYm90dG9tO1xuICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICB0b3A6ICgoX29sZCR0b3AgPSBvbGQgPT0gbnVsbCA/IHZvaWQgMCA6IG9sZC50b3ApICE9IG51bGwgPyBfb2xkJHRvcCA6IFtdKS5maWx0ZXIoZCA9PiAhKHJvd0lkcyAhPSBudWxsICYmIHJvd0lkcy5oYXMoZCkpKSxcbiAgICAgICAgICAgIGJvdHRvbTogWy4uLigoX29sZCRib3R0b20gPSBvbGQgPT0gbnVsbCA/IHZvaWQgMCA6IG9sZC5ib3R0b20pICE9IG51bGwgPyBfb2xkJGJvdHRvbSA6IFtdKS5maWx0ZXIoZCA9PiAhKHJvd0lkcyAhPSBudWxsICYmIHJvd0lkcy5oYXMoZCkpKSwgLi4uQXJyYXkuZnJvbShyb3dJZHMpXVxuICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHBvc2l0aW9uID09PSAndG9wJykge1xuICAgICAgICAgIHZhciBfb2xkJHRvcDIsIF9vbGQkYm90dG9tMjtcbiAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgdG9wOiBbLi4uKChfb2xkJHRvcDIgPSBvbGQgPT0gbnVsbCA/IHZvaWQgMCA6IG9sZC50b3ApICE9IG51bGwgPyBfb2xkJHRvcDIgOiBbXSkuZmlsdGVyKGQgPT4gIShyb3dJZHMgIT0gbnVsbCAmJiByb3dJZHMuaGFzKGQpKSksIC4uLkFycmF5LmZyb20ocm93SWRzKV0sXG4gICAgICAgICAgICBib3R0b206ICgoX29sZCRib3R0b20yID0gb2xkID09IG51bGwgPyB2b2lkIDAgOiBvbGQuYm90dG9tKSAhPSBudWxsID8gX29sZCRib3R0b20yIDogW10pLmZpbHRlcihkID0+ICEocm93SWRzICE9IG51bGwgJiYgcm93SWRzLmhhcyhkKSkpXG4gICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgIHRvcDogKChfb2xkJHRvcDMgPSBvbGQgPT0gbnVsbCA/IHZvaWQgMCA6IG9sZC50b3ApICE9IG51bGwgPyBfb2xkJHRvcDMgOiBbXSkuZmlsdGVyKGQgPT4gIShyb3dJZHMgIT0gbnVsbCAmJiByb3dJZHMuaGFzKGQpKSksXG4gICAgICAgICAgYm90dG9tOiAoKF9vbGQkYm90dG9tMyA9IG9sZCA9PSBudWxsID8gdm9pZCAwIDogb2xkLmJvdHRvbSkgIT0gbnVsbCA/IF9vbGQkYm90dG9tMyA6IFtdKS5maWx0ZXIoZCA9PiAhKHJvd0lkcyAhPSBudWxsICYmIHJvd0lkcy5oYXMoZCkpKVxuICAgICAgICB9O1xuICAgICAgfSk7XG4gICAgfTtcbiAgICByb3cuZ2V0Q2FuUGluID0gKCkgPT4ge1xuICAgICAgdmFyIF9yZWY0O1xuICAgICAgY29uc3Qge1xuICAgICAgICBlbmFibGVSb3dQaW5uaW5nLFxuICAgICAgICBlbmFibGVQaW5uaW5nXG4gICAgICB9ID0gdGFibGUub3B0aW9ucztcbiAgICAgIGlmICh0eXBlb2YgZW5hYmxlUm93UGlubmluZyA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICByZXR1cm4gZW5hYmxlUm93UGlubmluZyhyb3cpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIChfcmVmNCA9IGVuYWJsZVJvd1Bpbm5pbmcgIT0gbnVsbCA/IGVuYWJsZVJvd1Bpbm5pbmcgOiBlbmFibGVQaW5uaW5nKSAhPSBudWxsID8gX3JlZjQgOiB0cnVlO1xuICAgIH07XG4gICAgcm93LmdldElzUGlubmVkID0gKCkgPT4ge1xuICAgICAgY29uc3Qgcm93SWRzID0gW3Jvdy5pZF07XG4gICAgICBjb25zdCB7XG4gICAgICAgIHRvcCxcbiAgICAgICAgYm90dG9tXG4gICAgICB9ID0gdGFibGUuZ2V0U3RhdGUoKS5yb3dQaW5uaW5nO1xuICAgICAgY29uc3QgaXNUb3AgPSByb3dJZHMuc29tZShkID0+IHRvcCA9PSBudWxsID8gdm9pZCAwIDogdG9wLmluY2x1ZGVzKGQpKTtcbiAgICAgIGNvbnN0IGlzQm90dG9tID0gcm93SWRzLnNvbWUoZCA9PiBib3R0b20gPT0gbnVsbCA/IHZvaWQgMCA6IGJvdHRvbS5pbmNsdWRlcyhkKSk7XG4gICAgICByZXR1cm4gaXNUb3AgPyAndG9wJyA6IGlzQm90dG9tID8gJ2JvdHRvbScgOiBmYWxzZTtcbiAgICB9O1xuICAgIHJvdy5nZXRQaW5uZWRJbmRleCA9ICgpID0+IHtcbiAgICAgIHZhciBfdGFibGUkX2dldFBpbm5lZFJvd3MsIF92aXNpYmxlUGlubmVkUm93SWRzJDtcbiAgICAgIGNvbnN0IHBvc2l0aW9uID0gcm93LmdldElzUGlubmVkKCk7XG4gICAgICBpZiAoIXBvc2l0aW9uKSByZXR1cm4gLTE7XG4gICAgICBjb25zdCB2aXNpYmxlUGlubmVkUm93SWRzID0gKF90YWJsZSRfZ2V0UGlubmVkUm93cyA9IHRhYmxlLl9nZXRQaW5uZWRSb3dzKHBvc2l0aW9uKSkgPT0gbnVsbCA/IHZvaWQgMCA6IF90YWJsZSRfZ2V0UGlubmVkUm93cy5tYXAoX3JlZjUgPT4ge1xuICAgICAgICBsZXQge1xuICAgICAgICAgIGlkXG4gICAgICAgIH0gPSBfcmVmNTtcbiAgICAgICAgcmV0dXJuIGlkO1xuICAgICAgfSk7XG4gICAgICByZXR1cm4gKF92aXNpYmxlUGlubmVkUm93SWRzJCA9IHZpc2libGVQaW5uZWRSb3dJZHMgPT0gbnVsbCA/IHZvaWQgMCA6IHZpc2libGVQaW5uZWRSb3dJZHMuaW5kZXhPZihyb3cuaWQpKSAhPSBudWxsID8gX3Zpc2libGVQaW5uZWRSb3dJZHMkIDogLTE7XG4gICAgfTtcbiAgICByb3cuZ2V0Q2VudGVyVmlzaWJsZUNlbGxzID0gbWVtbygoKSA9PiBbcm93Ll9nZXRBbGxWaXNpYmxlQ2VsbHMoKSwgdGFibGUuZ2V0U3RhdGUoKS5jb2x1bW5QaW5uaW5nLmxlZnQsIHRhYmxlLmdldFN0YXRlKCkuY29sdW1uUGlubmluZy5yaWdodF0sIChhbGxDZWxscywgbGVmdCwgcmlnaHQpID0+IHtcbiAgICAgIGNvbnN0IGxlZnRBbmRSaWdodCA9IFsuLi4obGVmdCAhPSBudWxsID8gbGVmdCA6IFtdKSwgLi4uKHJpZ2h0ICE9IG51bGwgPyByaWdodCA6IFtdKV07XG4gICAgICByZXR1cm4gYWxsQ2VsbHMuZmlsdGVyKGQgPT4gIWxlZnRBbmRSaWdodC5pbmNsdWRlcyhkLmNvbHVtbi5pZCkpO1xuICAgIH0sIHtcbiAgICAgIGtleTogcHJvY2Vzcy5lbnYuTk9ERV9FTlYgPT09ICdkZXZlbG9wbWVudCcgJiYgJ3Jvdy5nZXRDZW50ZXJWaXNpYmxlQ2VsbHMnLFxuICAgICAgZGVidWc6ICgpID0+IHtcbiAgICAgICAgdmFyIF90YWJsZSRvcHRpb25zJGRlYnVnQTtcbiAgICAgICAgcmV0dXJuIChfdGFibGUkb3B0aW9ucyRkZWJ1Z0EgPSB0YWJsZS5vcHRpb25zLmRlYnVnQWxsKSAhPSBudWxsID8gX3RhYmxlJG9wdGlvbnMkZGVidWdBIDogdGFibGUub3B0aW9ucy5kZWJ1Z1Jvd3M7XG4gICAgICB9XG4gICAgfSk7XG4gICAgcm93LmdldExlZnRWaXNpYmxlQ2VsbHMgPSBtZW1vKCgpID0+IFtyb3cuX2dldEFsbFZpc2libGVDZWxscygpLCB0YWJsZS5nZXRTdGF0ZSgpLmNvbHVtblBpbm5pbmcubGVmdCwsXSwgKGFsbENlbGxzLCBsZWZ0KSA9PiB7XG4gICAgICBjb25zdCBjZWxscyA9IChsZWZ0ICE9IG51bGwgPyBsZWZ0IDogW10pLm1hcChjb2x1bW5JZCA9PiBhbGxDZWxscy5maW5kKGNlbGwgPT4gY2VsbC5jb2x1bW4uaWQgPT09IGNvbHVtbklkKSkuZmlsdGVyKEJvb2xlYW4pLm1hcChkID0+ICh7XG4gICAgICAgIC4uLmQsXG4gICAgICAgIHBvc2l0aW9uOiAnbGVmdCdcbiAgICAgIH0pKTtcbiAgICAgIHJldHVybiBjZWxscztcbiAgICB9LCB7XG4gICAgICBrZXk6IHByb2Nlc3MuZW52Lk5PREVfRU5WID09PSAnZGV2ZWxvcG1lbnQnICYmICdyb3cuZ2V0TGVmdFZpc2libGVDZWxscycsXG4gICAgICBkZWJ1ZzogKCkgPT4ge1xuICAgICAgICB2YXIgX3RhYmxlJG9wdGlvbnMkZGVidWdBMjtcbiAgICAgICAgcmV0dXJuIChfdGFibGUkb3B0aW9ucyRkZWJ1Z0EyID0gdGFibGUub3B0aW9ucy5kZWJ1Z0FsbCkgIT0gbnVsbCA/IF90YWJsZSRvcHRpb25zJGRlYnVnQTIgOiB0YWJsZS5vcHRpb25zLmRlYnVnUm93cztcbiAgICAgIH1cbiAgICB9KTtcbiAgICByb3cuZ2V0UmlnaHRWaXNpYmxlQ2VsbHMgPSBtZW1vKCgpID0+IFtyb3cuX2dldEFsbFZpc2libGVDZWxscygpLCB0YWJsZS5nZXRTdGF0ZSgpLmNvbHVtblBpbm5pbmcucmlnaHRdLCAoYWxsQ2VsbHMsIHJpZ2h0KSA9PiB7XG4gICAgICBjb25zdCBjZWxscyA9IChyaWdodCAhPSBudWxsID8gcmlnaHQgOiBbXSkubWFwKGNvbHVtbklkID0+IGFsbENlbGxzLmZpbmQoY2VsbCA9PiBjZWxsLmNvbHVtbi5pZCA9PT0gY29sdW1uSWQpKS5maWx0ZXIoQm9vbGVhbikubWFwKGQgPT4gKHtcbiAgICAgICAgLi4uZCxcbiAgICAgICAgcG9zaXRpb246ICdyaWdodCdcbiAgICAgIH0pKTtcbiAgICAgIHJldHVybiBjZWxscztcbiAgICB9LCB7XG4gICAgICBrZXk6IHByb2Nlc3MuZW52Lk5PREVfRU5WID09PSAnZGV2ZWxvcG1lbnQnICYmICdyb3cuZ2V0UmlnaHRWaXNpYmxlQ2VsbHMnLFxuICAgICAgZGVidWc6ICgpID0+IHtcbiAgICAgICAgdmFyIF90YWJsZSRvcHRpb25zJGRlYnVnQTM7XG4gICAgICAgIHJldHVybiAoX3RhYmxlJG9wdGlvbnMkZGVidWdBMyA9IHRhYmxlLm9wdGlvbnMuZGVidWdBbGwpICE9IG51bGwgPyBfdGFibGUkb3B0aW9ucyRkZWJ1Z0EzIDogdGFibGUub3B0aW9ucy5kZWJ1Z1Jvd3M7XG4gICAgICB9XG4gICAgfSk7XG4gIH0sXG4gIGNyZWF0ZVRhYmxlOiB0YWJsZSA9PiB7XG4gICAgdGFibGUuc2V0Q29sdW1uUGlubmluZyA9IHVwZGF0ZXIgPT4gdGFibGUub3B0aW9ucy5vbkNvbHVtblBpbm5pbmdDaGFuZ2UgPT0gbnVsbCA/IHZvaWQgMCA6IHRhYmxlLm9wdGlvbnMub25Db2x1bW5QaW5uaW5nQ2hhbmdlKHVwZGF0ZXIpO1xuICAgIHRhYmxlLnJlc2V0Q29sdW1uUGlubmluZyA9IGRlZmF1bHRTdGF0ZSA9PiB7XG4gICAgICB2YXIgX3RhYmxlJGluaXRpYWxTdGF0ZSRjLCBfdGFibGUkaW5pdGlhbFN0YXRlO1xuICAgICAgcmV0dXJuIHRhYmxlLnNldENvbHVtblBpbm5pbmcoZGVmYXVsdFN0YXRlID8gZ2V0RGVmYXVsdENvbHVtblBpbm5pbmdTdGF0ZSgpIDogKF90YWJsZSRpbml0aWFsU3RhdGUkYyA9IChfdGFibGUkaW5pdGlhbFN0YXRlID0gdGFibGUuaW5pdGlhbFN0YXRlKSA9PSBudWxsID8gdm9pZCAwIDogX3RhYmxlJGluaXRpYWxTdGF0ZS5jb2x1bW5QaW5uaW5nKSAhPSBudWxsID8gX3RhYmxlJGluaXRpYWxTdGF0ZSRjIDogZ2V0RGVmYXVsdENvbHVtblBpbm5pbmdTdGF0ZSgpKTtcbiAgICB9O1xuICAgIHRhYmxlLmdldElzU29tZUNvbHVtbnNQaW5uZWQgPSBwb3NpdGlvbiA9PiB7XG4gICAgICB2YXIgX3Bpbm5pbmdTdGF0ZSRwb3NpdGlvO1xuICAgICAgY29uc3QgcGlubmluZ1N0YXRlID0gdGFibGUuZ2V0U3RhdGUoKS5jb2x1bW5QaW5uaW5nO1xuICAgICAgaWYgKCFwb3NpdGlvbikge1xuICAgICAgICB2YXIgX3Bpbm5pbmdTdGF0ZSRsZWZ0LCBfcGlubmluZ1N0YXRlJHJpZ2h0O1xuICAgICAgICByZXR1cm4gQm9vbGVhbigoKF9waW5uaW5nU3RhdGUkbGVmdCA9IHBpbm5pbmdTdGF0ZS5sZWZ0KSA9PSBudWxsID8gdm9pZCAwIDogX3Bpbm5pbmdTdGF0ZSRsZWZ0Lmxlbmd0aCkgfHwgKChfcGlubmluZ1N0YXRlJHJpZ2h0ID0gcGlubmluZ1N0YXRlLnJpZ2h0KSA9PSBudWxsID8gdm9pZCAwIDogX3Bpbm5pbmdTdGF0ZSRyaWdodC5sZW5ndGgpKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBCb29sZWFuKChfcGlubmluZ1N0YXRlJHBvc2l0aW8gPSBwaW5uaW5nU3RhdGVbcG9zaXRpb25dKSA9PSBudWxsID8gdm9pZCAwIDogX3Bpbm5pbmdTdGF0ZSRwb3NpdGlvLmxlbmd0aCk7XG4gICAgfTtcbiAgICB0YWJsZS5nZXRMZWZ0TGVhZkNvbHVtbnMgPSBtZW1vKCgpID0+IFt0YWJsZS5nZXRBbGxMZWFmQ29sdW1ucygpLCB0YWJsZS5nZXRTdGF0ZSgpLmNvbHVtblBpbm5pbmcubGVmdF0sIChhbGxDb2x1bW5zLCBsZWZ0KSA9PiB7XG4gICAgICByZXR1cm4gKGxlZnQgIT0gbnVsbCA/IGxlZnQgOiBbXSkubWFwKGNvbHVtbklkID0+IGFsbENvbHVtbnMuZmluZChjb2x1bW4gPT4gY29sdW1uLmlkID09PSBjb2x1bW5JZCkpLmZpbHRlcihCb29sZWFuKTtcbiAgICB9LCB7XG4gICAgICBrZXk6IHByb2Nlc3MuZW52Lk5PREVfRU5WID09PSAnZGV2ZWxvcG1lbnQnICYmICdnZXRMZWZ0TGVhZkNvbHVtbnMnLFxuICAgICAgZGVidWc6ICgpID0+IHtcbiAgICAgICAgdmFyIF90YWJsZSRvcHRpb25zJGRlYnVnQTQ7XG4gICAgICAgIHJldHVybiAoX3RhYmxlJG9wdGlvbnMkZGVidWdBNCA9IHRhYmxlLm9wdGlvbnMuZGVidWdBbGwpICE9IG51bGwgPyBfdGFibGUkb3B0aW9ucyRkZWJ1Z0E0IDogdGFibGUub3B0aW9ucy5kZWJ1Z0NvbHVtbnM7XG4gICAgICB9XG4gICAgfSk7XG4gICAgdGFibGUuZ2V0UmlnaHRMZWFmQ29sdW1ucyA9IG1lbW8oKCkgPT4gW3RhYmxlLmdldEFsbExlYWZDb2x1bW5zKCksIHRhYmxlLmdldFN0YXRlKCkuY29sdW1uUGlubmluZy5yaWdodF0sIChhbGxDb2x1bW5zLCByaWdodCkgPT4ge1xuICAgICAgcmV0dXJuIChyaWdodCAhPSBudWxsID8gcmlnaHQgOiBbXSkubWFwKGNvbHVtbklkID0+IGFsbENvbHVtbnMuZmluZChjb2x1bW4gPT4gY29sdW1uLmlkID09PSBjb2x1bW5JZCkpLmZpbHRlcihCb29sZWFuKTtcbiAgICB9LCB7XG4gICAgICBrZXk6IHByb2Nlc3MuZW52Lk5PREVfRU5WID09PSAnZGV2ZWxvcG1lbnQnICYmICdnZXRSaWdodExlYWZDb2x1bW5zJyxcbiAgICAgIGRlYnVnOiAoKSA9PiB7XG4gICAgICAgIHZhciBfdGFibGUkb3B0aW9ucyRkZWJ1Z0E1O1xuICAgICAgICByZXR1cm4gKF90YWJsZSRvcHRpb25zJGRlYnVnQTUgPSB0YWJsZS5vcHRpb25zLmRlYnVnQWxsKSAhPSBudWxsID8gX3RhYmxlJG9wdGlvbnMkZGVidWdBNSA6IHRhYmxlLm9wdGlvbnMuZGVidWdDb2x1bW5zO1xuICAgICAgfVxuICAgIH0pO1xuICAgIHRhYmxlLmdldENlbnRlckxlYWZDb2x1bW5zID0gbWVtbygoKSA9PiBbdGFibGUuZ2V0QWxsTGVhZkNvbHVtbnMoKSwgdGFibGUuZ2V0U3RhdGUoKS5jb2x1bW5QaW5uaW5nLmxlZnQsIHRhYmxlLmdldFN0YXRlKCkuY29sdW1uUGlubmluZy5yaWdodF0sIChhbGxDb2x1bW5zLCBsZWZ0LCByaWdodCkgPT4ge1xuICAgICAgY29uc3QgbGVmdEFuZFJpZ2h0ID0gWy4uLihsZWZ0ICE9IG51bGwgPyBsZWZ0IDogW10pLCAuLi4ocmlnaHQgIT0gbnVsbCA/IHJpZ2h0IDogW10pXTtcbiAgICAgIHJldHVybiBhbGxDb2x1bW5zLmZpbHRlcihkID0+ICFsZWZ0QW5kUmlnaHQuaW5jbHVkZXMoZC5pZCkpO1xuICAgIH0sIHtcbiAgICAgIGtleTogcHJvY2Vzcy5lbnYuTk9ERV9FTlYgPT09ICdkZXZlbG9wbWVudCcgJiYgJ2dldENlbnRlckxlYWZDb2x1bW5zJyxcbiAgICAgIGRlYnVnOiAoKSA9PiB7XG4gICAgICAgIHZhciBfdGFibGUkb3B0aW9ucyRkZWJ1Z0E2O1xuICAgICAgICByZXR1cm4gKF90YWJsZSRvcHRpb25zJGRlYnVnQTYgPSB0YWJsZS5vcHRpb25zLmRlYnVnQWxsKSAhPSBudWxsID8gX3RhYmxlJG9wdGlvbnMkZGVidWdBNiA6IHRhYmxlLm9wdGlvbnMuZGVidWdDb2x1bW5zO1xuICAgICAgfVxuICAgIH0pO1xuICAgIHRhYmxlLnNldFJvd1Bpbm5pbmcgPSB1cGRhdGVyID0+IHRhYmxlLm9wdGlvbnMub25Sb3dQaW5uaW5nQ2hhbmdlID09IG51bGwgPyB2b2lkIDAgOiB0YWJsZS5vcHRpb25zLm9uUm93UGlubmluZ0NoYW5nZSh1cGRhdGVyKTtcbiAgICB0YWJsZS5yZXNldFJvd1Bpbm5pbmcgPSBkZWZhdWx0U3RhdGUgPT4ge1xuICAgICAgdmFyIF90YWJsZSRpbml0aWFsU3RhdGUkciwgX3RhYmxlJGluaXRpYWxTdGF0ZTI7XG4gICAgICByZXR1cm4gdGFibGUuc2V0Um93UGlubmluZyhkZWZhdWx0U3RhdGUgPyBnZXREZWZhdWx0Um93UGlubmluZ1N0YXRlKCkgOiAoX3RhYmxlJGluaXRpYWxTdGF0ZSRyID0gKF90YWJsZSRpbml0aWFsU3RhdGUyID0gdGFibGUuaW5pdGlhbFN0YXRlKSA9PSBudWxsID8gdm9pZCAwIDogX3RhYmxlJGluaXRpYWxTdGF0ZTIucm93UGlubmluZykgIT0gbnVsbCA/IF90YWJsZSRpbml0aWFsU3RhdGUkciA6IGdldERlZmF1bHRSb3dQaW5uaW5nU3RhdGUoKSk7XG4gICAgfTtcbiAgICB0YWJsZS5nZXRJc1NvbWVSb3dzUGlubmVkID0gcG9zaXRpb24gPT4ge1xuICAgICAgdmFyIF9waW5uaW5nU3RhdGUkcG9zaXRpbzI7XG4gICAgICBjb25zdCBwaW5uaW5nU3RhdGUgPSB0YWJsZS5nZXRTdGF0ZSgpLnJvd1Bpbm5pbmc7XG4gICAgICBpZiAoIXBvc2l0aW9uKSB7XG4gICAgICAgIHZhciBfcGlubmluZ1N0YXRlJHRvcCwgX3Bpbm5pbmdTdGF0ZSRib3R0b207XG4gICAgICAgIHJldHVybiBCb29sZWFuKCgoX3Bpbm5pbmdTdGF0ZSR0b3AgPSBwaW5uaW5nU3RhdGUudG9wKSA9PSBudWxsID8gdm9pZCAwIDogX3Bpbm5pbmdTdGF0ZSR0b3AubGVuZ3RoKSB8fCAoKF9waW5uaW5nU3RhdGUkYm90dG9tID0gcGlubmluZ1N0YXRlLmJvdHRvbSkgPT0gbnVsbCA/IHZvaWQgMCA6IF9waW5uaW5nU3RhdGUkYm90dG9tLmxlbmd0aCkpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIEJvb2xlYW4oKF9waW5uaW5nU3RhdGUkcG9zaXRpbzIgPSBwaW5uaW5nU3RhdGVbcG9zaXRpb25dKSA9PSBudWxsID8gdm9pZCAwIDogX3Bpbm5pbmdTdGF0ZSRwb3NpdGlvMi5sZW5ndGgpO1xuICAgIH07XG4gICAgdGFibGUuX2dldFBpbm5lZFJvd3MgPSBwb3NpdGlvbiA9PiBtZW1vKCgpID0+IFt0YWJsZS5nZXRSb3dNb2RlbCgpLnJvd3MsIHRhYmxlLmdldFN0YXRlKCkucm93UGlubmluZ1twb3NpdGlvbl1dLCAodmlzaWJsZVJvd3MsIHBpbm5lZFJvd0lkcykgPT4ge1xuICAgICAgdmFyIF90YWJsZSRvcHRpb25zJGtlZXBQaTtcbiAgICAgIGNvbnN0IHJvd3MgPSAoKF90YWJsZSRvcHRpb25zJGtlZXBQaSA9IHRhYmxlLm9wdGlvbnMua2VlcFBpbm5lZFJvd3MpICE9IG51bGwgPyBfdGFibGUkb3B0aW9ucyRrZWVwUGkgOiB0cnVlKSA/XG4gICAgICAvL2dldCBhbGwgcm93cyB0aGF0IGFyZSBwaW5uZWQgZXZlbiBpZiB0aGV5IHdvdWxkIG5vdCBiZSBvdGhlcndpc2UgdmlzaWJsZVxuICAgICAgLy9hY2NvdW50IGZvciBleHBhbmRlZCBwYXJlbnQgcm93cywgYnV0IG5vdCBwYWdpbmF0aW9uIG9yIGZpbHRlcmluZ1xuICAgICAgKHBpbm5lZFJvd0lkcyAhPSBudWxsID8gcGlubmVkUm93SWRzIDogW10pLm1hcChyb3dJZCA9PiB7XG4gICAgICAgIGNvbnN0IHJvdyA9IHRhYmxlLmdldFJvdyhyb3dJZCwgdHJ1ZSk7XG4gICAgICAgIHJldHVybiByb3cuZ2V0SXNBbGxQYXJlbnRzRXhwYW5kZWQoKSA/IHJvdyA6IG51bGw7XG4gICAgICB9KSA6XG4gICAgICAvL2Vsc2UgZ2V0IG9ubHkgdmlzaWJsZSByb3dzIHRoYXQgYXJlIHBpbm5lZFxuICAgICAgKHBpbm5lZFJvd0lkcyAhPSBudWxsID8gcGlubmVkUm93SWRzIDogW10pLm1hcChyb3dJZCA9PiB2aXNpYmxlUm93cy5maW5kKHJvdyA9PiByb3cuaWQgPT09IHJvd0lkKSk7XG4gICAgICByZXR1cm4gcm93cy5maWx0ZXIoQm9vbGVhbikubWFwKGQgPT4gKHtcbiAgICAgICAgLi4uZCxcbiAgICAgICAgcG9zaXRpb25cbiAgICAgIH0pKTtcbiAgICB9LCB7XG4gICAgICBrZXk6IHByb2Nlc3MuZW52Lk5PREVfRU5WID09PSAnZGV2ZWxvcG1lbnQnICYmIGByb3cuZ2V0JHtwb3NpdGlvbiA9PT0gJ3RvcCcgPyAnVG9wJyA6ICdCb3R0b20nfVJvd3NgLFxuICAgICAgZGVidWc6ICgpID0+IHtcbiAgICAgICAgdmFyIF90YWJsZSRvcHRpb25zJGRlYnVnQTc7XG4gICAgICAgIHJldHVybiAoX3RhYmxlJG9wdGlvbnMkZGVidWdBNyA9IHRhYmxlLm9wdGlvbnMuZGVidWdBbGwpICE9IG51bGwgPyBfdGFibGUkb3B0aW9ucyRkZWJ1Z0E3IDogdGFibGUub3B0aW9ucy5kZWJ1Z1Jvd3M7XG4gICAgICB9XG4gICAgfSkoKTtcbiAgICB0YWJsZS5nZXRUb3BSb3dzID0gKCkgPT4gdGFibGUuX2dldFBpbm5lZFJvd3MoJ3RvcCcpO1xuICAgIHRhYmxlLmdldEJvdHRvbVJvd3MgPSAoKSA9PiB0YWJsZS5fZ2V0UGlubmVkUm93cygnYm90dG9tJyk7XG4gICAgdGFibGUuZ2V0Q2VudGVyUm93cyA9IG1lbW8oKCkgPT4gW3RhYmxlLmdldFJvd01vZGVsKCkucm93cywgdGFibGUuZ2V0U3RhdGUoKS5yb3dQaW5uaW5nLnRvcCwgdGFibGUuZ2V0U3RhdGUoKS5yb3dQaW5uaW5nLmJvdHRvbV0sIChhbGxSb3dzLCB0b3AsIGJvdHRvbSkgPT4ge1xuICAgICAgY29uc3QgdG9wQW5kQm90dG9tID0gbmV3IFNldChbLi4uKHRvcCAhPSBudWxsID8gdG9wIDogW10pLCAuLi4oYm90dG9tICE9IG51bGwgPyBib3R0b20gOiBbXSldKTtcbiAgICAgIHJldHVybiBhbGxSb3dzLmZpbHRlcihkID0+ICF0b3BBbmRCb3R0b20uaGFzKGQuaWQpKTtcbiAgICB9LCB7XG4gICAgICBrZXk6IHByb2Nlc3MuZW52Lk5PREVfRU5WID09PSAnZGV2ZWxvcG1lbnQnICYmICdyb3cuZ2V0Q2VudGVyUm93cycsXG4gICAgICBkZWJ1ZzogKCkgPT4ge1xuICAgICAgICB2YXIgX3RhYmxlJG9wdGlvbnMkZGVidWdBODtcbiAgICAgICAgcmV0dXJuIChfdGFibGUkb3B0aW9ucyRkZWJ1Z0E4ID0gdGFibGUub3B0aW9ucy5kZWJ1Z0FsbCkgIT0gbnVsbCA/IF90YWJsZSRvcHRpb25zJGRlYnVnQTggOiB0YWJsZS5vcHRpb25zLmRlYnVnUm93cztcbiAgICAgIH1cbiAgICB9KTtcbiAgfVxufTtcblxuLy9cblxuY29uc3QgUm93U2VsZWN0aW9uID0ge1xuICBnZXRJbml0aWFsU3RhdGU6IHN0YXRlID0+IHtcbiAgICByZXR1cm4ge1xuICAgICAgcm93U2VsZWN0aW9uOiB7fSxcbiAgICAgIC4uLnN0YXRlXG4gICAgfTtcbiAgfSxcbiAgZ2V0RGVmYXVsdE9wdGlvbnM6IHRhYmxlID0+IHtcbiAgICByZXR1cm4ge1xuICAgICAgb25Sb3dTZWxlY3Rpb25DaGFuZ2U6IG1ha2VTdGF0ZVVwZGF0ZXIoJ3Jvd1NlbGVjdGlvbicsIHRhYmxlKSxcbiAgICAgIGVuYWJsZVJvd1NlbGVjdGlvbjogdHJ1ZSxcbiAgICAgIGVuYWJsZU11bHRpUm93U2VsZWN0aW9uOiB0cnVlLFxuICAgICAgZW5hYmxlU3ViUm93U2VsZWN0aW9uOiB0cnVlXG4gICAgICAvLyBlbmFibGVHcm91cGluZ1Jvd1NlbGVjdGlvbjogZmFsc2UsXG4gICAgICAvLyBpc0FkZGl0aXZlU2VsZWN0RXZlbnQ6IChlOiB1bmtub3duKSA9PiAhIWUubWV0YUtleSxcbiAgICAgIC8vIGlzSW5jbHVzaXZlU2VsZWN0RXZlbnQ6IChlOiB1bmtub3duKSA9PiAhIWUuc2hpZnRLZXksXG4gICAgfTtcbiAgfSxcbiAgY3JlYXRlVGFibGU6IHRhYmxlID0+IHtcbiAgICB0YWJsZS5zZXRSb3dTZWxlY3Rpb24gPSB1cGRhdGVyID0+IHRhYmxlLm9wdGlvbnMub25Sb3dTZWxlY3Rpb25DaGFuZ2UgPT0gbnVsbCA/IHZvaWQgMCA6IHRhYmxlLm9wdGlvbnMub25Sb3dTZWxlY3Rpb25DaGFuZ2UodXBkYXRlcik7XG4gICAgdGFibGUucmVzZXRSb3dTZWxlY3Rpb24gPSBkZWZhdWx0U3RhdGUgPT4ge1xuICAgICAgdmFyIF90YWJsZSRpbml0aWFsU3RhdGUkcjtcbiAgICAgIHJldHVybiB0YWJsZS5zZXRSb3dTZWxlY3Rpb24oZGVmYXVsdFN0YXRlID8ge30gOiAoX3RhYmxlJGluaXRpYWxTdGF0ZSRyID0gdGFibGUuaW5pdGlhbFN0YXRlLnJvd1NlbGVjdGlvbikgIT0gbnVsbCA/IF90YWJsZSRpbml0aWFsU3RhdGUkciA6IHt9KTtcbiAgICB9O1xuICAgIHRhYmxlLnRvZ2dsZUFsbFJvd3NTZWxlY3RlZCA9IHZhbHVlID0+IHtcbiAgICAgIHRhYmxlLnNldFJvd1NlbGVjdGlvbihvbGQgPT4ge1xuICAgICAgICB2YWx1ZSA9IHR5cGVvZiB2YWx1ZSAhPT0gJ3VuZGVmaW5lZCcgPyB2YWx1ZSA6ICF0YWJsZS5nZXRJc0FsbFJvd3NTZWxlY3RlZCgpO1xuICAgICAgICBjb25zdCByb3dTZWxlY3Rpb24gPSB7XG4gICAgICAgICAgLi4ub2xkXG4gICAgICAgIH07XG4gICAgICAgIGNvbnN0IHByZUdyb3VwZWRGbGF0Um93cyA9IHRhYmxlLmdldFByZUdyb3VwZWRSb3dNb2RlbCgpLmZsYXRSb3dzO1xuXG4gICAgICAgIC8vIFdlIGRvbid0IHVzZSBgbXV0YXRlUm93SXNTZWxlY3RlZGAgaGVyZSBmb3IgcGVyZm9ybWFuY2UgcmVhc29ucy5cbiAgICAgICAgLy8gQWxsIG9mIHRoZSByb3dzIGFyZSBmbGF0IGFscmVhZHksIHNvIGl0IHdvdWxkbid0IGJlIHdvcnRoIGl0XG4gICAgICAgIGlmICh2YWx1ZSkge1xuICAgICAgICAgIHByZUdyb3VwZWRGbGF0Um93cy5mb3JFYWNoKHJvdyA9PiB7XG4gICAgICAgICAgICBpZiAoIXJvdy5nZXRDYW5TZWxlY3QoKSkge1xuICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByb3dTZWxlY3Rpb25bcm93LmlkXSA9IHRydWU7XG4gICAgICAgICAgfSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgcHJlR3JvdXBlZEZsYXRSb3dzLmZvckVhY2gocm93ID0+IHtcbiAgICAgICAgICAgIGRlbGV0ZSByb3dTZWxlY3Rpb25bcm93LmlkXTtcbiAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcm93U2VsZWN0aW9uO1xuICAgICAgfSk7XG4gICAgfTtcbiAgICB0YWJsZS50b2dnbGVBbGxQYWdlUm93c1NlbGVjdGVkID0gdmFsdWUgPT4gdGFibGUuc2V0Um93U2VsZWN0aW9uKG9sZCA9PiB7XG4gICAgICBjb25zdCByZXNvbHZlZFZhbHVlID0gdHlwZW9mIHZhbHVlICE9PSAndW5kZWZpbmVkJyA/IHZhbHVlIDogIXRhYmxlLmdldElzQWxsUGFnZVJvd3NTZWxlY3RlZCgpO1xuICAgICAgY29uc3Qgcm93U2VsZWN0aW9uID0ge1xuICAgICAgICAuLi5vbGRcbiAgICAgIH07XG4gICAgICB0YWJsZS5nZXRSb3dNb2RlbCgpLnJvd3MuZm9yRWFjaChyb3cgPT4ge1xuICAgICAgICBtdXRhdGVSb3dJc1NlbGVjdGVkKHJvd1NlbGVjdGlvbiwgcm93LmlkLCByZXNvbHZlZFZhbHVlLCB0cnVlLCB0YWJsZSk7XG4gICAgICB9KTtcbiAgICAgIHJldHVybiByb3dTZWxlY3Rpb247XG4gICAgfSk7XG5cbiAgICAvLyBhZGRSb3dTZWxlY3Rpb25SYW5nZTogcm93SWQgPT4ge1xuICAgIC8vICAgY29uc3Qge1xuICAgIC8vICAgICByb3dzLFxuICAgIC8vICAgICByb3dzQnlJZCxcbiAgICAvLyAgICAgb3B0aW9uczogeyBzZWxlY3RHcm91cGluZ1Jvd3MsIHNlbGVjdFN1YlJvd3MgfSxcbiAgICAvLyAgIH0gPSB0YWJsZVxuXG4gICAgLy8gICBjb25zdCBmaW5kU2VsZWN0ZWRSb3cgPSAocm93czogUm93W10pID0+IHtcbiAgICAvLyAgICAgbGV0IGZvdW5kXG4gICAgLy8gICAgIHJvd3MuZmluZChkID0+IHtcbiAgICAvLyAgICAgICBpZiAoZC5nZXRJc1NlbGVjdGVkKCkpIHtcbiAgICAvLyAgICAgICAgIGZvdW5kID0gZFxuICAgIC8vICAgICAgICAgcmV0dXJuIHRydWVcbiAgICAvLyAgICAgICB9XG4gICAgLy8gICAgICAgY29uc3Qgc3ViRm91bmQgPSBmaW5kU2VsZWN0ZWRSb3coZC5zdWJSb3dzIHx8IFtdKVxuICAgIC8vICAgICAgIGlmIChzdWJGb3VuZCkge1xuICAgIC8vICAgICAgICAgZm91bmQgPSBzdWJGb3VuZFxuICAgIC8vICAgICAgICAgcmV0dXJuIHRydWVcbiAgICAvLyAgICAgICB9XG4gICAgLy8gICAgICAgcmV0dXJuIGZhbHNlXG4gICAgLy8gICAgIH0pXG4gICAgLy8gICAgIHJldHVybiBmb3VuZFxuICAgIC8vICAgfVxuXG4gICAgLy8gICBjb25zdCBmaXJzdFJvdyA9IGZpbmRTZWxlY3RlZFJvdyhyb3dzKSB8fCByb3dzWzBdXG4gICAgLy8gICBjb25zdCBsYXN0Um93ID0gcm93c0J5SWRbcm93SWRdXG5cbiAgICAvLyAgIGxldCBpbmNsdWRlID0gZmFsc2VcbiAgICAvLyAgIGNvbnN0IHNlbGVjdGVkUm93SWRzID0ge31cblxuICAgIC8vICAgY29uc3QgYWRkUm93ID0gKHJvdzogUm93KSA9PiB7XG4gICAgLy8gICAgIG11dGF0ZVJvd0lzU2VsZWN0ZWQoc2VsZWN0ZWRSb3dJZHMsIHJvdy5pZCwgdHJ1ZSwge1xuICAgIC8vICAgICAgIHJvd3NCeUlkLFxuICAgIC8vICAgICAgIHNlbGVjdEdyb3VwaW5nUm93czogc2VsZWN0R3JvdXBpbmdSb3dzISxcbiAgICAvLyAgICAgICBzZWxlY3RTdWJSb3dzOiBzZWxlY3RTdWJSb3dzISxcbiAgICAvLyAgICAgfSlcbiAgICAvLyAgIH1cblxuICAgIC8vICAgdGFibGUucm93cy5mb3JFYWNoKHJvdyA9PiB7XG4gICAgLy8gICAgIGNvbnN0IGlzRmlyc3RSb3cgPSByb3cuaWQgPT09IGZpcnN0Um93LmlkXG4gICAgLy8gICAgIGNvbnN0IGlzTGFzdFJvdyA9IHJvdy5pZCA9PT0gbGFzdFJvdy5pZFxuXG4gICAgLy8gICAgIGlmIChpc0ZpcnN0Um93IHx8IGlzTGFzdFJvdykge1xuICAgIC8vICAgICAgIGlmICghaW5jbHVkZSkge1xuICAgIC8vICAgICAgICAgaW5jbHVkZSA9IHRydWVcbiAgICAvLyAgICAgICB9IGVsc2UgaWYgKGluY2x1ZGUpIHtcbiAgICAvLyAgICAgICAgIGFkZFJvdyhyb3cpXG4gICAgLy8gICAgICAgICBpbmNsdWRlID0gZmFsc2VcbiAgICAvLyAgICAgICB9XG4gICAgLy8gICAgIH1cblxuICAgIC8vICAgICBpZiAoaW5jbHVkZSkge1xuICAgIC8vICAgICAgIGFkZFJvdyhyb3cpXG4gICAgLy8gICAgIH1cbiAgICAvLyAgIH0pXG5cbiAgICAvLyAgIHRhYmxlLnNldFJvd1NlbGVjdGlvbihzZWxlY3RlZFJvd0lkcylcbiAgICAvLyB9LFxuICAgIHRhYmxlLmdldFByZVNlbGVjdGVkUm93TW9kZWwgPSAoKSA9PiB0YWJsZS5nZXRDb3JlUm93TW9kZWwoKTtcbiAgICB0YWJsZS5nZXRTZWxlY3RlZFJvd01vZGVsID0gbWVtbygoKSA9PiBbdGFibGUuZ2V0U3RhdGUoKS5yb3dTZWxlY3Rpb24sIHRhYmxlLmdldENvcmVSb3dNb2RlbCgpXSwgKHJvd1NlbGVjdGlvbiwgcm93TW9kZWwpID0+IHtcbiAgICAgIGlmICghT2JqZWN0LmtleXMocm93U2VsZWN0aW9uKS5sZW5ndGgpIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICByb3dzOiBbXSxcbiAgICAgICAgICBmbGF0Um93czogW10sXG4gICAgICAgICAgcm93c0J5SWQ6IHt9XG4gICAgICAgIH07XG4gICAgICB9XG4gICAgICByZXR1cm4gc2VsZWN0Um93c0ZuKHRhYmxlLCByb3dNb2RlbCk7XG4gICAgfSwge1xuICAgICAga2V5OiBwcm9jZXNzLmVudi5OT0RFX0VOViA9PT0gJ2RldmVsb3BtZW50JyAmJiAnZ2V0U2VsZWN0ZWRSb3dNb2RlbCcsXG4gICAgICBkZWJ1ZzogKCkgPT4ge1xuICAgICAgICB2YXIgX3RhYmxlJG9wdGlvbnMkZGVidWdBO1xuICAgICAgICByZXR1cm4gKF90YWJsZSRvcHRpb25zJGRlYnVnQSA9IHRhYmxlLm9wdGlvbnMuZGVidWdBbGwpICE9IG51bGwgPyBfdGFibGUkb3B0aW9ucyRkZWJ1Z0EgOiB0YWJsZS5vcHRpb25zLmRlYnVnVGFibGU7XG4gICAgICB9XG4gICAgfSk7XG4gICAgdGFibGUuZ2V0RmlsdGVyZWRTZWxlY3RlZFJvd01vZGVsID0gbWVtbygoKSA9PiBbdGFibGUuZ2V0U3RhdGUoKS5yb3dTZWxlY3Rpb24sIHRhYmxlLmdldEZpbHRlcmVkUm93TW9kZWwoKV0sIChyb3dTZWxlY3Rpb24sIHJvd01vZGVsKSA9PiB7XG4gICAgICBpZiAoIU9iamVjdC5rZXlzKHJvd1NlbGVjdGlvbikubGVuZ3RoKSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgcm93czogW10sXG4gICAgICAgICAgZmxhdFJvd3M6IFtdLFxuICAgICAgICAgIHJvd3NCeUlkOiB7fVxuICAgICAgICB9O1xuICAgICAgfVxuICAgICAgcmV0dXJuIHNlbGVjdFJvd3NGbih0YWJsZSwgcm93TW9kZWwpO1xuICAgIH0sIHtcbiAgICAgIGtleTogcHJvY2Vzcy5lbnYuTk9ERV9FTlYgPT09ICdwcm9kdWN0aW9uJyAmJiAnZ2V0RmlsdGVyZWRTZWxlY3RlZFJvd01vZGVsJyxcbiAgICAgIGRlYnVnOiAoKSA9PiB7XG4gICAgICAgIHZhciBfdGFibGUkb3B0aW9ucyRkZWJ1Z0EyO1xuICAgICAgICByZXR1cm4gKF90YWJsZSRvcHRpb25zJGRlYnVnQTIgPSB0YWJsZS5vcHRpb25zLmRlYnVnQWxsKSAhPSBudWxsID8gX3RhYmxlJG9wdGlvbnMkZGVidWdBMiA6IHRhYmxlLm9wdGlvbnMuZGVidWdUYWJsZTtcbiAgICAgIH1cbiAgICB9KTtcbiAgICB0YWJsZS5nZXRHcm91cGVkU2VsZWN0ZWRSb3dNb2RlbCA9IG1lbW8oKCkgPT4gW3RhYmxlLmdldFN0YXRlKCkucm93U2VsZWN0aW9uLCB0YWJsZS5nZXRTb3J0ZWRSb3dNb2RlbCgpXSwgKHJvd1NlbGVjdGlvbiwgcm93TW9kZWwpID0+IHtcbiAgICAgIGlmICghT2JqZWN0LmtleXMocm93U2VsZWN0aW9uKS5sZW5ndGgpIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICByb3dzOiBbXSxcbiAgICAgICAgICBmbGF0Um93czogW10sXG4gICAgICAgICAgcm93c0J5SWQ6IHt9XG4gICAgICAgIH07XG4gICAgICB9XG4gICAgICByZXR1cm4gc2VsZWN0Um93c0ZuKHRhYmxlLCByb3dNb2RlbCk7XG4gICAgfSwge1xuICAgICAga2V5OiBwcm9jZXNzLmVudi5OT0RFX0VOViA9PT0gJ3Byb2R1Y3Rpb24nICYmICdnZXRHcm91cGVkU2VsZWN0ZWRSb3dNb2RlbCcsXG4gICAgICBkZWJ1ZzogKCkgPT4ge1xuICAgICAgICB2YXIgX3RhYmxlJG9wdGlvbnMkZGVidWdBMztcbiAgICAgICAgcmV0dXJuIChfdGFibGUkb3B0aW9ucyRkZWJ1Z0EzID0gdGFibGUub3B0aW9ucy5kZWJ1Z0FsbCkgIT0gbnVsbCA/IF90YWJsZSRvcHRpb25zJGRlYnVnQTMgOiB0YWJsZS5vcHRpb25zLmRlYnVnVGFibGU7XG4gICAgICB9XG4gICAgfSk7XG5cbiAgICAvLy9cblxuICAgIC8vIGdldEdyb3VwaW5nUm93Q2FuU2VsZWN0OiByb3dJZCA9PiB7XG4gICAgLy8gICBjb25zdCByb3cgPSB0YWJsZS5nZXRSb3cocm93SWQpXG5cbiAgICAvLyAgIGlmICghcm93KSB7XG4gICAgLy8gICAgIHRocm93IG5ldyBFcnJvcigpXG4gICAgLy8gICB9XG5cbiAgICAvLyAgIGlmICh0eXBlb2YgdGFibGUub3B0aW9ucy5lbmFibGVHcm91cGluZ1Jvd1NlbGVjdGlvbiA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIC8vICAgICByZXR1cm4gdGFibGUub3B0aW9ucy5lbmFibGVHcm91cGluZ1Jvd1NlbGVjdGlvbihyb3cpXG4gICAgLy8gICB9XG5cbiAgICAvLyAgIHJldHVybiB0YWJsZS5vcHRpb25zLmVuYWJsZUdyb3VwaW5nUm93U2VsZWN0aW9uID8/IGZhbHNlXG4gICAgLy8gfSxcblxuICAgIHRhYmxlLmdldElzQWxsUm93c1NlbGVjdGVkID0gKCkgPT4ge1xuICAgICAgY29uc3QgcHJlR3JvdXBlZEZsYXRSb3dzID0gdGFibGUuZ2V0RmlsdGVyZWRSb3dNb2RlbCgpLmZsYXRSb3dzO1xuICAgICAgY29uc3Qge1xuICAgICAgICByb3dTZWxlY3Rpb25cbiAgICAgIH0gPSB0YWJsZS5nZXRTdGF0ZSgpO1xuICAgICAgbGV0IGlzQWxsUm93c1NlbGVjdGVkID0gQm9vbGVhbihwcmVHcm91cGVkRmxhdFJvd3MubGVuZ3RoICYmIE9iamVjdC5rZXlzKHJvd1NlbGVjdGlvbikubGVuZ3RoKTtcbiAgICAgIGlmIChpc0FsbFJvd3NTZWxlY3RlZCkge1xuICAgICAgICBpZiAocHJlR3JvdXBlZEZsYXRSb3dzLnNvbWUocm93ID0+IHJvdy5nZXRDYW5TZWxlY3QoKSAmJiAhcm93U2VsZWN0aW9uW3Jvdy5pZF0pKSB7XG4gICAgICAgICAgaXNBbGxSb3dzU2VsZWN0ZWQgPSBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIGlzQWxsUm93c1NlbGVjdGVkO1xuICAgIH07XG4gICAgdGFibGUuZ2V0SXNBbGxQYWdlUm93c1NlbGVjdGVkID0gKCkgPT4ge1xuICAgICAgY29uc3QgcGFnaW5hdGlvbkZsYXRSb3dzID0gdGFibGUuZ2V0UGFnaW5hdGlvblJvd01vZGVsKCkuZmxhdFJvd3MuZmlsdGVyKHJvdyA9PiByb3cuZ2V0Q2FuU2VsZWN0KCkpO1xuICAgICAgY29uc3Qge1xuICAgICAgICByb3dTZWxlY3Rpb25cbiAgICAgIH0gPSB0YWJsZS5nZXRTdGF0ZSgpO1xuICAgICAgbGV0IGlzQWxsUGFnZVJvd3NTZWxlY3RlZCA9ICEhcGFnaW5hdGlvbkZsYXRSb3dzLmxlbmd0aDtcbiAgICAgIGlmIChpc0FsbFBhZ2VSb3dzU2VsZWN0ZWQgJiYgcGFnaW5hdGlvbkZsYXRSb3dzLnNvbWUocm93ID0+ICFyb3dTZWxlY3Rpb25bcm93LmlkXSkpIHtcbiAgICAgICAgaXNBbGxQYWdlUm93c1NlbGVjdGVkID0gZmFsc2U7XG4gICAgICB9XG4gICAgICByZXR1cm4gaXNBbGxQYWdlUm93c1NlbGVjdGVkO1xuICAgIH07XG4gICAgdGFibGUuZ2V0SXNTb21lUm93c1NlbGVjdGVkID0gKCkgPT4ge1xuICAgICAgdmFyIF90YWJsZSRnZXRTdGF0ZSRyb3dTZTtcbiAgICAgIGNvbnN0IHRvdGFsU2VsZWN0ZWQgPSBPYmplY3Qua2V5cygoX3RhYmxlJGdldFN0YXRlJHJvd1NlID0gdGFibGUuZ2V0U3RhdGUoKS5yb3dTZWxlY3Rpb24pICE9IG51bGwgPyBfdGFibGUkZ2V0U3RhdGUkcm93U2UgOiB7fSkubGVuZ3RoO1xuICAgICAgcmV0dXJuIHRvdGFsU2VsZWN0ZWQgPiAwICYmIHRvdGFsU2VsZWN0ZWQgPCB0YWJsZS5nZXRGaWx0ZXJlZFJvd01vZGVsKCkuZmxhdFJvd3MubGVuZ3RoO1xuICAgIH07XG4gICAgdGFibGUuZ2V0SXNTb21lUGFnZVJvd3NTZWxlY3RlZCA9ICgpID0+IHtcbiAgICAgIGNvbnN0IHBhZ2luYXRpb25GbGF0Um93cyA9IHRhYmxlLmdldFBhZ2luYXRpb25Sb3dNb2RlbCgpLmZsYXRSb3dzO1xuICAgICAgcmV0dXJuIHRhYmxlLmdldElzQWxsUGFnZVJvd3NTZWxlY3RlZCgpID8gZmFsc2UgOiBwYWdpbmF0aW9uRmxhdFJvd3MuZmlsdGVyKHJvdyA9PiByb3cuZ2V0Q2FuU2VsZWN0KCkpLnNvbWUoZCA9PiBkLmdldElzU2VsZWN0ZWQoKSB8fCBkLmdldElzU29tZVNlbGVjdGVkKCkpO1xuICAgIH07XG4gICAgdGFibGUuZ2V0VG9nZ2xlQWxsUm93c1NlbGVjdGVkSGFuZGxlciA9ICgpID0+IHtcbiAgICAgIHJldHVybiBlID0+IHtcbiAgICAgICAgdGFibGUudG9nZ2xlQWxsUm93c1NlbGVjdGVkKGUudGFyZ2V0LmNoZWNrZWQpO1xuICAgICAgfTtcbiAgICB9O1xuICAgIHRhYmxlLmdldFRvZ2dsZUFsbFBhZ2VSb3dzU2VsZWN0ZWRIYW5kbGVyID0gKCkgPT4ge1xuICAgICAgcmV0dXJuIGUgPT4ge1xuICAgICAgICB0YWJsZS50b2dnbGVBbGxQYWdlUm93c1NlbGVjdGVkKGUudGFyZ2V0LmNoZWNrZWQpO1xuICAgICAgfTtcbiAgICB9O1xuICB9LFxuICBjcmVhdGVSb3c6IChyb3csIHRhYmxlKSA9PiB7XG4gICAgcm93LnRvZ2dsZVNlbGVjdGVkID0gKHZhbHVlLCBvcHRzKSA9PiB7XG4gICAgICBjb25zdCBpc1NlbGVjdGVkID0gcm93LmdldElzU2VsZWN0ZWQoKTtcbiAgICAgIHRhYmxlLnNldFJvd1NlbGVjdGlvbihvbGQgPT4ge1xuICAgICAgICB2YXIgX29wdHMkc2VsZWN0Q2hpbGRyZW47XG4gICAgICAgIHZhbHVlID0gdHlwZW9mIHZhbHVlICE9PSAndW5kZWZpbmVkJyA/IHZhbHVlIDogIWlzU2VsZWN0ZWQ7XG4gICAgICAgIGlmIChyb3cuZ2V0Q2FuU2VsZWN0KCkgJiYgaXNTZWxlY3RlZCA9PT0gdmFsdWUpIHtcbiAgICAgICAgICByZXR1cm4gb2xkO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHNlbGVjdGVkUm93SWRzID0ge1xuICAgICAgICAgIC4uLm9sZFxuICAgICAgICB9O1xuICAgICAgICBtdXRhdGVSb3dJc1NlbGVjdGVkKHNlbGVjdGVkUm93SWRzLCByb3cuaWQsIHZhbHVlLCAoX29wdHMkc2VsZWN0Q2hpbGRyZW4gPSBvcHRzID09IG51bGwgPyB2b2lkIDAgOiBvcHRzLnNlbGVjdENoaWxkcmVuKSAhPSBudWxsID8gX29wdHMkc2VsZWN0Q2hpbGRyZW4gOiB0cnVlLCB0YWJsZSk7XG4gICAgICAgIHJldHVybiBzZWxlY3RlZFJvd0lkcztcbiAgICAgIH0pO1xuICAgIH07XG4gICAgcm93LmdldElzU2VsZWN0ZWQgPSAoKSA9PiB7XG4gICAgICBjb25zdCB7XG4gICAgICAgIHJvd1NlbGVjdGlvblxuICAgICAgfSA9IHRhYmxlLmdldFN0YXRlKCk7XG4gICAgICByZXR1cm4gaXNSb3dTZWxlY3RlZChyb3csIHJvd1NlbGVjdGlvbik7XG4gICAgfTtcbiAgICByb3cuZ2V0SXNTb21lU2VsZWN0ZWQgPSAoKSA9PiB7XG4gICAgICBjb25zdCB7XG4gICAgICAgIHJvd1NlbGVjdGlvblxuICAgICAgfSA9IHRhYmxlLmdldFN0YXRlKCk7XG4gICAgICByZXR1cm4gaXNTdWJSb3dTZWxlY3RlZChyb3csIHJvd1NlbGVjdGlvbikgPT09ICdzb21lJztcbiAgICB9O1xuICAgIHJvdy5nZXRJc0FsbFN1YlJvd3NTZWxlY3RlZCA9ICgpID0+IHtcbiAgICAgIGNvbnN0IHtcbiAgICAgICAgcm93U2VsZWN0aW9uXG4gICAgICB9ID0gdGFibGUuZ2V0U3RhdGUoKTtcbiAgICAgIHJldHVybiBpc1N1YlJvd1NlbGVjdGVkKHJvdywgcm93U2VsZWN0aW9uKSA9PT0gJ2FsbCc7XG4gICAgfTtcbiAgICByb3cuZ2V0Q2FuU2VsZWN0ID0gKCkgPT4ge1xuICAgICAgdmFyIF90YWJsZSRvcHRpb25zJGVuYWJsZTtcbiAgICAgIGlmICh0eXBlb2YgdGFibGUub3B0aW9ucy5lbmFibGVSb3dTZWxlY3Rpb24gPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgcmV0dXJuIHRhYmxlLm9wdGlvbnMuZW5hYmxlUm93U2VsZWN0aW9uKHJvdyk7XG4gICAgICB9XG4gICAgICByZXR1cm4gKF90YWJsZSRvcHRpb25zJGVuYWJsZSA9IHRhYmxlLm9wdGlvbnMuZW5hYmxlUm93U2VsZWN0aW9uKSAhPSBudWxsID8gX3RhYmxlJG9wdGlvbnMkZW5hYmxlIDogdHJ1ZTtcbiAgICB9O1xuICAgIHJvdy5nZXRDYW5TZWxlY3RTdWJSb3dzID0gKCkgPT4ge1xuICAgICAgdmFyIF90YWJsZSRvcHRpb25zJGVuYWJsZTI7XG4gICAgICBpZiAodHlwZW9mIHRhYmxlLm9wdGlvbnMuZW5hYmxlU3ViUm93U2VsZWN0aW9uID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgIHJldHVybiB0YWJsZS5vcHRpb25zLmVuYWJsZVN1YlJvd1NlbGVjdGlvbihyb3cpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIChfdGFibGUkb3B0aW9ucyRlbmFibGUyID0gdGFibGUub3B0aW9ucy5lbmFibGVTdWJSb3dTZWxlY3Rpb24pICE9IG51bGwgPyBfdGFibGUkb3B0aW9ucyRlbmFibGUyIDogdHJ1ZTtcbiAgICB9O1xuICAgIHJvdy5nZXRDYW5NdWx0aVNlbGVjdCA9ICgpID0+IHtcbiAgICAgIHZhciBfdGFibGUkb3B0aW9ucyRlbmFibGUzO1xuICAgICAgaWYgKHR5cGVvZiB0YWJsZS5vcHRpb25zLmVuYWJsZU11bHRpUm93U2VsZWN0aW9uID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgIHJldHVybiB0YWJsZS5vcHRpb25zLmVuYWJsZU11bHRpUm93U2VsZWN0aW9uKHJvdyk7XG4gICAgICB9XG4gICAgICByZXR1cm4gKF90YWJsZSRvcHRpb25zJGVuYWJsZTMgPSB0YWJsZS5vcHRpb25zLmVuYWJsZU11bHRpUm93U2VsZWN0aW9uKSAhPSBudWxsID8gX3RhYmxlJG9wdGlvbnMkZW5hYmxlMyA6IHRydWU7XG4gICAgfTtcbiAgICByb3cuZ2V0VG9nZ2xlU2VsZWN0ZWRIYW5kbGVyID0gKCkgPT4ge1xuICAgICAgY29uc3QgY2FuU2VsZWN0ID0gcm93LmdldENhblNlbGVjdCgpO1xuICAgICAgcmV0dXJuIGUgPT4ge1xuICAgICAgICB2YXIgX3RhcmdldDtcbiAgICAgICAgaWYgKCFjYW5TZWxlY3QpIHJldHVybjtcbiAgICAgICAgcm93LnRvZ2dsZVNlbGVjdGVkKChfdGFyZ2V0ID0gZS50YXJnZXQpID09IG51bGwgPyB2b2lkIDAgOiBfdGFyZ2V0LmNoZWNrZWQpO1xuICAgICAgfTtcbiAgICB9O1xuICB9XG59O1xuY29uc3QgbXV0YXRlUm93SXNTZWxlY3RlZCA9IChzZWxlY3RlZFJvd0lkcywgaWQsIHZhbHVlLCBpbmNsdWRlQ2hpbGRyZW4sIHRhYmxlKSA9PiB7XG4gIHZhciBfcm93JHN1YlJvd3M7XG4gIGNvbnN0IHJvdyA9IHRhYmxlLmdldFJvdyhpZCwgdHJ1ZSk7XG5cbiAgLy8gY29uc3QgaXNHcm91cGVkID0gcm93LmdldElzR3JvdXBlZCgpXG5cbiAgLy8gaWYgKCAvLyBUT0RPOiBlbmZvcmNlIGdyb3VwaW5nIHJvdyBzZWxlY3Rpb24gcnVsZXNcbiAgLy8gICAhaXNHcm91cGVkIHx8XG4gIC8vICAgKGlzR3JvdXBlZCAmJiB0YWJsZS5vcHRpb25zLmVuYWJsZUdyb3VwaW5nUm93U2VsZWN0aW9uKVxuICAvLyApIHtcbiAgaWYgKHZhbHVlKSB7XG4gICAgaWYgKCFyb3cuZ2V0Q2FuTXVsdGlTZWxlY3QoKSkge1xuICAgICAgT2JqZWN0LmtleXMoc2VsZWN0ZWRSb3dJZHMpLmZvckVhY2goa2V5ID0+IGRlbGV0ZSBzZWxlY3RlZFJvd0lkc1trZXldKTtcbiAgICB9XG4gICAgaWYgKHJvdy5nZXRDYW5TZWxlY3QoKSkge1xuICAgICAgc2VsZWN0ZWRSb3dJZHNbaWRdID0gdHJ1ZTtcbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgZGVsZXRlIHNlbGVjdGVkUm93SWRzW2lkXTtcbiAgfVxuICAvLyB9XG5cbiAgaWYgKGluY2x1ZGVDaGlsZHJlbiAmJiAoX3JvdyRzdWJSb3dzID0gcm93LnN1YlJvd3MpICE9IG51bGwgJiYgX3JvdyRzdWJSb3dzLmxlbmd0aCAmJiByb3cuZ2V0Q2FuU2VsZWN0U3ViUm93cygpKSB7XG4gICAgcm93LnN1YlJvd3MuZm9yRWFjaChyb3cgPT4gbXV0YXRlUm93SXNTZWxlY3RlZChzZWxlY3RlZFJvd0lkcywgcm93LmlkLCB2YWx1ZSwgaW5jbHVkZUNoaWxkcmVuLCB0YWJsZSkpO1xuICB9XG59O1xuZnVuY3Rpb24gc2VsZWN0Um93c0ZuKHRhYmxlLCByb3dNb2RlbCkge1xuICBjb25zdCByb3dTZWxlY3Rpb24gPSB0YWJsZS5nZXRTdGF0ZSgpLnJvd1NlbGVjdGlvbjtcbiAgY29uc3QgbmV3U2VsZWN0ZWRGbGF0Um93cyA9IFtdO1xuICBjb25zdCBuZXdTZWxlY3RlZFJvd3NCeUlkID0ge307XG5cbiAgLy8gRmlsdGVycyB0b3AgbGV2ZWwgYW5kIG5lc3RlZCByb3dzXG4gIGNvbnN0IHJlY3Vyc2VSb3dzID0gZnVuY3Rpb24gKHJvd3MsIGRlcHRoKSB7XG4gICAgcmV0dXJuIHJvd3MubWFwKHJvdyA9PiB7XG4gICAgICB2YXIgX3JvdyRzdWJSb3dzMjtcbiAgICAgIGNvbnN0IGlzU2VsZWN0ZWQgPSBpc1Jvd1NlbGVjdGVkKHJvdywgcm93U2VsZWN0aW9uKTtcbiAgICAgIGlmIChpc1NlbGVjdGVkKSB7XG4gICAgICAgIG5ld1NlbGVjdGVkRmxhdFJvd3MucHVzaChyb3cpO1xuICAgICAgICBuZXdTZWxlY3RlZFJvd3NCeUlkW3Jvdy5pZF0gPSByb3c7XG4gICAgICB9XG4gICAgICBpZiAoKF9yb3ckc3ViUm93czIgPSByb3cuc3ViUm93cykgIT0gbnVsbCAmJiBfcm93JHN1YlJvd3MyLmxlbmd0aCkge1xuICAgICAgICByb3cgPSB7XG4gICAgICAgICAgLi4ucm93LFxuICAgICAgICAgIHN1YlJvd3M6IHJlY3Vyc2VSb3dzKHJvdy5zdWJSb3dzKVxuICAgICAgICB9O1xuICAgICAgfVxuICAgICAgaWYgKGlzU2VsZWN0ZWQpIHtcbiAgICAgICAgcmV0dXJuIHJvdztcbiAgICAgIH1cbiAgICB9KS5maWx0ZXIoQm9vbGVhbik7XG4gIH07XG4gIHJldHVybiB7XG4gICAgcm93czogcmVjdXJzZVJvd3Mocm93TW9kZWwucm93cyksXG4gICAgZmxhdFJvd3M6IG5ld1NlbGVjdGVkRmxhdFJvd3MsXG4gICAgcm93c0J5SWQ6IG5ld1NlbGVjdGVkUm93c0J5SWRcbiAgfTtcbn1cbmZ1bmN0aW9uIGlzUm93U2VsZWN0ZWQocm93LCBzZWxlY3Rpb24pIHtcbiAgdmFyIF9zZWxlY3Rpb24kcm93JGlkO1xuICByZXR1cm4gKF9zZWxlY3Rpb24kcm93JGlkID0gc2VsZWN0aW9uW3Jvdy5pZF0pICE9IG51bGwgPyBfc2VsZWN0aW9uJHJvdyRpZCA6IGZhbHNlO1xufVxuZnVuY3Rpb24gaXNTdWJSb3dTZWxlY3RlZChyb3csIHNlbGVjdGlvbiwgdGFibGUpIHtcbiAgdmFyIF9yb3ckc3ViUm93czM7XG4gIGlmICghKChfcm93JHN1YlJvd3MzID0gcm93LnN1YlJvd3MpICE9IG51bGwgJiYgX3JvdyRzdWJSb3dzMy5sZW5ndGgpKSByZXR1cm4gZmFsc2U7XG4gIGxldCBhbGxDaGlsZHJlblNlbGVjdGVkID0gdHJ1ZTtcbiAgbGV0IHNvbWVTZWxlY3RlZCA9IGZhbHNlO1xuICByb3cuc3ViUm93cy5mb3JFYWNoKHN1YlJvdyA9PiB7XG4gICAgLy8gQmFpbCBvdXQgZWFybHkgaWYgd2Uga25vdyBib3RoIG9mIHRoZXNlXG4gICAgaWYgKHNvbWVTZWxlY3RlZCAmJiAhYWxsQ2hpbGRyZW5TZWxlY3RlZCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBpZiAoc3ViUm93LmdldENhblNlbGVjdCgpKSB7XG4gICAgICBpZiAoaXNSb3dTZWxlY3RlZChzdWJSb3csIHNlbGVjdGlvbikpIHtcbiAgICAgICAgc29tZVNlbGVjdGVkID0gdHJ1ZTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGFsbENoaWxkcmVuU2VsZWN0ZWQgPSBmYWxzZTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBDaGVjayByb3cgc2VsZWN0aW9uIG9mIG5lc3RlZCBzdWJyb3dzXG4gICAgaWYgKHN1YlJvdy5zdWJSb3dzICYmIHN1YlJvdy5zdWJSb3dzLmxlbmd0aCkge1xuICAgICAgY29uc3Qgc3ViUm93Q2hpbGRyZW5TZWxlY3RlZCA9IGlzU3ViUm93U2VsZWN0ZWQoc3ViUm93LCBzZWxlY3Rpb24pO1xuICAgICAgaWYgKHN1YlJvd0NoaWxkcmVuU2VsZWN0ZWQgPT09ICdhbGwnKSB7XG4gICAgICAgIHNvbWVTZWxlY3RlZCA9IHRydWU7XG4gICAgICB9IGVsc2UgaWYgKHN1YlJvd0NoaWxkcmVuU2VsZWN0ZWQgPT09ICdzb21lJykge1xuICAgICAgICBzb21lU2VsZWN0ZWQgPSB0cnVlO1xuICAgICAgICBhbGxDaGlsZHJlblNlbGVjdGVkID0gZmFsc2U7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBhbGxDaGlsZHJlblNlbGVjdGVkID0gZmFsc2U7XG4gICAgICB9XG4gICAgfVxuICB9KTtcbiAgcmV0dXJuIGFsbENoaWxkcmVuU2VsZWN0ZWQgPyAnYWxsJyA6IHNvbWVTZWxlY3RlZCA/ICdzb21lJyA6IGZhbHNlO1xufVxuXG5jb25zdCByZVNwbGl0QWxwaGFOdW1lcmljID0gLyhbMC05XSspL2dtO1xuY29uc3QgYWxwaGFudW1lcmljID0gKHJvd0EsIHJvd0IsIGNvbHVtbklkKSA9PiB7XG4gIHJldHVybiBjb21wYXJlQWxwaGFudW1lcmljKHRvU3RyaW5nKHJvd0EuZ2V0VmFsdWUoY29sdW1uSWQpKS50b0xvd2VyQ2FzZSgpLCB0b1N0cmluZyhyb3dCLmdldFZhbHVlKGNvbHVtbklkKSkudG9Mb3dlckNhc2UoKSk7XG59O1xuY29uc3QgYWxwaGFudW1lcmljQ2FzZVNlbnNpdGl2ZSA9IChyb3dBLCByb3dCLCBjb2x1bW5JZCkgPT4ge1xuICByZXR1cm4gY29tcGFyZUFscGhhbnVtZXJpYyh0b1N0cmluZyhyb3dBLmdldFZhbHVlKGNvbHVtbklkKSksIHRvU3RyaW5nKHJvd0IuZ2V0VmFsdWUoY29sdW1uSWQpKSk7XG59O1xuXG4vLyBUaGUgdGV4dCBmaWx0ZXIgaXMgbW9yZSBiYXNpYyAobGVzcyBudW1lcmljIHN1cHBvcnQpXG4vLyBidXQgaXMgbXVjaCBmYXN0ZXJcbmNvbnN0IHRleHQgPSAocm93QSwgcm93QiwgY29sdW1uSWQpID0+IHtcbiAgcmV0dXJuIGNvbXBhcmVCYXNpYyh0b1N0cmluZyhyb3dBLmdldFZhbHVlKGNvbHVtbklkKSkudG9Mb3dlckNhc2UoKSwgdG9TdHJpbmcocm93Qi5nZXRWYWx1ZShjb2x1bW5JZCkpLnRvTG93ZXJDYXNlKCkpO1xufTtcblxuLy8gVGhlIHRleHQgZmlsdGVyIGlzIG1vcmUgYmFzaWMgKGxlc3MgbnVtZXJpYyBzdXBwb3J0KVxuLy8gYnV0IGlzIG11Y2ggZmFzdGVyXG5jb25zdCB0ZXh0Q2FzZVNlbnNpdGl2ZSA9IChyb3dBLCByb3dCLCBjb2x1bW5JZCkgPT4ge1xuICByZXR1cm4gY29tcGFyZUJhc2ljKHRvU3RyaW5nKHJvd0EuZ2V0VmFsdWUoY29sdW1uSWQpKSwgdG9TdHJpbmcocm93Qi5nZXRWYWx1ZShjb2x1bW5JZCkpKTtcbn07XG5jb25zdCBkYXRldGltZSA9IChyb3dBLCByb3dCLCBjb2x1bW5JZCkgPT4ge1xuICBjb25zdCBhID0gcm93QS5nZXRWYWx1ZShjb2x1bW5JZCk7XG4gIGNvbnN0IGIgPSByb3dCLmdldFZhbHVlKGNvbHVtbklkKTtcblxuICAvLyBDYW4gaGFuZGxlIG51bGxpc2ggdmFsdWVzXG4gIC8vIFVzZSA+IGFuZCA8IGJlY2F1c2UgPT0gKGFuZCA9PT0pIGRvZXNuJ3Qgd29yayB3aXRoXG4gIC8vIERhdGUgb2JqZWN0cyAod291bGQgcmVxdWlyZSBjYWxsaW5nIGdldFRpbWUoKSkuXG4gIHJldHVybiBhID4gYiA/IDEgOiBhIDwgYiA/IC0xIDogMDtcbn07XG5jb25zdCBiYXNpYyA9IChyb3dBLCByb3dCLCBjb2x1bW5JZCkgPT4ge1xuICByZXR1cm4gY29tcGFyZUJhc2ljKHJvd0EuZ2V0VmFsdWUoY29sdW1uSWQpLCByb3dCLmdldFZhbHVlKGNvbHVtbklkKSk7XG59O1xuXG4vLyBVdGlsc1xuXG5mdW5jdGlvbiBjb21wYXJlQmFzaWMoYSwgYikge1xuICByZXR1cm4gYSA9PT0gYiA/IDAgOiBhID4gYiA/IDEgOiAtMTtcbn1cbmZ1bmN0aW9uIHRvU3RyaW5nKGEpIHtcbiAgaWYgKHR5cGVvZiBhID09PSAnbnVtYmVyJykge1xuICAgIGlmIChpc05hTihhKSB8fCBhID09PSBJbmZpbml0eSB8fCBhID09PSAtSW5maW5pdHkpIHtcbiAgICAgIHJldHVybiAnJztcbiAgICB9XG4gICAgcmV0dXJuIFN0cmluZyhhKTtcbiAgfVxuICBpZiAodHlwZW9mIGEgPT09ICdzdHJpbmcnKSB7XG4gICAgcmV0dXJuIGE7XG4gIH1cbiAgcmV0dXJuICcnO1xufVxuXG4vLyBNaXhlZCBzb3J0aW5nIGlzIHNsb3csIGJ1dCB2ZXJ5IGluY2x1c2l2ZSBvZiBtYW55IGVkZ2UgY2FzZXMuXG4vLyBJdCBoYW5kbGVzIG51bWJlcnMsIG1peGVkIGFscGhhbnVtZXJpYyBjb21iaW5hdGlvbnMsIGFuZCBldmVuXG4vLyBudWxsLCB1bmRlZmluZWQsIGFuZCBJbmZpbml0eVxuZnVuY3Rpb24gY29tcGFyZUFscGhhbnVtZXJpYyhhU3RyLCBiU3RyKSB7XG4gIC8vIFNwbGl0IG9uIG51bWJlciBncm91cHMsIGJ1dCBrZWVwIHRoZSBkZWxpbWl0ZXJcbiAgLy8gVGhlbiByZW1vdmUgZmFsc2V5IHNwbGl0IHZhbHVlc1xuICBjb25zdCBhID0gYVN0ci5zcGxpdChyZVNwbGl0QWxwaGFOdW1lcmljKS5maWx0ZXIoQm9vbGVhbik7XG4gIGNvbnN0IGIgPSBiU3RyLnNwbGl0KHJlU3BsaXRBbHBoYU51bWVyaWMpLmZpbHRlcihCb29sZWFuKTtcblxuICAvLyBXaGlsZVxuICB3aGlsZSAoYS5sZW5ndGggJiYgYi5sZW5ndGgpIHtcbiAgICBjb25zdCBhYSA9IGEuc2hpZnQoKTtcbiAgICBjb25zdCBiYiA9IGIuc2hpZnQoKTtcbiAgICBjb25zdCBhbiA9IHBhcnNlSW50KGFhLCAxMCk7XG4gICAgY29uc3QgYm4gPSBwYXJzZUludChiYiwgMTApO1xuICAgIGNvbnN0IGNvbWJvID0gW2FuLCBibl0uc29ydCgpO1xuXG4gICAgLy8gQm90aCBhcmUgc3RyaW5nXG4gICAgaWYgKGlzTmFOKGNvbWJvWzBdKSkge1xuICAgICAgaWYgKGFhID4gYmIpIHtcbiAgICAgICAgcmV0dXJuIDE7XG4gICAgICB9XG4gICAgICBpZiAoYmIgPiBhYSkge1xuICAgICAgICByZXR1cm4gLTE7XG4gICAgICB9XG4gICAgICBjb250aW51ZTtcbiAgICB9XG5cbiAgICAvLyBPbmUgaXMgYSBzdHJpbmcsIG9uZSBpcyBhIG51bWJlclxuICAgIGlmIChpc05hTihjb21ib1sxXSkpIHtcbiAgICAgIHJldHVybiBpc05hTihhbikgPyAtMSA6IDE7XG4gICAgfVxuXG4gICAgLy8gQm90aCBhcmUgbnVtYmVyc1xuICAgIGlmIChhbiA+IGJuKSB7XG4gICAgICByZXR1cm4gMTtcbiAgICB9XG4gICAgaWYgKGJuID4gYW4pIHtcbiAgICAgIHJldHVybiAtMTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIGEubGVuZ3RoIC0gYi5sZW5ndGg7XG59XG5cbi8vIEV4cG9ydHNcblxuY29uc3Qgc29ydGluZ0ZucyA9IHtcbiAgYWxwaGFudW1lcmljLFxuICBhbHBoYW51bWVyaWNDYXNlU2Vuc2l0aXZlLFxuICB0ZXh0LFxuICB0ZXh0Q2FzZVNlbnNpdGl2ZSxcbiAgZGF0ZXRpbWUsXG4gIGJhc2ljXG59O1xuXG4vL1xuXG5jb25zdCBTb3J0aW5nID0ge1xuICBnZXRJbml0aWFsU3RhdGU6IHN0YXRlID0+IHtcbiAgICByZXR1cm4ge1xuICAgICAgc29ydGluZzogW10sXG4gICAgICAuLi5zdGF0ZVxuICAgIH07XG4gIH0sXG4gIGdldERlZmF1bHRDb2x1bW5EZWY6ICgpID0+IHtcbiAgICByZXR1cm4ge1xuICAgICAgc29ydGluZ0ZuOiAnYXV0bycsXG4gICAgICBzb3J0VW5kZWZpbmVkOiAxXG4gICAgfTtcbiAgfSxcbiAgZ2V0RGVmYXVsdE9wdGlvbnM6IHRhYmxlID0+IHtcbiAgICByZXR1cm4ge1xuICAgICAgb25Tb3J0aW5nQ2hhbmdlOiBtYWtlU3RhdGVVcGRhdGVyKCdzb3J0aW5nJywgdGFibGUpLFxuICAgICAgaXNNdWx0aVNvcnRFdmVudDogZSA9PiB7XG4gICAgICAgIHJldHVybiBlLnNoaWZ0S2V5O1xuICAgICAgfVxuICAgIH07XG4gIH0sXG4gIGNyZWF0ZUNvbHVtbjogKGNvbHVtbiwgdGFibGUpID0+IHtcbiAgICBjb2x1bW4uZ2V0QXV0b1NvcnRpbmdGbiA9ICgpID0+IHtcbiAgICAgIGNvbnN0IGZpcnN0Um93cyA9IHRhYmxlLmdldEZpbHRlcmVkUm93TW9kZWwoKS5mbGF0Um93cy5zbGljZSgxMCk7XG4gICAgICBsZXQgaXNTdHJpbmcgPSBmYWxzZTtcbiAgICAgIGZvciAoY29uc3Qgcm93IG9mIGZpcnN0Um93cykge1xuICAgICAgICBjb25zdCB2YWx1ZSA9IHJvdyA9PSBudWxsID8gdm9pZCAwIDogcm93LmdldFZhbHVlKGNvbHVtbi5pZCk7XG4gICAgICAgIGlmIChPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwodmFsdWUpID09PSAnW29iamVjdCBEYXRlXScpIHtcbiAgICAgICAgICByZXR1cm4gc29ydGluZ0Zucy5kYXRldGltZTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodHlwZW9mIHZhbHVlID09PSAnc3RyaW5nJykge1xuICAgICAgICAgIGlzU3RyaW5nID0gdHJ1ZTtcbiAgICAgICAgICBpZiAodmFsdWUuc3BsaXQocmVTcGxpdEFscGhhTnVtZXJpYykubGVuZ3RoID4gMSkge1xuICAgICAgICAgICAgcmV0dXJuIHNvcnRpbmdGbnMuYWxwaGFudW1lcmljO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgaWYgKGlzU3RyaW5nKSB7XG4gICAgICAgIHJldHVybiBzb3J0aW5nRm5zLnRleHQ7XG4gICAgICB9XG4gICAgICByZXR1cm4gc29ydGluZ0Zucy5iYXNpYztcbiAgICB9O1xuICAgIGNvbHVtbi5nZXRBdXRvU29ydERpciA9ICgpID0+IHtcbiAgICAgIGNvbnN0IGZpcnN0Um93ID0gdGFibGUuZ2V0RmlsdGVyZWRSb3dNb2RlbCgpLmZsYXRSb3dzWzBdO1xuICAgICAgY29uc3QgdmFsdWUgPSBmaXJzdFJvdyA9PSBudWxsID8gdm9pZCAwIDogZmlyc3RSb3cuZ2V0VmFsdWUoY29sdW1uLmlkKTtcbiAgICAgIGlmICh0eXBlb2YgdmFsdWUgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgIHJldHVybiAnYXNjJztcbiAgICAgIH1cbiAgICAgIHJldHVybiAnZGVzYyc7XG4gICAgfTtcbiAgICBjb2x1bW4uZ2V0U29ydGluZ0ZuID0gKCkgPT4ge1xuICAgICAgdmFyIF90YWJsZSRvcHRpb25zJHNvcnRpbiwgX3RhYmxlJG9wdGlvbnMkc29ydGluMjtcbiAgICAgIGlmICghY29sdW1uKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcigpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGlzRnVuY3Rpb24oY29sdW1uLmNvbHVtbkRlZi5zb3J0aW5nRm4pID8gY29sdW1uLmNvbHVtbkRlZi5zb3J0aW5nRm4gOiBjb2x1bW4uY29sdW1uRGVmLnNvcnRpbmdGbiA9PT0gJ2F1dG8nID8gY29sdW1uLmdldEF1dG9Tb3J0aW5nRm4oKSA6IChfdGFibGUkb3B0aW9ucyRzb3J0aW4gPSAoX3RhYmxlJG9wdGlvbnMkc29ydGluMiA9IHRhYmxlLm9wdGlvbnMuc29ydGluZ0ZucykgPT0gbnVsbCA/IHZvaWQgMCA6IF90YWJsZSRvcHRpb25zJHNvcnRpbjJbY29sdW1uLmNvbHVtbkRlZi5zb3J0aW5nRm5dKSAhPSBudWxsID8gX3RhYmxlJG9wdGlvbnMkc29ydGluIDogc29ydGluZ0Zuc1tjb2x1bW4uY29sdW1uRGVmLnNvcnRpbmdGbl07XG4gICAgfTtcbiAgICBjb2x1bW4udG9nZ2xlU29ydGluZyA9IChkZXNjLCBtdWx0aSkgPT4ge1xuICAgICAgLy8gaWYgKGNvbHVtbi5jb2x1bW5zLmxlbmd0aCkge1xuICAgICAgLy8gICBjb2x1bW4uY29sdW1ucy5mb3JFYWNoKChjLCBpKSA9PiB7XG4gICAgICAvLyAgICAgaWYgKGMuaWQpIHtcbiAgICAgIC8vICAgICAgIHRhYmxlLnRvZ2dsZUNvbHVtblNvcnRpbmcoYy5pZCwgdW5kZWZpbmVkLCBtdWx0aSB8fCAhIWkpXG4gICAgICAvLyAgICAgfVxuICAgICAgLy8gICB9KVxuICAgICAgLy8gICByZXR1cm5cbiAgICAgIC8vIH1cblxuICAgICAgLy8gdGhpcyBuZWVkcyB0byBiZSBvdXRzaWRlIG9mIHRhYmxlLnNldFNvcnRpbmcgdG8gYmUgaW4gc3luYyB3aXRoIHJlcmVuZGVyXG4gICAgICBjb25zdCBuZXh0U29ydGluZ09yZGVyID0gY29sdW1uLmdldE5leHRTb3J0aW5nT3JkZXIoKTtcbiAgICAgIGNvbnN0IGhhc01hbnVhbFZhbHVlID0gdHlwZW9mIGRlc2MgIT09ICd1bmRlZmluZWQnICYmIGRlc2MgIT09IG51bGw7XG4gICAgICB0YWJsZS5zZXRTb3J0aW5nKG9sZCA9PiB7XG4gICAgICAgIC8vIEZpbmQgYW55IGV4aXN0aW5nIHNvcnRpbmcgZm9yIHRoaXMgY29sdW1uXG4gICAgICAgIGNvbnN0IGV4aXN0aW5nU29ydGluZyA9IG9sZCA9PSBudWxsID8gdm9pZCAwIDogb2xkLmZpbmQoZCA9PiBkLmlkID09PSBjb2x1bW4uaWQpO1xuICAgICAgICBjb25zdCBleGlzdGluZ0luZGV4ID0gb2xkID09IG51bGwgPyB2b2lkIDAgOiBvbGQuZmluZEluZGV4KGQgPT4gZC5pZCA9PT0gY29sdW1uLmlkKTtcbiAgICAgICAgbGV0IG5ld1NvcnRpbmcgPSBbXTtcblxuICAgICAgICAvLyBXaGF0IHNob3VsZCB3ZSBkbyB3aXRoIHRoaXMgc29ydCBhY3Rpb24/XG4gICAgICAgIGxldCBzb3J0QWN0aW9uO1xuICAgICAgICBsZXQgbmV4dERlc2MgPSBoYXNNYW51YWxWYWx1ZSA/IGRlc2MgOiBuZXh0U29ydGluZ09yZGVyID09PSAnZGVzYyc7XG5cbiAgICAgICAgLy8gTXVsdGktbW9kZVxuICAgICAgICBpZiAob2xkICE9IG51bGwgJiYgb2xkLmxlbmd0aCAmJiBjb2x1bW4uZ2V0Q2FuTXVsdGlTb3J0KCkgJiYgbXVsdGkpIHtcbiAgICAgICAgICBpZiAoZXhpc3RpbmdTb3J0aW5nKSB7XG4gICAgICAgICAgICBzb3J0QWN0aW9uID0gJ3RvZ2dsZSc7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHNvcnRBY3Rpb24gPSAnYWRkJztcbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgLy8gTm9ybWFsIG1vZGVcbiAgICAgICAgICBpZiAob2xkICE9IG51bGwgJiYgb2xkLmxlbmd0aCAmJiBleGlzdGluZ0luZGV4ICE9PSBvbGQubGVuZ3RoIC0gMSkge1xuICAgICAgICAgICAgc29ydEFjdGlvbiA9ICdyZXBsYWNlJztcbiAgICAgICAgICB9IGVsc2UgaWYgKGV4aXN0aW5nU29ydGluZykge1xuICAgICAgICAgICAgc29ydEFjdGlvbiA9ICd0b2dnbGUnO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBzb3J0QWN0aW9uID0gJ3JlcGxhY2UnO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIC8vIEhhbmRsZSB0b2dnbGUgc3RhdGVzIHRoYXQgd2lsbCByZW1vdmUgdGhlIHNvcnRpbmdcbiAgICAgICAgaWYgKHNvcnRBY3Rpb24gPT09ICd0b2dnbGUnKSB7XG4gICAgICAgICAgLy8gSWYgd2UgYXJlIFwiYWN0dWFsbHlcIiB0b2dnbGluZyAobm90IGEgbWFudWFsIHNldCB2YWx1ZSksIHNob3VsZCB3ZSByZW1vdmUgdGhlIHNvcnRpbmc/XG4gICAgICAgICAgaWYgKCFoYXNNYW51YWxWYWx1ZSkge1xuICAgICAgICAgICAgLy8gSXMgb3VyIGludGVudGlvbiB0byByZW1vdmU/XG4gICAgICAgICAgICBpZiAoIW5leHRTb3J0aW5nT3JkZXIpIHtcbiAgICAgICAgICAgICAgc29ydEFjdGlvbiA9ICdyZW1vdmUnO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAoc29ydEFjdGlvbiA9PT0gJ2FkZCcpIHtcbiAgICAgICAgICB2YXIgX3RhYmxlJG9wdGlvbnMkbWF4TXVsO1xuICAgICAgICAgIG5ld1NvcnRpbmcgPSBbLi4ub2xkLCB7XG4gICAgICAgICAgICBpZDogY29sdW1uLmlkLFxuICAgICAgICAgICAgZGVzYzogbmV4dERlc2NcbiAgICAgICAgICB9XTtcbiAgICAgICAgICAvLyBUYWtlIGxhdGVzdCBuIGNvbHVtbnNcbiAgICAgICAgICBuZXdTb3J0aW5nLnNwbGljZSgwLCBuZXdTb3J0aW5nLmxlbmd0aCAtICgoX3RhYmxlJG9wdGlvbnMkbWF4TXVsID0gdGFibGUub3B0aW9ucy5tYXhNdWx0aVNvcnRDb2xDb3VudCkgIT0gbnVsbCA/IF90YWJsZSRvcHRpb25zJG1heE11bCA6IE51bWJlci5NQVhfU0FGRV9JTlRFR0VSKSk7XG4gICAgICAgIH0gZWxzZSBpZiAoc29ydEFjdGlvbiA9PT0gJ3RvZ2dsZScpIHtcbiAgICAgICAgICAvLyBUaGlzIGZsaXBzIChvciBzZXRzKSB0aGVcbiAgICAgICAgICBuZXdTb3J0aW5nID0gb2xkLm1hcChkID0+IHtcbiAgICAgICAgICAgIGlmIChkLmlkID09PSBjb2x1bW4uaWQpIHtcbiAgICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICAuLi5kLFxuICAgICAgICAgICAgICAgIGRlc2M6IG5leHREZXNjXG4gICAgICAgICAgICAgIH07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gZDtcbiAgICAgICAgICB9KTtcbiAgICAgICAgfSBlbHNlIGlmIChzb3J0QWN0aW9uID09PSAncmVtb3ZlJykge1xuICAgICAgICAgIG5ld1NvcnRpbmcgPSBvbGQuZmlsdGVyKGQgPT4gZC5pZCAhPT0gY29sdW1uLmlkKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBuZXdTb3J0aW5nID0gW3tcbiAgICAgICAgICAgIGlkOiBjb2x1bW4uaWQsXG4gICAgICAgICAgICBkZXNjOiBuZXh0RGVzY1xuICAgICAgICAgIH1dO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBuZXdTb3J0aW5nO1xuICAgICAgfSk7XG4gICAgfTtcbiAgICBjb2x1bW4uZ2V0Rmlyc3RTb3J0RGlyID0gKCkgPT4ge1xuICAgICAgdmFyIF9yZWYsIF9jb2x1bW4kY29sdW1uRGVmJHNvcjtcbiAgICAgIGNvbnN0IHNvcnREZXNjRmlyc3QgPSAoX3JlZiA9IChfY29sdW1uJGNvbHVtbkRlZiRzb3IgPSBjb2x1bW4uY29sdW1uRGVmLnNvcnREZXNjRmlyc3QpICE9IG51bGwgPyBfY29sdW1uJGNvbHVtbkRlZiRzb3IgOiB0YWJsZS5vcHRpb25zLnNvcnREZXNjRmlyc3QpICE9IG51bGwgPyBfcmVmIDogY29sdW1uLmdldEF1dG9Tb3J0RGlyKCkgPT09ICdkZXNjJztcbiAgICAgIHJldHVybiBzb3J0RGVzY0ZpcnN0ID8gJ2Rlc2MnIDogJ2FzYyc7XG4gICAgfTtcbiAgICBjb2x1bW4uZ2V0TmV4dFNvcnRpbmdPcmRlciA9IG11bHRpID0+IHtcbiAgICAgIHZhciBfdGFibGUkb3B0aW9ucyRlbmFibGUsIF90YWJsZSRvcHRpb25zJGVuYWJsZTI7XG4gICAgICBjb25zdCBmaXJzdFNvcnREaXJlY3Rpb24gPSBjb2x1bW4uZ2V0Rmlyc3RTb3J0RGlyKCk7XG4gICAgICBjb25zdCBpc1NvcnRlZCA9IGNvbHVtbi5nZXRJc1NvcnRlZCgpO1xuICAgICAgaWYgKCFpc1NvcnRlZCkge1xuICAgICAgICByZXR1cm4gZmlyc3RTb3J0RGlyZWN0aW9uO1xuICAgICAgfVxuICAgICAgaWYgKGlzU29ydGVkICE9PSBmaXJzdFNvcnREaXJlY3Rpb24gJiYgKChfdGFibGUkb3B0aW9ucyRlbmFibGUgPSB0YWJsZS5vcHRpb25zLmVuYWJsZVNvcnRpbmdSZW1vdmFsKSAhPSBudWxsID8gX3RhYmxlJG9wdGlvbnMkZW5hYmxlIDogdHJ1ZSkgJiYgKFxuICAgICAgLy8gSWYgZW5hYmxlU29ydFJlbW92ZSwgZW5hYmxlIGluIGdlbmVyYWxcbiAgICAgIG11bHRpID8gKF90YWJsZSRvcHRpb25zJGVuYWJsZTIgPSB0YWJsZS5vcHRpb25zLmVuYWJsZU11bHRpUmVtb3ZlKSAhPSBudWxsID8gX3RhYmxlJG9wdGlvbnMkZW5hYmxlMiA6IHRydWUgOiB0cnVlKSAvLyBJZiBtdWx0aSwgZG9uJ3QgYWxsb3cgaWYgZW5hYmxlTXVsdGlSZW1vdmUpKVxuICAgICAgKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBpc1NvcnRlZCA9PT0gJ2Rlc2MnID8gJ2FzYycgOiAnZGVzYyc7XG4gICAgfTtcbiAgICBjb2x1bW4uZ2V0Q2FuU29ydCA9ICgpID0+IHtcbiAgICAgIHZhciBfY29sdW1uJGNvbHVtbkRlZiRlbmEsIF90YWJsZSRvcHRpb25zJGVuYWJsZTM7XG4gICAgICByZXR1cm4gKChfY29sdW1uJGNvbHVtbkRlZiRlbmEgPSBjb2x1bW4uY29sdW1uRGVmLmVuYWJsZVNvcnRpbmcpICE9IG51bGwgPyBfY29sdW1uJGNvbHVtbkRlZiRlbmEgOiB0cnVlKSAmJiAoKF90YWJsZSRvcHRpb25zJGVuYWJsZTMgPSB0YWJsZS5vcHRpb25zLmVuYWJsZVNvcnRpbmcpICE9IG51bGwgPyBfdGFibGUkb3B0aW9ucyRlbmFibGUzIDogdHJ1ZSkgJiYgISFjb2x1bW4uYWNjZXNzb3JGbjtcbiAgICB9O1xuICAgIGNvbHVtbi5nZXRDYW5NdWx0aVNvcnQgPSAoKSA9PiB7XG4gICAgICB2YXIgX3JlZjIsIF9jb2x1bW4kY29sdW1uRGVmJGVuYTI7XG4gICAgICByZXR1cm4gKF9yZWYyID0gKF9jb2x1bW4kY29sdW1uRGVmJGVuYTIgPSBjb2x1bW4uY29sdW1uRGVmLmVuYWJsZU11bHRpU29ydCkgIT0gbnVsbCA/IF9jb2x1bW4kY29sdW1uRGVmJGVuYTIgOiB0YWJsZS5vcHRpb25zLmVuYWJsZU11bHRpU29ydCkgIT0gbnVsbCA/IF9yZWYyIDogISFjb2x1bW4uYWNjZXNzb3JGbjtcbiAgICB9O1xuICAgIGNvbHVtbi5nZXRJc1NvcnRlZCA9ICgpID0+IHtcbiAgICAgIHZhciBfdGFibGUkZ2V0U3RhdGUkc29ydGk7XG4gICAgICBjb25zdCBjb2x1bW5Tb3J0ID0gKF90YWJsZSRnZXRTdGF0ZSRzb3J0aSA9IHRhYmxlLmdldFN0YXRlKCkuc29ydGluZykgPT0gbnVsbCA/IHZvaWQgMCA6IF90YWJsZSRnZXRTdGF0ZSRzb3J0aS5maW5kKGQgPT4gZC5pZCA9PT0gY29sdW1uLmlkKTtcbiAgICAgIHJldHVybiAhY29sdW1uU29ydCA/IGZhbHNlIDogY29sdW1uU29ydC5kZXNjID8gJ2Rlc2MnIDogJ2FzYyc7XG4gICAgfTtcbiAgICBjb2x1bW4uZ2V0U29ydEluZGV4ID0gKCkgPT4ge1xuICAgICAgdmFyIF90YWJsZSRnZXRTdGF0ZSRzb3J0aTIsIF90YWJsZSRnZXRTdGF0ZSRzb3J0aTM7XG4gICAgICByZXR1cm4gKF90YWJsZSRnZXRTdGF0ZSRzb3J0aTIgPSAoX3RhYmxlJGdldFN0YXRlJHNvcnRpMyA9IHRhYmxlLmdldFN0YXRlKCkuc29ydGluZykgPT0gbnVsbCA/IHZvaWQgMCA6IF90YWJsZSRnZXRTdGF0ZSRzb3J0aTMuZmluZEluZGV4KGQgPT4gZC5pZCA9PT0gY29sdW1uLmlkKSkgIT0gbnVsbCA/IF90YWJsZSRnZXRTdGF0ZSRzb3J0aTIgOiAtMTtcbiAgICB9O1xuICAgIGNvbHVtbi5jbGVhclNvcnRpbmcgPSAoKSA9PiB7XG4gICAgICAvL2NsZWFyIHNvcnRpbmcgZm9yIGp1c3QgMSBjb2x1bW5cbiAgICAgIHRhYmxlLnNldFNvcnRpbmcob2xkID0+IG9sZCAhPSBudWxsICYmIG9sZC5sZW5ndGggPyBvbGQuZmlsdGVyKGQgPT4gZC5pZCAhPT0gY29sdW1uLmlkKSA6IFtdKTtcbiAgICB9O1xuICAgIGNvbHVtbi5nZXRUb2dnbGVTb3J0aW5nSGFuZGxlciA9ICgpID0+IHtcbiAgICAgIGNvbnN0IGNhblNvcnQgPSBjb2x1bW4uZ2V0Q2FuU29ydCgpO1xuICAgICAgcmV0dXJuIGUgPT4ge1xuICAgICAgICBpZiAoIWNhblNvcnQpIHJldHVybjtcbiAgICAgICAgZS5wZXJzaXN0ID09IG51bGwgfHwgZS5wZXJzaXN0KCk7XG4gICAgICAgIGNvbHVtbi50b2dnbGVTb3J0aW5nID09IG51bGwgfHwgY29sdW1uLnRvZ2dsZVNvcnRpbmcodW5kZWZpbmVkLCBjb2x1bW4uZ2V0Q2FuTXVsdGlTb3J0KCkgPyB0YWJsZS5vcHRpb25zLmlzTXVsdGlTb3J0RXZlbnQgPT0gbnVsbCA/IHZvaWQgMCA6IHRhYmxlLm9wdGlvbnMuaXNNdWx0aVNvcnRFdmVudChlKSA6IGZhbHNlKTtcbiAgICAgIH07XG4gICAgfTtcbiAgfSxcbiAgY3JlYXRlVGFibGU6IHRhYmxlID0+IHtcbiAgICB0YWJsZS5zZXRTb3J0aW5nID0gdXBkYXRlciA9PiB0YWJsZS5vcHRpb25zLm9uU29ydGluZ0NoYW5nZSA9PSBudWxsID8gdm9pZCAwIDogdGFibGUub3B0aW9ucy5vblNvcnRpbmdDaGFuZ2UodXBkYXRlcik7XG4gICAgdGFibGUucmVzZXRTb3J0aW5nID0gZGVmYXVsdFN0YXRlID0+IHtcbiAgICAgIHZhciBfdGFibGUkaW5pdGlhbFN0YXRlJHMsIF90YWJsZSRpbml0aWFsU3RhdGU7XG4gICAgICB0YWJsZS5zZXRTb3J0aW5nKGRlZmF1bHRTdGF0ZSA/IFtdIDogKF90YWJsZSRpbml0aWFsU3RhdGUkcyA9IChfdGFibGUkaW5pdGlhbFN0YXRlID0gdGFibGUuaW5pdGlhbFN0YXRlKSA9PSBudWxsID8gdm9pZCAwIDogX3RhYmxlJGluaXRpYWxTdGF0ZS5zb3J0aW5nKSAhPSBudWxsID8gX3RhYmxlJGluaXRpYWxTdGF0ZSRzIDogW10pO1xuICAgIH07XG4gICAgdGFibGUuZ2V0UHJlU29ydGVkUm93TW9kZWwgPSAoKSA9PiB0YWJsZS5nZXRHcm91cGVkUm93TW9kZWwoKTtcbiAgICB0YWJsZS5nZXRTb3J0ZWRSb3dNb2RlbCA9ICgpID0+IHtcbiAgICAgIGlmICghdGFibGUuX2dldFNvcnRlZFJvd01vZGVsICYmIHRhYmxlLm9wdGlvbnMuZ2V0U29ydGVkUm93TW9kZWwpIHtcbiAgICAgICAgdGFibGUuX2dldFNvcnRlZFJvd01vZGVsID0gdGFibGUub3B0aW9ucy5nZXRTb3J0ZWRSb3dNb2RlbCh0YWJsZSk7XG4gICAgICB9XG4gICAgICBpZiAodGFibGUub3B0aW9ucy5tYW51YWxTb3J0aW5nIHx8ICF0YWJsZS5fZ2V0U29ydGVkUm93TW9kZWwpIHtcbiAgICAgICAgcmV0dXJuIHRhYmxlLmdldFByZVNvcnRlZFJvd01vZGVsKCk7XG4gICAgICB9XG4gICAgICByZXR1cm4gdGFibGUuX2dldFNvcnRlZFJvd01vZGVsKCk7XG4gICAgfTtcbiAgfVxufTtcblxuLy9cblxuY29uc3QgVmlzaWJpbGl0eSA9IHtcbiAgZ2V0SW5pdGlhbFN0YXRlOiBzdGF0ZSA9PiB7XG4gICAgcmV0dXJuIHtcbiAgICAgIGNvbHVtblZpc2liaWxpdHk6IHt9LFxuICAgICAgLi4uc3RhdGVcbiAgICB9O1xuICB9LFxuICBnZXREZWZhdWx0T3B0aW9uczogdGFibGUgPT4ge1xuICAgIHJldHVybiB7XG4gICAgICBvbkNvbHVtblZpc2liaWxpdHlDaGFuZ2U6IG1ha2VTdGF0ZVVwZGF0ZXIoJ2NvbHVtblZpc2liaWxpdHknLCB0YWJsZSlcbiAgICB9O1xuICB9LFxuICBjcmVhdGVDb2x1bW46IChjb2x1bW4sIHRhYmxlKSA9PiB7XG4gICAgY29sdW1uLnRvZ2dsZVZpc2liaWxpdHkgPSB2YWx1ZSA9PiB7XG4gICAgICBpZiAoY29sdW1uLmdldENhbkhpZGUoKSkge1xuICAgICAgICB0YWJsZS5zZXRDb2x1bW5WaXNpYmlsaXR5KG9sZCA9PiAoe1xuICAgICAgICAgIC4uLm9sZCxcbiAgICAgICAgICBbY29sdW1uLmlkXTogdmFsdWUgIT0gbnVsbCA/IHZhbHVlIDogIWNvbHVtbi5nZXRJc1Zpc2libGUoKVxuICAgICAgICB9KSk7XG4gICAgICB9XG4gICAgfTtcbiAgICBjb2x1bW4uZ2V0SXNWaXNpYmxlID0gKCkgPT4ge1xuICAgICAgdmFyIF90YWJsZSRnZXRTdGF0ZSRjb2x1bSwgX3RhYmxlJGdldFN0YXRlJGNvbHVtMjtcbiAgICAgIHJldHVybiAoX3RhYmxlJGdldFN0YXRlJGNvbHVtID0gKF90YWJsZSRnZXRTdGF0ZSRjb2x1bTIgPSB0YWJsZS5nZXRTdGF0ZSgpLmNvbHVtblZpc2liaWxpdHkpID09IG51bGwgPyB2b2lkIDAgOiBfdGFibGUkZ2V0U3RhdGUkY29sdW0yW2NvbHVtbi5pZF0pICE9IG51bGwgPyBfdGFibGUkZ2V0U3RhdGUkY29sdW0gOiB0cnVlO1xuICAgIH07XG4gICAgY29sdW1uLmdldENhbkhpZGUgPSAoKSA9PiB7XG4gICAgICB2YXIgX2NvbHVtbiRjb2x1bW5EZWYkZW5hLCBfdGFibGUkb3B0aW9ucyRlbmFibGU7XG4gICAgICByZXR1cm4gKChfY29sdW1uJGNvbHVtbkRlZiRlbmEgPSBjb2x1bW4uY29sdW1uRGVmLmVuYWJsZUhpZGluZykgIT0gbnVsbCA/IF9jb2x1bW4kY29sdW1uRGVmJGVuYSA6IHRydWUpICYmICgoX3RhYmxlJG9wdGlvbnMkZW5hYmxlID0gdGFibGUub3B0aW9ucy5lbmFibGVIaWRpbmcpICE9IG51bGwgPyBfdGFibGUkb3B0aW9ucyRlbmFibGUgOiB0cnVlKTtcbiAgICB9O1xuICAgIGNvbHVtbi5nZXRUb2dnbGVWaXNpYmlsaXR5SGFuZGxlciA9ICgpID0+IHtcbiAgICAgIHJldHVybiBlID0+IHtcbiAgICAgICAgY29sdW1uLnRvZ2dsZVZpc2liaWxpdHkgPT0gbnVsbCB8fCBjb2x1bW4udG9nZ2xlVmlzaWJpbGl0eShlLnRhcmdldC5jaGVja2VkKTtcbiAgICAgIH07XG4gICAgfTtcbiAgfSxcbiAgY3JlYXRlUm93OiAocm93LCB0YWJsZSkgPT4ge1xuICAgIHJvdy5fZ2V0QWxsVmlzaWJsZUNlbGxzID0gbWVtbygoKSA9PiBbcm93LmdldEFsbENlbGxzKCksIHRhYmxlLmdldFN0YXRlKCkuY29sdW1uVmlzaWJpbGl0eV0sIGNlbGxzID0+IHtcbiAgICAgIHJldHVybiBjZWxscy5maWx0ZXIoY2VsbCA9PiBjZWxsLmNvbHVtbi5nZXRJc1Zpc2libGUoKSk7XG4gICAgfSwge1xuICAgICAga2V5OiBwcm9jZXNzLmVudi5OT0RFX0VOViA9PT0gJ3Byb2R1Y3Rpb24nICYmICdyb3cuX2dldEFsbFZpc2libGVDZWxscycsXG4gICAgICBkZWJ1ZzogKCkgPT4ge1xuICAgICAgICB2YXIgX3RhYmxlJG9wdGlvbnMkZGVidWdBO1xuICAgICAgICByZXR1cm4gKF90YWJsZSRvcHRpb25zJGRlYnVnQSA9IHRhYmxlLm9wdGlvbnMuZGVidWdBbGwpICE9IG51bGwgPyBfdGFibGUkb3B0aW9ucyRkZWJ1Z0EgOiB0YWJsZS5vcHRpb25zLmRlYnVnUm93cztcbiAgICAgIH1cbiAgICB9KTtcbiAgICByb3cuZ2V0VmlzaWJsZUNlbGxzID0gbWVtbygoKSA9PiBbcm93LmdldExlZnRWaXNpYmxlQ2VsbHMoKSwgcm93LmdldENlbnRlclZpc2libGVDZWxscygpLCByb3cuZ2V0UmlnaHRWaXNpYmxlQ2VsbHMoKV0sIChsZWZ0LCBjZW50ZXIsIHJpZ2h0KSA9PiBbLi4ubGVmdCwgLi4uY2VudGVyLCAuLi5yaWdodF0sIHtcbiAgICAgIGtleTogcHJvY2Vzcy5lbnYuTk9ERV9FTlYgPT09ICdkZXZlbG9wbWVudCcgJiYgJ3Jvdy5nZXRWaXNpYmxlQ2VsbHMnLFxuICAgICAgZGVidWc6ICgpID0+IHtcbiAgICAgICAgdmFyIF90YWJsZSRvcHRpb25zJGRlYnVnQTI7XG4gICAgICAgIHJldHVybiAoX3RhYmxlJG9wdGlvbnMkZGVidWdBMiA9IHRhYmxlLm9wdGlvbnMuZGVidWdBbGwpICE9IG51bGwgPyBfdGFibGUkb3B0aW9ucyRkZWJ1Z0EyIDogdGFibGUub3B0aW9ucy5kZWJ1Z1Jvd3M7XG4gICAgICB9XG4gICAgfSk7XG4gIH0sXG4gIGNyZWF0ZVRhYmxlOiB0YWJsZSA9PiB7XG4gICAgY29uc3QgbWFrZVZpc2libGVDb2x1bW5zTWV0aG9kID0gKGtleSwgZ2V0Q29sdW1ucykgPT4ge1xuICAgICAgcmV0dXJuIG1lbW8oKCkgPT4gW2dldENvbHVtbnMoKSwgZ2V0Q29sdW1ucygpLmZpbHRlcihkID0+IGQuZ2V0SXNWaXNpYmxlKCkpLm1hcChkID0+IGQuaWQpLmpvaW4oJ18nKV0sIGNvbHVtbnMgPT4ge1xuICAgICAgICByZXR1cm4gY29sdW1ucy5maWx0ZXIoZCA9PiBkLmdldElzVmlzaWJsZSA9PSBudWxsID8gdm9pZCAwIDogZC5nZXRJc1Zpc2libGUoKSk7XG4gICAgICB9LCB7XG4gICAgICAgIGtleSxcbiAgICAgICAgZGVidWc6ICgpID0+IHtcbiAgICAgICAgICB2YXIgX3RhYmxlJG9wdGlvbnMkZGVidWdBMztcbiAgICAgICAgICByZXR1cm4gKF90YWJsZSRvcHRpb25zJGRlYnVnQTMgPSB0YWJsZS5vcHRpb25zLmRlYnVnQWxsKSAhPSBudWxsID8gX3RhYmxlJG9wdGlvbnMkZGVidWdBMyA6IHRhYmxlLm9wdGlvbnMuZGVidWdDb2x1bW5zO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICB9O1xuICAgIHRhYmxlLmdldFZpc2libGVGbGF0Q29sdW1ucyA9IG1ha2VWaXNpYmxlQ29sdW1uc01ldGhvZCgnZ2V0VmlzaWJsZUZsYXRDb2x1bW5zJywgKCkgPT4gdGFibGUuZ2V0QWxsRmxhdENvbHVtbnMoKSk7XG4gICAgdGFibGUuZ2V0VmlzaWJsZUxlYWZDb2x1bW5zID0gbWFrZVZpc2libGVDb2x1bW5zTWV0aG9kKCdnZXRWaXNpYmxlTGVhZkNvbHVtbnMnLCAoKSA9PiB0YWJsZS5nZXRBbGxMZWFmQ29sdW1ucygpKTtcbiAgICB0YWJsZS5nZXRMZWZ0VmlzaWJsZUxlYWZDb2x1bW5zID0gbWFrZVZpc2libGVDb2x1bW5zTWV0aG9kKCdnZXRMZWZ0VmlzaWJsZUxlYWZDb2x1bW5zJywgKCkgPT4gdGFibGUuZ2V0TGVmdExlYWZDb2x1bW5zKCkpO1xuICAgIHRhYmxlLmdldFJpZ2h0VmlzaWJsZUxlYWZDb2x1bW5zID0gbWFrZVZpc2libGVDb2x1bW5zTWV0aG9kKCdnZXRSaWdodFZpc2libGVMZWFmQ29sdW1ucycsICgpID0+IHRhYmxlLmdldFJpZ2h0TGVhZkNvbHVtbnMoKSk7XG4gICAgdGFibGUuZ2V0Q2VudGVyVmlzaWJsZUxlYWZDb2x1bW5zID0gbWFrZVZpc2libGVDb2x1bW5zTWV0aG9kKCdnZXRDZW50ZXJWaXNpYmxlTGVhZkNvbHVtbnMnLCAoKSA9PiB0YWJsZS5nZXRDZW50ZXJMZWFmQ29sdW1ucygpKTtcbiAgICB0YWJsZS5zZXRDb2x1bW5WaXNpYmlsaXR5ID0gdXBkYXRlciA9PiB0YWJsZS5vcHRpb25zLm9uQ29sdW1uVmlzaWJpbGl0eUNoYW5nZSA9PSBudWxsID8gdm9pZCAwIDogdGFibGUub3B0aW9ucy5vbkNvbHVtblZpc2liaWxpdHlDaGFuZ2UodXBkYXRlcik7XG4gICAgdGFibGUucmVzZXRDb2x1bW5WaXNpYmlsaXR5ID0gZGVmYXVsdFN0YXRlID0+IHtcbiAgICAgIHZhciBfdGFibGUkaW5pdGlhbFN0YXRlJGM7XG4gICAgICB0YWJsZS5zZXRDb2x1bW5WaXNpYmlsaXR5KGRlZmF1bHRTdGF0ZSA/IHt9IDogKF90YWJsZSRpbml0aWFsU3RhdGUkYyA9IHRhYmxlLmluaXRpYWxTdGF0ZS5jb2x1bW5WaXNpYmlsaXR5KSAhPSBudWxsID8gX3RhYmxlJGluaXRpYWxTdGF0ZSRjIDoge30pO1xuICAgIH07XG4gICAgdGFibGUudG9nZ2xlQWxsQ29sdW1uc1Zpc2libGUgPSB2YWx1ZSA9PiB7XG4gICAgICB2YXIgX3ZhbHVlO1xuICAgICAgdmFsdWUgPSAoX3ZhbHVlID0gdmFsdWUpICE9IG51bGwgPyBfdmFsdWUgOiAhdGFibGUuZ2V0SXNBbGxDb2x1bW5zVmlzaWJsZSgpO1xuICAgICAgdGFibGUuc2V0Q29sdW1uVmlzaWJpbGl0eSh0YWJsZS5nZXRBbGxMZWFmQ29sdW1ucygpLnJlZHVjZSgob2JqLCBjb2x1bW4pID0+ICh7XG4gICAgICAgIC4uLm9iaixcbiAgICAgICAgW2NvbHVtbi5pZF06ICF2YWx1ZSA/ICEoY29sdW1uLmdldENhbkhpZGUgIT0gbnVsbCAmJiBjb2x1bW4uZ2V0Q2FuSGlkZSgpKSA6IHZhbHVlXG4gICAgICB9KSwge30pKTtcbiAgICB9O1xuICAgIHRhYmxlLmdldElzQWxsQ29sdW1uc1Zpc2libGUgPSAoKSA9PiAhdGFibGUuZ2V0QWxsTGVhZkNvbHVtbnMoKS5zb21lKGNvbHVtbiA9PiAhKGNvbHVtbi5nZXRJc1Zpc2libGUgIT0gbnVsbCAmJiBjb2x1bW4uZ2V0SXNWaXNpYmxlKCkpKTtcbiAgICB0YWJsZS5nZXRJc1NvbWVDb2x1bW5zVmlzaWJsZSA9ICgpID0+IHRhYmxlLmdldEFsbExlYWZDb2x1bW5zKCkuc29tZShjb2x1bW4gPT4gY29sdW1uLmdldElzVmlzaWJsZSA9PSBudWxsID8gdm9pZCAwIDogY29sdW1uLmdldElzVmlzaWJsZSgpKTtcbiAgICB0YWJsZS5nZXRUb2dnbGVBbGxDb2x1bW5zVmlzaWJpbGl0eUhhbmRsZXIgPSAoKSA9PiB7XG4gICAgICByZXR1cm4gZSA9PiB7XG4gICAgICAgIHZhciBfdGFyZ2V0O1xuICAgICAgICB0YWJsZS50b2dnbGVBbGxDb2x1bW5zVmlzaWJsZSgoX3RhcmdldCA9IGUudGFyZ2V0KSA9PSBudWxsID8gdm9pZCAwIDogX3RhcmdldC5jaGVja2VkKTtcbiAgICAgIH07XG4gICAgfTtcbiAgfVxufTtcblxuY29uc3QgZmVhdHVyZXMgPSBbSGVhZGVycywgVmlzaWJpbGl0eSwgT3JkZXJpbmcsIFBpbm5pbmcsIEZpbHRlcnMsIFNvcnRpbmcsIEdyb3VwaW5nLCBFeHBhbmRpbmcsIFBhZ2luYXRpb24sIFJvd1NlbGVjdGlvbiwgQ29sdW1uU2l6aW5nXTtcblxuLy9cblxuZnVuY3Rpb24gY3JlYXRlVGFibGUob3B0aW9ucykge1xuICB2YXIgX29wdGlvbnMkaW5pdGlhbFN0YXRlO1xuICBpZiAob3B0aW9ucy5kZWJ1Z0FsbCB8fCBvcHRpb25zLmRlYnVnVGFibGUpIHtcbiAgICBjb25zb2xlLmluZm8oJ0NyZWF0aW5nIFRhYmxlIEluc3RhbmNlLi4uJyk7XG4gIH1cbiAgbGV0IHRhYmxlID0ge1xuICAgIF9mZWF0dXJlczogZmVhdHVyZXNcbiAgfTtcbiAgY29uc3QgZGVmYXVsdE9wdGlvbnMgPSB0YWJsZS5fZmVhdHVyZXMucmVkdWNlKChvYmosIGZlYXR1cmUpID0+IHtcbiAgICByZXR1cm4gT2JqZWN0LmFzc2lnbihvYmosIGZlYXR1cmUuZ2V0RGVmYXVsdE9wdGlvbnMgPT0gbnVsbCA/IHZvaWQgMCA6IGZlYXR1cmUuZ2V0RGVmYXVsdE9wdGlvbnModGFibGUpKTtcbiAgfSwge30pO1xuICBjb25zdCBtZXJnZU9wdGlvbnMgPSBvcHRpb25zID0+IHtcbiAgICBpZiAodGFibGUub3B0aW9ucy5tZXJnZU9wdGlvbnMpIHtcbiAgICAgIHJldHVybiB0YWJsZS5vcHRpb25zLm1lcmdlT3B0aW9ucyhkZWZhdWx0T3B0aW9ucywgb3B0aW9ucyk7XG4gICAgfVxuICAgIHJldHVybiB7XG4gICAgICAuLi5kZWZhdWx0T3B0aW9ucyxcbiAgICAgIC4uLm9wdGlvbnNcbiAgICB9O1xuICB9O1xuICBjb25zdCBjb3JlSW5pdGlhbFN0YXRlID0ge307XG4gIGxldCBpbml0aWFsU3RhdGUgPSB7XG4gICAgLi4uY29yZUluaXRpYWxTdGF0ZSxcbiAgICAuLi4oKF9vcHRpb25zJGluaXRpYWxTdGF0ZSA9IG9wdGlvbnMuaW5pdGlhbFN0YXRlKSAhPSBudWxsID8gX29wdGlvbnMkaW5pdGlhbFN0YXRlIDoge30pXG4gIH07XG4gIHRhYmxlLl9mZWF0dXJlcy5mb3JFYWNoKGZlYXR1cmUgPT4ge1xuICAgIHZhciBfZmVhdHVyZSRnZXRJbml0aWFsU3Q7XG4gICAgaW5pdGlhbFN0YXRlID0gKF9mZWF0dXJlJGdldEluaXRpYWxTdCA9IGZlYXR1cmUuZ2V0SW5pdGlhbFN0YXRlID09IG51bGwgPyB2b2lkIDAgOiBmZWF0dXJlLmdldEluaXRpYWxTdGF0ZShpbml0aWFsU3RhdGUpKSAhPSBudWxsID8gX2ZlYXR1cmUkZ2V0SW5pdGlhbFN0IDogaW5pdGlhbFN0YXRlO1xuICB9KTtcbiAgY29uc3QgcXVldWVkID0gW107XG4gIGxldCBxdWV1ZWRUaW1lb3V0ID0gZmFsc2U7XG4gIGNvbnN0IGNvcmVJbnN0YW5jZSA9IHtcbiAgICBfZmVhdHVyZXM6IGZlYXR1cmVzLFxuICAgIG9wdGlvbnM6IHtcbiAgICAgIC4uLmRlZmF1bHRPcHRpb25zLFxuICAgICAgLi4ub3B0aW9uc1xuICAgIH0sXG4gICAgaW5pdGlhbFN0YXRlLFxuICAgIF9xdWV1ZTogY2IgPT4ge1xuICAgICAgcXVldWVkLnB1c2goY2IpO1xuICAgICAgaWYgKCFxdWV1ZWRUaW1lb3V0KSB7XG4gICAgICAgIHF1ZXVlZFRpbWVvdXQgPSB0cnVlO1xuXG4gICAgICAgIC8vIFNjaGVkdWxlIGEgbWljcm90YXNrIHRvIHJ1biB0aGUgcXVldWVkIGNhbGxiYWNrcyBhZnRlclxuICAgICAgICAvLyB0aGUgY3VycmVudCBjYWxsIHN0YWNrIChyZW5kZXIsIGV0YykgaGFzIGZpbmlzaGVkLlxuICAgICAgICBQcm9taXNlLnJlc29sdmUoKS50aGVuKCgpID0+IHtcbiAgICAgICAgICB3aGlsZSAocXVldWVkLmxlbmd0aCkge1xuICAgICAgICAgICAgcXVldWVkLnNoaWZ0KCkoKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgcXVldWVkVGltZW91dCA9IGZhbHNlO1xuICAgICAgICB9KS5jYXRjaChlcnJvciA9PiBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgICAgICB0aHJvdyBlcnJvcjtcbiAgICAgICAgfSkpO1xuICAgICAgfVxuICAgIH0sXG4gICAgcmVzZXQ6ICgpID0+IHtcbiAgICAgIHRhYmxlLnNldFN0YXRlKHRhYmxlLmluaXRpYWxTdGF0ZSk7XG4gICAgfSxcbiAgICBzZXRPcHRpb25zOiB1cGRhdGVyID0+IHtcbiAgICAgIGNvbnN0IG5ld09wdGlvbnMgPSBmdW5jdGlvbmFsVXBkYXRlKHVwZGF0ZXIsIHRhYmxlLm9wdGlvbnMpO1xuICAgICAgdGFibGUub3B0aW9ucyA9IG1lcmdlT3B0aW9ucyhuZXdPcHRpb25zKTtcbiAgICB9LFxuICAgIGdldFN0YXRlOiAoKSA9PiB7XG4gICAgICByZXR1cm4gdGFibGUub3B0aW9ucy5zdGF0ZTtcbiAgICB9LFxuICAgIHNldFN0YXRlOiB1cGRhdGVyID0+IHtcbiAgICAgIHRhYmxlLm9wdGlvbnMub25TdGF0ZUNoYW5nZSA9PSBudWxsIHx8IHRhYmxlLm9wdGlvbnMub25TdGF0ZUNoYW5nZSh1cGRhdGVyKTtcbiAgICB9LFxuICAgIF9nZXRSb3dJZDogKHJvdywgaW5kZXgsIHBhcmVudCkgPT4ge1xuICAgICAgdmFyIF90YWJsZSRvcHRpb25zJGdldFJvdztcbiAgICAgIHJldHVybiAoX3RhYmxlJG9wdGlvbnMkZ2V0Um93ID0gdGFibGUub3B0aW9ucy5nZXRSb3dJZCA9PSBudWxsID8gdm9pZCAwIDogdGFibGUub3B0aW9ucy5nZXRSb3dJZChyb3csIGluZGV4LCBwYXJlbnQpKSAhPSBudWxsID8gX3RhYmxlJG9wdGlvbnMkZ2V0Um93IDogYCR7cGFyZW50ID8gW3BhcmVudC5pZCwgaW5kZXhdLmpvaW4oJy4nKSA6IGluZGV4fWA7XG4gICAgfSxcbiAgICBnZXRDb3JlUm93TW9kZWw6ICgpID0+IHtcbiAgICAgIGlmICghdGFibGUuX2dldENvcmVSb3dNb2RlbCkge1xuICAgICAgICB0YWJsZS5fZ2V0Q29yZVJvd01vZGVsID0gdGFibGUub3B0aW9ucy5nZXRDb3JlUm93TW9kZWwodGFibGUpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHRhYmxlLl9nZXRDb3JlUm93TW9kZWwoKTtcbiAgICB9LFxuICAgIC8vIFRoZSBmaW5hbCBjYWxscyBzdGFydCBhdCB0aGUgYm90dG9tIG9mIHRoZSBtb2RlbCxcbiAgICAvLyBleHBhbmRlZCByb3dzLCB3aGljaCB0aGVuIHdvcmsgdGhlaXIgd2F5IHVwXG5cbiAgICBnZXRSb3dNb2RlbDogKCkgPT4ge1xuICAgICAgcmV0dXJuIHRhYmxlLmdldFBhZ2luYXRpb25Sb3dNb2RlbCgpO1xuICAgIH0sXG4gICAgZ2V0Um93OiAoaWQsIHNlYXJjaEFsbCkgPT4ge1xuICAgICAgY29uc3Qgcm93ID0gKHNlYXJjaEFsbCA/IHRhYmxlLmdldENvcmVSb3dNb2RlbCgpIDogdGFibGUuZ2V0Um93TW9kZWwoKSkucm93c0J5SWRbaWRdO1xuICAgICAgaWYgKCFyb3cpIHtcbiAgICAgICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYGdldFJvdyBleHBlY3RlZCBhbiBJRCwgYnV0IGdvdCAke2lkfWApO1xuICAgICAgICB9XG4gICAgICAgIHRocm93IG5ldyBFcnJvcigpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHJvdztcbiAgICB9LFxuICAgIF9nZXREZWZhdWx0Q29sdW1uRGVmOiBtZW1vKCgpID0+IFt0YWJsZS5vcHRpb25zLmRlZmF1bHRDb2x1bW5dLCBkZWZhdWx0Q29sdW1uID0+IHtcbiAgICAgIHZhciBfZGVmYXVsdENvbHVtbjtcbiAgICAgIGRlZmF1bHRDb2x1bW4gPSAoX2RlZmF1bHRDb2x1bW4gPSBkZWZhdWx0Q29sdW1uKSAhPSBudWxsID8gX2RlZmF1bHRDb2x1bW4gOiB7fTtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIGhlYWRlcjogcHJvcHMgPT4ge1xuICAgICAgICAgIGNvbnN0IHJlc29sdmVkQ29sdW1uRGVmID0gcHJvcHMuaGVhZGVyLmNvbHVtbi5jb2x1bW5EZWY7XG4gICAgICAgICAgaWYgKHJlc29sdmVkQ29sdW1uRGVmLmFjY2Vzc29yS2V5KSB7XG4gICAgICAgICAgICByZXR1cm4gcmVzb2x2ZWRDb2x1bW5EZWYuYWNjZXNzb3JLZXk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmIChyZXNvbHZlZENvbHVtbkRlZi5hY2Nlc3NvckZuKSB7XG4gICAgICAgICAgICByZXR1cm4gcmVzb2x2ZWRDb2x1bW5EZWYuaWQ7XG4gICAgICAgICAgfVxuICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9LFxuICAgICAgICAvLyBmb290ZXI6IHByb3BzID0+IHByb3BzLmhlYWRlci5jb2x1bW4uaWQsXG4gICAgICAgIGNlbGw6IHByb3BzID0+IHtcbiAgICAgICAgICB2YXIgX3Byb3BzJHJlbmRlclZhbHVlJHRvLCBfcHJvcHMkcmVuZGVyVmFsdWU7XG4gICAgICAgICAgcmV0dXJuIChfcHJvcHMkcmVuZGVyVmFsdWUkdG8gPSAoX3Byb3BzJHJlbmRlclZhbHVlID0gcHJvcHMucmVuZGVyVmFsdWUoKSkgPT0gbnVsbCB8fCBfcHJvcHMkcmVuZGVyVmFsdWUudG9TdHJpbmcgPT0gbnVsbCA/IHZvaWQgMCA6IF9wcm9wcyRyZW5kZXJWYWx1ZS50b1N0cmluZygpKSAhPSBudWxsID8gX3Byb3BzJHJlbmRlclZhbHVlJHRvIDogbnVsbDtcbiAgICAgICAgfSxcbiAgICAgICAgLi4udGFibGUuX2ZlYXR1cmVzLnJlZHVjZSgob2JqLCBmZWF0dXJlKSA9PiB7XG4gICAgICAgICAgcmV0dXJuIE9iamVjdC5hc3NpZ24ob2JqLCBmZWF0dXJlLmdldERlZmF1bHRDb2x1bW5EZWYgPT0gbnVsbCA/IHZvaWQgMCA6IGZlYXR1cmUuZ2V0RGVmYXVsdENvbHVtbkRlZigpKTtcbiAgICAgICAgfSwge30pLFxuICAgICAgICAuLi5kZWZhdWx0Q29sdW1uXG4gICAgICB9O1xuICAgIH0sIHtcbiAgICAgIGRlYnVnOiAoKSA9PiB7XG4gICAgICAgIHZhciBfdGFibGUkb3B0aW9ucyRkZWJ1Z0E7XG4gICAgICAgIHJldHVybiAoX3RhYmxlJG9wdGlvbnMkZGVidWdBID0gdGFibGUub3B0aW9ucy5kZWJ1Z0FsbCkgIT0gbnVsbCA/IF90YWJsZSRvcHRpb25zJGRlYnVnQSA6IHRhYmxlLm9wdGlvbnMuZGVidWdDb2x1bW5zO1xuICAgICAgfSxcbiAgICAgIGtleTogcHJvY2Vzcy5lbnYuTk9ERV9FTlYgPT09ICdkZXZlbG9wbWVudCcgJiYgJ2dldERlZmF1bHRDb2x1bW5EZWYnXG4gICAgfSksXG4gICAgX2dldENvbHVtbkRlZnM6ICgpID0+IHRhYmxlLm9wdGlvbnMuY29sdW1ucyxcbiAgICBnZXRBbGxDb2x1bW5zOiBtZW1vKCgpID0+IFt0YWJsZS5fZ2V0Q29sdW1uRGVmcygpXSwgY29sdW1uRGVmcyA9PiB7XG4gICAgICBjb25zdCByZWN1cnNlQ29sdW1ucyA9IGZ1bmN0aW9uIChjb2x1bW5EZWZzLCBwYXJlbnQsIGRlcHRoKSB7XG4gICAgICAgIGlmIChkZXB0aCA9PT0gdm9pZCAwKSB7XG4gICAgICAgICAgZGVwdGggPSAwO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBjb2x1bW5EZWZzLm1hcChjb2x1bW5EZWYgPT4ge1xuICAgICAgICAgIGNvbnN0IGNvbHVtbiA9IGNyZWF0ZUNvbHVtbih0YWJsZSwgY29sdW1uRGVmLCBkZXB0aCwgcGFyZW50KTtcbiAgICAgICAgICBjb25zdCBncm91cGluZ0NvbHVtbkRlZiA9IGNvbHVtbkRlZjtcbiAgICAgICAgICBjb2x1bW4uY29sdW1ucyA9IGdyb3VwaW5nQ29sdW1uRGVmLmNvbHVtbnMgPyByZWN1cnNlQ29sdW1ucyhncm91cGluZ0NvbHVtbkRlZi5jb2x1bW5zLCBjb2x1bW4sIGRlcHRoICsgMSkgOiBbXTtcbiAgICAgICAgICByZXR1cm4gY29sdW1uO1xuICAgICAgICB9KTtcbiAgICAgIH07XG4gICAgICByZXR1cm4gcmVjdXJzZUNvbHVtbnMoY29sdW1uRGVmcyk7XG4gICAgfSwge1xuICAgICAga2V5OiBwcm9jZXNzLmVudi5OT0RFX0VOViA9PT0gJ2RldmVsb3BtZW50JyAmJiAnZ2V0QWxsQ29sdW1ucycsXG4gICAgICBkZWJ1ZzogKCkgPT4ge1xuICAgICAgICB2YXIgX3RhYmxlJG9wdGlvbnMkZGVidWdBMjtcbiAgICAgICAgcmV0dXJuIChfdGFibGUkb3B0aW9ucyRkZWJ1Z0EyID0gdGFibGUub3B0aW9ucy5kZWJ1Z0FsbCkgIT0gbnVsbCA/IF90YWJsZSRvcHRpb25zJGRlYnVnQTIgOiB0YWJsZS5vcHRpb25zLmRlYnVnQ29sdW1ucztcbiAgICAgIH1cbiAgICB9KSxcbiAgICBnZXRBbGxGbGF0Q29sdW1uczogbWVtbygoKSA9PiBbdGFibGUuZ2V0QWxsQ29sdW1ucygpXSwgYWxsQ29sdW1ucyA9PiB7XG4gICAgICByZXR1cm4gYWxsQ29sdW1ucy5mbGF0TWFwKGNvbHVtbiA9PiB7XG4gICAgICAgIHJldHVybiBjb2x1bW4uZ2V0RmxhdENvbHVtbnMoKTtcbiAgICAgIH0pO1xuICAgIH0sIHtcbiAgICAgIGtleTogcHJvY2Vzcy5lbnYuTk9ERV9FTlYgPT09ICdkZXZlbG9wbWVudCcgJiYgJ2dldEFsbEZsYXRDb2x1bW5zJyxcbiAgICAgIGRlYnVnOiAoKSA9PiB7XG4gICAgICAgIHZhciBfdGFibGUkb3B0aW9ucyRkZWJ1Z0EzO1xuICAgICAgICByZXR1cm4gKF90YWJsZSRvcHRpb25zJGRlYnVnQTMgPSB0YWJsZS5vcHRpb25zLmRlYnVnQWxsKSAhPSBudWxsID8gX3RhYmxlJG9wdGlvbnMkZGVidWdBMyA6IHRhYmxlLm9wdGlvbnMuZGVidWdDb2x1bW5zO1xuICAgICAgfVxuICAgIH0pLFxuICAgIF9nZXRBbGxGbGF0Q29sdW1uc0J5SWQ6IG1lbW8oKCkgPT4gW3RhYmxlLmdldEFsbEZsYXRDb2x1bW5zKCldLCBmbGF0Q29sdW1ucyA9PiB7XG4gICAgICByZXR1cm4gZmxhdENvbHVtbnMucmVkdWNlKChhY2MsIGNvbHVtbikgPT4ge1xuICAgICAgICBhY2NbY29sdW1uLmlkXSA9IGNvbHVtbjtcbiAgICAgICAgcmV0dXJuIGFjYztcbiAgICAgIH0sIHt9KTtcbiAgICB9LCB7XG4gICAgICBrZXk6IHByb2Nlc3MuZW52Lk5PREVfRU5WID09PSAnZGV2ZWxvcG1lbnQnICYmICdnZXRBbGxGbGF0Q29sdW1uc0J5SWQnLFxuICAgICAgZGVidWc6ICgpID0+IHtcbiAgICAgICAgdmFyIF90YWJsZSRvcHRpb25zJGRlYnVnQTQ7XG4gICAgICAgIHJldHVybiAoX3RhYmxlJG9wdGlvbnMkZGVidWdBNCA9IHRhYmxlLm9wdGlvbnMuZGVidWdBbGwpICE9IG51bGwgPyBfdGFibGUkb3B0aW9ucyRkZWJ1Z0E0IDogdGFibGUub3B0aW9ucy5kZWJ1Z0NvbHVtbnM7XG4gICAgICB9XG4gICAgfSksXG4gICAgZ2V0QWxsTGVhZkNvbHVtbnM6IG1lbW8oKCkgPT4gW3RhYmxlLmdldEFsbENvbHVtbnMoKSwgdGFibGUuX2dldE9yZGVyQ29sdW1uc0ZuKCldLCAoYWxsQ29sdW1ucywgb3JkZXJDb2x1bW5zKSA9PiB7XG4gICAgICBsZXQgbGVhZkNvbHVtbnMgPSBhbGxDb2x1bW5zLmZsYXRNYXAoY29sdW1uID0+IGNvbHVtbi5nZXRMZWFmQ29sdW1ucygpKTtcbiAgICAgIHJldHVybiBvcmRlckNvbHVtbnMobGVhZkNvbHVtbnMpO1xuICAgIH0sIHtcbiAgICAgIGtleTogcHJvY2Vzcy5lbnYuTk9ERV9FTlYgPT09ICdkZXZlbG9wbWVudCcgJiYgJ2dldEFsbExlYWZDb2x1bW5zJyxcbiAgICAgIGRlYnVnOiAoKSA9PiB7XG4gICAgICAgIHZhciBfdGFibGUkb3B0aW9ucyRkZWJ1Z0E1O1xuICAgICAgICByZXR1cm4gKF90YWJsZSRvcHRpb25zJGRlYnVnQTUgPSB0YWJsZS5vcHRpb25zLmRlYnVnQWxsKSAhPSBudWxsID8gX3RhYmxlJG9wdGlvbnMkZGVidWdBNSA6IHRhYmxlLm9wdGlvbnMuZGVidWdDb2x1bW5zO1xuICAgICAgfVxuICAgIH0pLFxuICAgIGdldENvbHVtbjogY29sdW1uSWQgPT4ge1xuICAgICAgY29uc3QgY29sdW1uID0gdGFibGUuX2dldEFsbEZsYXRDb2x1bW5zQnlJZCgpW2NvbHVtbklkXTtcbiAgICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nICYmICFjb2x1bW4pIHtcbiAgICAgICAgY29uc29sZS5lcnJvcihgW1RhYmxlXSBDb2x1bW4gd2l0aCBpZCAnJHtjb2x1bW5JZH0nIGRvZXMgbm90IGV4aXN0LmApO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGNvbHVtbjtcbiAgICB9XG4gIH07XG4gIE9iamVjdC5hc3NpZ24odGFibGUsIGNvcmVJbnN0YW5jZSk7XG4gIGZvciAobGV0IGluZGV4ID0gMDsgaW5kZXggPCB0YWJsZS5fZmVhdHVyZXMubGVuZ3RoOyBpbmRleCsrKSB7XG4gICAgY29uc3QgZmVhdHVyZSA9IHRhYmxlLl9mZWF0dXJlc1tpbmRleF07XG4gICAgZmVhdHVyZSA9PSBudWxsIHx8IGZlYXR1cmUuY3JlYXRlVGFibGUgPT0gbnVsbCB8fCBmZWF0dXJlLmNyZWF0ZVRhYmxlKHRhYmxlKTtcbiAgfVxuICByZXR1cm4gdGFibGU7XG59XG5cbmZ1bmN0aW9uIGNyZWF0ZUNlbGwodGFibGUsIHJvdywgY29sdW1uLCBjb2x1bW5JZCkge1xuICBjb25zdCBnZXRSZW5kZXJWYWx1ZSA9ICgpID0+IHtcbiAgICB2YXIgX2NlbGwkZ2V0VmFsdWU7XG4gICAgcmV0dXJuIChfY2VsbCRnZXRWYWx1ZSA9IGNlbGwuZ2V0VmFsdWUoKSkgIT0gbnVsbCA/IF9jZWxsJGdldFZhbHVlIDogdGFibGUub3B0aW9ucy5yZW5kZXJGYWxsYmFja1ZhbHVlO1xuICB9O1xuICBjb25zdCBjZWxsID0ge1xuICAgIGlkOiBgJHtyb3cuaWR9XyR7Y29sdW1uLmlkfWAsXG4gICAgcm93LFxuICAgIGNvbHVtbixcbiAgICBnZXRWYWx1ZTogKCkgPT4gcm93LmdldFZhbHVlKGNvbHVtbklkKSxcbiAgICByZW5kZXJWYWx1ZTogZ2V0UmVuZGVyVmFsdWUsXG4gICAgZ2V0Q29udGV4dDogbWVtbygoKSA9PiBbdGFibGUsIGNvbHVtbiwgcm93LCBjZWxsXSwgKHRhYmxlLCBjb2x1bW4sIHJvdywgY2VsbCkgPT4gKHtcbiAgICAgIHRhYmxlLFxuICAgICAgY29sdW1uLFxuICAgICAgcm93LFxuICAgICAgY2VsbDogY2VsbCxcbiAgICAgIGdldFZhbHVlOiBjZWxsLmdldFZhbHVlLFxuICAgICAgcmVuZGVyVmFsdWU6IGNlbGwucmVuZGVyVmFsdWVcbiAgICB9KSwge1xuICAgICAga2V5OiBwcm9jZXNzLmVudi5OT0RFX0VOViA9PT0gJ2RldmVsb3BtZW50JyAmJiAnY2VsbC5nZXRDb250ZXh0JyxcbiAgICAgIGRlYnVnOiAoKSA9PiB0YWJsZS5vcHRpb25zLmRlYnVnQWxsXG4gICAgfSlcbiAgfTtcbiAgdGFibGUuX2ZlYXR1cmVzLmZvckVhY2goZmVhdHVyZSA9PiB7XG4gICAgZmVhdHVyZS5jcmVhdGVDZWxsID09IG51bGwgfHwgZmVhdHVyZS5jcmVhdGVDZWxsKGNlbGwsIGNvbHVtbiwgcm93LCB0YWJsZSk7XG4gIH0sIHt9KTtcbiAgcmV0dXJuIGNlbGw7XG59XG5cbmNvbnN0IGNyZWF0ZVJvdyA9ICh0YWJsZSwgaWQsIG9yaWdpbmFsLCByb3dJbmRleCwgZGVwdGgsIHN1YlJvd3MsIHBhcmVudElkKSA9PiB7XG4gIGxldCByb3cgPSB7XG4gICAgaWQsXG4gICAgaW5kZXg6IHJvd0luZGV4LFxuICAgIG9yaWdpbmFsLFxuICAgIGRlcHRoLFxuICAgIHBhcmVudElkLFxuICAgIF92YWx1ZXNDYWNoZToge30sXG4gICAgX3VuaXF1ZVZhbHVlc0NhY2hlOiB7fSxcbiAgICBnZXRWYWx1ZTogY29sdW1uSWQgPT4ge1xuICAgICAgaWYgKHJvdy5fdmFsdWVzQ2FjaGUuaGFzT3duUHJvcGVydHkoY29sdW1uSWQpKSB7XG4gICAgICAgIHJldHVybiByb3cuX3ZhbHVlc0NhY2hlW2NvbHVtbklkXTtcbiAgICAgIH1cbiAgICAgIGNvbnN0IGNvbHVtbiA9IHRhYmxlLmdldENvbHVtbihjb2x1bW5JZCk7XG4gICAgICBpZiAoIShjb2x1bW4gIT0gbnVsbCAmJiBjb2x1bW4uYWNjZXNzb3JGbikpIHtcbiAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICAgIH1cbiAgICAgIHJvdy5fdmFsdWVzQ2FjaGVbY29sdW1uSWRdID0gY29sdW1uLmFjY2Vzc29yRm4ocm93Lm9yaWdpbmFsLCByb3dJbmRleCk7XG4gICAgICByZXR1cm4gcm93Ll92YWx1ZXNDYWNoZVtjb2x1bW5JZF07XG4gICAgfSxcbiAgICBnZXRVbmlxdWVWYWx1ZXM6IGNvbHVtbklkID0+IHtcbiAgICAgIGlmIChyb3cuX3VuaXF1ZVZhbHVlc0NhY2hlLmhhc093blByb3BlcnR5KGNvbHVtbklkKSkge1xuICAgICAgICByZXR1cm4gcm93Ll91bmlxdWVWYWx1ZXNDYWNoZVtjb2x1bW5JZF07XG4gICAgICB9XG4gICAgICBjb25zdCBjb2x1bW4gPSB0YWJsZS5nZXRDb2x1bW4oY29sdW1uSWQpO1xuICAgICAgaWYgKCEoY29sdW1uICE9IG51bGwgJiYgY29sdW1uLmFjY2Vzc29yRm4pKSB7XG4gICAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgICB9XG4gICAgICBpZiAoIWNvbHVtbi5jb2x1bW5EZWYuZ2V0VW5pcXVlVmFsdWVzKSB7XG4gICAgICAgIHJvdy5fdW5pcXVlVmFsdWVzQ2FjaGVbY29sdW1uSWRdID0gW3Jvdy5nZXRWYWx1ZShjb2x1bW5JZCldO1xuICAgICAgICByZXR1cm4gcm93Ll91bmlxdWVWYWx1ZXNDYWNoZVtjb2x1bW5JZF07XG4gICAgICB9XG4gICAgICByb3cuX3VuaXF1ZVZhbHVlc0NhY2hlW2NvbHVtbklkXSA9IGNvbHVtbi5jb2x1bW5EZWYuZ2V0VW5pcXVlVmFsdWVzKHJvdy5vcmlnaW5hbCwgcm93SW5kZXgpO1xuICAgICAgcmV0dXJuIHJvdy5fdW5pcXVlVmFsdWVzQ2FjaGVbY29sdW1uSWRdO1xuICAgIH0sXG4gICAgcmVuZGVyVmFsdWU6IGNvbHVtbklkID0+IHtcbiAgICAgIHZhciBfcm93JGdldFZhbHVlO1xuICAgICAgcmV0dXJuIChfcm93JGdldFZhbHVlID0gcm93LmdldFZhbHVlKGNvbHVtbklkKSkgIT0gbnVsbCA/IF9yb3ckZ2V0VmFsdWUgOiB0YWJsZS5vcHRpb25zLnJlbmRlckZhbGxiYWNrVmFsdWU7XG4gICAgfSxcbiAgICBzdWJSb3dzOiBzdWJSb3dzICE9IG51bGwgPyBzdWJSb3dzIDogW10sXG4gICAgZ2V0TGVhZlJvd3M6ICgpID0+IGZsYXR0ZW5CeShyb3cuc3ViUm93cywgZCA9PiBkLnN1YlJvd3MpLFxuICAgIGdldFBhcmVudFJvdzogKCkgPT4gcm93LnBhcmVudElkID8gdGFibGUuZ2V0Um93KHJvdy5wYXJlbnRJZCwgdHJ1ZSkgOiB1bmRlZmluZWQsXG4gICAgZ2V0UGFyZW50Um93czogKCkgPT4ge1xuICAgICAgbGV0IHBhcmVudFJvd3MgPSBbXTtcbiAgICAgIGxldCBjdXJyZW50Um93ID0gcm93O1xuICAgICAgd2hpbGUgKHRydWUpIHtcbiAgICAgICAgY29uc3QgcGFyZW50Um93ID0gY3VycmVudFJvdy5nZXRQYXJlbnRSb3coKTtcbiAgICAgICAgaWYgKCFwYXJlbnRSb3cpIGJyZWFrO1xuICAgICAgICBwYXJlbnRSb3dzLnB1c2gocGFyZW50Um93KTtcbiAgICAgICAgY3VycmVudFJvdyA9IHBhcmVudFJvdztcbiAgICAgIH1cbiAgICAgIHJldHVybiBwYXJlbnRSb3dzLnJldmVyc2UoKTtcbiAgICB9LFxuICAgIGdldEFsbENlbGxzOiBtZW1vKCgpID0+IFt0YWJsZS5nZXRBbGxMZWFmQ29sdW1ucygpXSwgbGVhZkNvbHVtbnMgPT4ge1xuICAgICAgcmV0dXJuIGxlYWZDb2x1bW5zLm1hcChjb2x1bW4gPT4ge1xuICAgICAgICByZXR1cm4gY3JlYXRlQ2VsbCh0YWJsZSwgcm93LCBjb2x1bW4sIGNvbHVtbi5pZCk7XG4gICAgICB9KTtcbiAgICB9LCB7XG4gICAgICBrZXk6IHByb2Nlc3MuZW52Lk5PREVfRU5WID09PSAnZGV2ZWxvcG1lbnQnICYmICdyb3cuZ2V0QWxsQ2VsbHMnLFxuICAgICAgZGVidWc6ICgpID0+IHtcbiAgICAgICAgdmFyIF90YWJsZSRvcHRpb25zJGRlYnVnQTtcbiAgICAgICAgcmV0dXJuIChfdGFibGUkb3B0aW9ucyRkZWJ1Z0EgPSB0YWJsZS5vcHRpb25zLmRlYnVnQWxsKSAhPSBudWxsID8gX3RhYmxlJG9wdGlvbnMkZGVidWdBIDogdGFibGUub3B0aW9ucy5kZWJ1Z1Jvd3M7XG4gICAgICB9XG4gICAgfSksXG4gICAgX2dldEFsbENlbGxzQnlDb2x1bW5JZDogbWVtbygoKSA9PiBbcm93LmdldEFsbENlbGxzKCldLCBhbGxDZWxscyA9PiB7XG4gICAgICByZXR1cm4gYWxsQ2VsbHMucmVkdWNlKChhY2MsIGNlbGwpID0+IHtcbiAgICAgICAgYWNjW2NlbGwuY29sdW1uLmlkXSA9IGNlbGw7XG4gICAgICAgIHJldHVybiBhY2M7XG4gICAgICB9LCB7fSk7XG4gICAgfSwge1xuICAgICAga2V5OiBwcm9jZXNzLmVudi5OT0RFX0VOViA9PT0gJ3Byb2R1Y3Rpb24nICYmICdyb3cuZ2V0QWxsQ2VsbHNCeUNvbHVtbklkJyxcbiAgICAgIGRlYnVnOiAoKSA9PiB7XG4gICAgICAgIHZhciBfdGFibGUkb3B0aW9ucyRkZWJ1Z0EyO1xuICAgICAgICByZXR1cm4gKF90YWJsZSRvcHRpb25zJGRlYnVnQTIgPSB0YWJsZS5vcHRpb25zLmRlYnVnQWxsKSAhPSBudWxsID8gX3RhYmxlJG9wdGlvbnMkZGVidWdBMiA6IHRhYmxlLm9wdGlvbnMuZGVidWdSb3dzO1xuICAgICAgfVxuICAgIH0pXG4gIH07XG4gIGZvciAobGV0IGkgPSAwOyBpIDwgdGFibGUuX2ZlYXR1cmVzLmxlbmd0aDsgaSsrKSB7XG4gICAgY29uc3QgZmVhdHVyZSA9IHRhYmxlLl9mZWF0dXJlc1tpXTtcbiAgICBmZWF0dXJlID09IG51bGwgfHwgZmVhdHVyZS5jcmVhdGVSb3cgPT0gbnVsbCB8fCBmZWF0dXJlLmNyZWF0ZVJvdyhyb3csIHRhYmxlKTtcbiAgfVxuICByZXR1cm4gcm93O1xufTtcblxuLy8gdHlwZSBQZXJzb24gPSB7XG4vLyAgIGZpcnN0TmFtZTogc3RyaW5nXG4vLyAgIGxhc3ROYW1lOiBzdHJpbmdcbi8vICAgYWdlOiBudW1iZXJcbi8vICAgdmlzaXRzOiBudW1iZXJcbi8vICAgc3RhdHVzOiBzdHJpbmdcbi8vICAgcHJvZ3Jlc3M6IG51bWJlclxuLy8gICBjcmVhdGVkQXQ6IERhdGVcbi8vICAgbmVzdGVkOiB7XG4vLyAgICAgZm9vOiBbXG4vLyAgICAgICB7XG4vLyAgICAgICAgIGJhcjogJ2Jhcidcbi8vICAgICAgIH1cbi8vICAgICBdXG4vLyAgICAgYmFyOiB7IHN1YkJhcjogYm9vbGVhbiB9W11cbi8vICAgICBiYXo6IHtcbi8vICAgICAgIGZvbzogJ2Zvbydcbi8vICAgICAgIGJhcjoge1xuLy8gICAgICAgICBiYXo6ICdiYXonXG4vLyAgICAgICB9XG4vLyAgICAgfVxuLy8gICB9XG4vLyB9XG5cbi8vIGNvbnN0IHRlc3Q6IERlZXBLZXlzPFBlcnNvbj4gPSAnbmVzdGVkLmZvby4wLmJhcidcbi8vIGNvbnN0IHRlc3QyOiBEZWVwS2V5czxQZXJzb24+ID0gJ25lc3RlZC5iYXInXG5cbi8vIGNvbnN0IGhlbHBlciA9IGNyZWF0ZUNvbHVtbkhlbHBlcjxQZXJzb24+KClcblxuLy8gaGVscGVyLmFjY2Vzc29yKCduZXN0ZWQuZm9vJywge1xuLy8gICBjZWxsOiBpbmZvID0+IGluZm8uZ2V0VmFsdWUoKSxcbi8vIH0pXG5cbi8vIGhlbHBlci5hY2Nlc3NvcignbmVzdGVkLmZvby4wLmJhcicsIHtcbi8vICAgY2VsbDogaW5mbyA9PiBpbmZvLmdldFZhbHVlKCksXG4vLyB9KVxuXG4vLyBoZWxwZXIuYWNjZXNzb3IoJ25lc3RlZC5iYXInLCB7XG4vLyAgIGNlbGw6IGluZm8gPT4gaW5mby5nZXRWYWx1ZSgpLFxuLy8gfSlcblxuZnVuY3Rpb24gY3JlYXRlQ29sdW1uSGVscGVyKCkge1xuICByZXR1cm4ge1xuICAgIGFjY2Vzc29yOiAoYWNjZXNzb3IsIGNvbHVtbikgPT4ge1xuICAgICAgcmV0dXJuIHR5cGVvZiBhY2Nlc3NvciA9PT0gJ2Z1bmN0aW9uJyA/IHtcbiAgICAgICAgLi4uY29sdW1uLFxuICAgICAgICBhY2Nlc3NvckZuOiBhY2Nlc3NvclxuICAgICAgfSA6IHtcbiAgICAgICAgLi4uY29sdW1uLFxuICAgICAgICBhY2Nlc3NvcktleTogYWNjZXNzb3JcbiAgICAgIH07XG4gICAgfSxcbiAgICBkaXNwbGF5OiBjb2x1bW4gPT4gY29sdW1uLFxuICAgIGdyb3VwOiBjb2x1bW4gPT4gY29sdW1uXG4gIH07XG59XG5cbmZ1bmN0aW9uIGdldENvcmVSb3dNb2RlbCgpIHtcbiAgcmV0dXJuIHRhYmxlID0+IG1lbW8oKCkgPT4gW3RhYmxlLm9wdGlvbnMuZGF0YV0sIGRhdGEgPT4ge1xuICAgIGNvbnN0IHJvd01vZGVsID0ge1xuICAgICAgcm93czogW10sXG4gICAgICBmbGF0Um93czogW10sXG4gICAgICByb3dzQnlJZDoge31cbiAgICB9O1xuICAgIGNvbnN0IGFjY2Vzc1Jvd3MgPSBmdW5jdGlvbiAob3JpZ2luYWxSb3dzLCBkZXB0aCwgcGFyZW50Um93KSB7XG4gICAgICBpZiAoZGVwdGggPT09IHZvaWQgMCkge1xuICAgICAgICBkZXB0aCA9IDA7XG4gICAgICB9XG4gICAgICBjb25zdCByb3dzID0gW107XG4gICAgICBmb3IgKGxldCBpID0gMDsgaSA8IG9yaWdpbmFsUm93cy5sZW5ndGg7IGkrKykge1xuICAgICAgICAvLyBUaGlzIGNvdWxkIGJlIGFuIGV4cGVuc2l2ZSBjaGVjayBhdCBzY2FsZSwgc28gd2Ugc2hvdWxkIG1vdmUgaXQgc29tZXdoZXJlIGVsc2UsIGJ1dCB3aGVyZT9cbiAgICAgICAgLy8gaWYgKCFpZCkge1xuICAgICAgICAvLyAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgICAgIC8vICAgICB0aHJvdyBuZXcgRXJyb3IoYGdldFJvd0lkIGV4cGVjdGVkIGFuIElELCBidXQgZ290ICR7aWR9YClcbiAgICAgICAgLy8gICB9XG4gICAgICAgIC8vIH1cblxuICAgICAgICAvLyBNYWtlIHRoZSByb3dcbiAgICAgICAgY29uc3Qgcm93ID0gY3JlYXRlUm93KHRhYmxlLCB0YWJsZS5fZ2V0Um93SWQob3JpZ2luYWxSb3dzW2ldLCBpLCBwYXJlbnRSb3cpLCBvcmlnaW5hbFJvd3NbaV0sIGksIGRlcHRoLCB1bmRlZmluZWQsIHBhcmVudFJvdyA9PSBudWxsID8gdm9pZCAwIDogcGFyZW50Um93LmlkKTtcblxuICAgICAgICAvLyBLZWVwIHRyYWNrIG9mIGV2ZXJ5IHJvdyBpbiBhIGZsYXQgYXJyYXlcbiAgICAgICAgcm93TW9kZWwuZmxhdFJvd3MucHVzaChyb3cpO1xuICAgICAgICAvLyBBbHNvIGtlZXAgdHJhY2sgb2YgZXZlcnkgcm93IGJ5IGl0cyBJRFxuICAgICAgICByb3dNb2RlbC5yb3dzQnlJZFtyb3cuaWRdID0gcm93O1xuICAgICAgICAvLyBQdXNoIHRhYmxlIHJvdyBpbnRvIHBhcmVudFxuICAgICAgICByb3dzLnB1c2gocm93KTtcblxuICAgICAgICAvLyBHZXQgdGhlIG9yaWdpbmFsIHN1YnJvd3NcbiAgICAgICAgaWYgKHRhYmxlLm9wdGlvbnMuZ2V0U3ViUm93cykge1xuICAgICAgICAgIHZhciBfcm93JG9yaWdpbmFsU3ViUm93cztcbiAgICAgICAgICByb3cub3JpZ2luYWxTdWJSb3dzID0gdGFibGUub3B0aW9ucy5nZXRTdWJSb3dzKG9yaWdpbmFsUm93c1tpXSwgaSk7XG5cbiAgICAgICAgICAvLyBUaGVuIHJlY3Vyc2l2ZWx5IGFjY2VzcyB0aGVtXG4gICAgICAgICAgaWYgKChfcm93JG9yaWdpbmFsU3ViUm93cyA9IHJvdy5vcmlnaW5hbFN1YlJvd3MpICE9IG51bGwgJiYgX3JvdyRvcmlnaW5hbFN1YlJvd3MubGVuZ3RoKSB7XG4gICAgICAgICAgICByb3cuc3ViUm93cyA9IGFjY2Vzc1Jvd3Mocm93Lm9yaWdpbmFsU3ViUm93cywgZGVwdGggKyAxLCByb3cpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIHJvd3M7XG4gICAgfTtcbiAgICByb3dNb2RlbC5yb3dzID0gYWNjZXNzUm93cyhkYXRhKTtcbiAgICByZXR1cm4gcm93TW9kZWw7XG4gIH0sIHtcbiAgICBrZXk6IHByb2Nlc3MuZW52Lk5PREVfRU5WID09PSAnZGV2ZWxvcG1lbnQnICYmICdnZXRSb3dNb2RlbCcsXG4gICAgZGVidWc6ICgpID0+IHtcbiAgICAgIHZhciBfdGFibGUkb3B0aW9ucyRkZWJ1Z0E7XG4gICAgICByZXR1cm4gKF90YWJsZSRvcHRpb25zJGRlYnVnQSA9IHRhYmxlLm9wdGlvbnMuZGVidWdBbGwpICE9IG51bGwgPyBfdGFibGUkb3B0aW9ucyRkZWJ1Z0EgOiB0YWJsZS5vcHRpb25zLmRlYnVnVGFibGU7XG4gICAgfSxcbiAgICBvbkNoYW5nZTogKCkgPT4ge1xuICAgICAgdGFibGUuX2F1dG9SZXNldFBhZ2VJbmRleCgpO1xuICAgIH1cbiAgfSk7XG59XG5cbmZ1bmN0aW9uIGZpbHRlclJvd3Mocm93cywgZmlsdGVyUm93SW1wbCwgdGFibGUpIHtcbiAgaWYgKHRhYmxlLm9wdGlvbnMuZmlsdGVyRnJvbUxlYWZSb3dzKSB7XG4gICAgcmV0dXJuIGZpbHRlclJvd01vZGVsRnJvbUxlYWZzKHJvd3MsIGZpbHRlclJvd0ltcGwsIHRhYmxlKTtcbiAgfVxuICByZXR1cm4gZmlsdGVyUm93TW9kZWxGcm9tUm9vdChyb3dzLCBmaWx0ZXJSb3dJbXBsLCB0YWJsZSk7XG59XG5mdW5jdGlvbiBmaWx0ZXJSb3dNb2RlbEZyb21MZWFmcyhyb3dzVG9GaWx0ZXIsIGZpbHRlclJvdywgdGFibGUpIHtcbiAgdmFyIF90YWJsZSRvcHRpb25zJG1heExlYTtcbiAgY29uc3QgbmV3RmlsdGVyZWRGbGF0Um93cyA9IFtdO1xuICBjb25zdCBuZXdGaWx0ZXJlZFJvd3NCeUlkID0ge307XG4gIGNvbnN0IG1heERlcHRoID0gKF90YWJsZSRvcHRpb25zJG1heExlYSA9IHRhYmxlLm9wdGlvbnMubWF4TGVhZlJvd0ZpbHRlckRlcHRoKSAhPSBudWxsID8gX3RhYmxlJG9wdGlvbnMkbWF4TGVhIDogMTAwO1xuICBjb25zdCByZWN1cnNlRmlsdGVyUm93cyA9IGZ1bmN0aW9uIChyb3dzVG9GaWx0ZXIsIGRlcHRoKSB7XG4gICAgaWYgKGRlcHRoID09PSB2b2lkIDApIHtcbiAgICAgIGRlcHRoID0gMDtcbiAgICB9XG4gICAgY29uc3Qgcm93cyA9IFtdO1xuXG4gICAgLy8gRmlsdGVyIGZyb20gY2hpbGRyZW4gdXAgZmlyc3RcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IHJvd3NUb0ZpbHRlci5sZW5ndGg7IGkrKykge1xuICAgICAgdmFyIF9yb3ckc3ViUm93cztcbiAgICAgIGxldCByb3cgPSByb3dzVG9GaWx0ZXJbaV07XG4gICAgICBjb25zdCBuZXdSb3cgPSBjcmVhdGVSb3codGFibGUsIHJvdy5pZCwgcm93Lm9yaWdpbmFsLCByb3cuaW5kZXgsIHJvdy5kZXB0aCwgdW5kZWZpbmVkLCByb3cucGFyZW50SWQpO1xuICAgICAgbmV3Um93LmNvbHVtbkZpbHRlcnMgPSByb3cuY29sdW1uRmlsdGVycztcbiAgICAgIGlmICgoX3JvdyRzdWJSb3dzID0gcm93LnN1YlJvd3MpICE9IG51bGwgJiYgX3JvdyRzdWJSb3dzLmxlbmd0aCAmJiBkZXB0aCA8IG1heERlcHRoKSB7XG4gICAgICAgIG5ld1Jvdy5zdWJSb3dzID0gcmVjdXJzZUZpbHRlclJvd3Mocm93LnN1YlJvd3MsIGRlcHRoICsgMSk7XG4gICAgICAgIHJvdyA9IG5ld1JvdztcbiAgICAgICAgaWYgKGZpbHRlclJvdyhyb3cpICYmICFuZXdSb3cuc3ViUm93cy5sZW5ndGgpIHtcbiAgICAgICAgICByb3dzLnB1c2gocm93KTtcbiAgICAgICAgICBuZXdGaWx0ZXJlZFJvd3NCeUlkW3Jvdy5pZF0gPSByb3c7XG4gICAgICAgICAgbmV3RmlsdGVyZWRGbGF0Um93cy5wdXNoKHJvdyk7XG4gICAgICAgICAgY29udGludWU7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGZpbHRlclJvdyhyb3cpIHx8IG5ld1Jvdy5zdWJSb3dzLmxlbmd0aCkge1xuICAgICAgICAgIHJvd3MucHVzaChyb3cpO1xuICAgICAgICAgIG5ld0ZpbHRlcmVkUm93c0J5SWRbcm93LmlkXSA9IHJvdztcbiAgICAgICAgICBuZXdGaWx0ZXJlZEZsYXRSb3dzLnB1c2gocm93KTtcbiAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcm93ID0gbmV3Um93O1xuICAgICAgICBpZiAoZmlsdGVyUm93KHJvdykpIHtcbiAgICAgICAgICByb3dzLnB1c2gocm93KTtcbiAgICAgICAgICBuZXdGaWx0ZXJlZFJvd3NCeUlkW3Jvdy5pZF0gPSByb3c7XG4gICAgICAgICAgbmV3RmlsdGVyZWRGbGF0Um93cy5wdXNoKHJvdyk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHJvd3M7XG4gIH07XG4gIHJldHVybiB7XG4gICAgcm93czogcmVjdXJzZUZpbHRlclJvd3Mocm93c1RvRmlsdGVyKSxcbiAgICBmbGF0Um93czogbmV3RmlsdGVyZWRGbGF0Um93cyxcbiAgICByb3dzQnlJZDogbmV3RmlsdGVyZWRSb3dzQnlJZFxuICB9O1xufVxuZnVuY3Rpb24gZmlsdGVyUm93TW9kZWxGcm9tUm9vdChyb3dzVG9GaWx0ZXIsIGZpbHRlclJvdywgdGFibGUpIHtcbiAgdmFyIF90YWJsZSRvcHRpb25zJG1heExlYTI7XG4gIGNvbnN0IG5ld0ZpbHRlcmVkRmxhdFJvd3MgPSBbXTtcbiAgY29uc3QgbmV3RmlsdGVyZWRSb3dzQnlJZCA9IHt9O1xuICBjb25zdCBtYXhEZXB0aCA9IChfdGFibGUkb3B0aW9ucyRtYXhMZWEyID0gdGFibGUub3B0aW9ucy5tYXhMZWFmUm93RmlsdGVyRGVwdGgpICE9IG51bGwgPyBfdGFibGUkb3B0aW9ucyRtYXhMZWEyIDogMTAwO1xuXG4gIC8vIEZpbHRlcnMgdG9wIGxldmVsIGFuZCBuZXN0ZWQgcm93c1xuICBjb25zdCByZWN1cnNlRmlsdGVyUm93cyA9IGZ1bmN0aW9uIChyb3dzVG9GaWx0ZXIsIGRlcHRoKSB7XG4gICAgaWYgKGRlcHRoID09PSB2b2lkIDApIHtcbiAgICAgIGRlcHRoID0gMDtcbiAgICB9XG4gICAgLy8gRmlsdGVyIGZyb20gcGFyZW50cyBkb3dud2FyZCBmaXJzdFxuXG4gICAgY29uc3Qgcm93cyA9IFtdO1xuXG4gICAgLy8gQXBwbHkgdGhlIGZpbHRlciB0byBhbnkgc3ViUm93c1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgcm93c1RvRmlsdGVyLmxlbmd0aDsgaSsrKSB7XG4gICAgICBsZXQgcm93ID0gcm93c1RvRmlsdGVyW2ldO1xuICAgICAgY29uc3QgcGFzcyA9IGZpbHRlclJvdyhyb3cpO1xuICAgICAgaWYgKHBhc3MpIHtcbiAgICAgICAgdmFyIF9yb3ckc3ViUm93czI7XG4gICAgICAgIGlmICgoX3JvdyRzdWJSb3dzMiA9IHJvdy5zdWJSb3dzKSAhPSBudWxsICYmIF9yb3ckc3ViUm93czIubGVuZ3RoICYmIGRlcHRoIDwgbWF4RGVwdGgpIHtcbiAgICAgICAgICBjb25zdCBuZXdSb3cgPSBjcmVhdGVSb3codGFibGUsIHJvdy5pZCwgcm93Lm9yaWdpbmFsLCByb3cuaW5kZXgsIHJvdy5kZXB0aCwgdW5kZWZpbmVkLCByb3cucGFyZW50SWQpO1xuICAgICAgICAgIG5ld1Jvdy5zdWJSb3dzID0gcmVjdXJzZUZpbHRlclJvd3Mocm93LnN1YlJvd3MsIGRlcHRoICsgMSk7XG4gICAgICAgICAgcm93ID0gbmV3Um93O1xuICAgICAgICB9XG4gICAgICAgIHJvd3MucHVzaChyb3cpO1xuICAgICAgICBuZXdGaWx0ZXJlZEZsYXRSb3dzLnB1c2gocm93KTtcbiAgICAgICAgbmV3RmlsdGVyZWRSb3dzQnlJZFtyb3cuaWRdID0gcm93O1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gcm93cztcbiAgfTtcbiAgcmV0dXJuIHtcbiAgICByb3dzOiByZWN1cnNlRmlsdGVyUm93cyhyb3dzVG9GaWx0ZXIpLFxuICAgIGZsYXRSb3dzOiBuZXdGaWx0ZXJlZEZsYXRSb3dzLFxuICAgIHJvd3NCeUlkOiBuZXdGaWx0ZXJlZFJvd3NCeUlkXG4gIH07XG59XG5cbmZ1bmN0aW9uIGdldEZpbHRlcmVkUm93TW9kZWwoKSB7XG4gIHJldHVybiB0YWJsZSA9PiBtZW1vKCgpID0+IFt0YWJsZS5nZXRQcmVGaWx0ZXJlZFJvd01vZGVsKCksIHRhYmxlLmdldFN0YXRlKCkuY29sdW1uRmlsdGVycywgdGFibGUuZ2V0U3RhdGUoKS5nbG9iYWxGaWx0ZXJdLCAocm93TW9kZWwsIGNvbHVtbkZpbHRlcnMsIGdsb2JhbEZpbHRlcikgPT4ge1xuICAgIGlmICghcm93TW9kZWwucm93cy5sZW5ndGggfHwgIShjb2x1bW5GaWx0ZXJzICE9IG51bGwgJiYgY29sdW1uRmlsdGVycy5sZW5ndGgpICYmICFnbG9iYWxGaWx0ZXIpIHtcbiAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgcm93TW9kZWwuZmxhdFJvd3MubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgcm93TW9kZWwuZmxhdFJvd3NbaV0uY29sdW1uRmlsdGVycyA9IHt9O1xuICAgICAgICByb3dNb2RlbC5mbGF0Um93c1tpXS5jb2x1bW5GaWx0ZXJzTWV0YSA9IHt9O1xuICAgICAgfVxuICAgICAgcmV0dXJuIHJvd01vZGVsO1xuICAgIH1cbiAgICBjb25zdCByZXNvbHZlZENvbHVtbkZpbHRlcnMgPSBbXTtcbiAgICBjb25zdCByZXNvbHZlZEdsb2JhbEZpbHRlcnMgPSBbXTtcbiAgICAoY29sdW1uRmlsdGVycyAhPSBudWxsID8gY29sdW1uRmlsdGVycyA6IFtdKS5mb3JFYWNoKGQgPT4ge1xuICAgICAgdmFyIF9maWx0ZXJGbiRyZXNvbHZlRmlsdDtcbiAgICAgIGNvbnN0IGNvbHVtbiA9IHRhYmxlLmdldENvbHVtbihkLmlkKTtcbiAgICAgIGlmICghY29sdW1uKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIGNvbnN0IGZpbHRlckZuID0gY29sdW1uLmdldEZpbHRlckZuKCk7XG4gICAgICBpZiAoIWZpbHRlckZuKSB7XG4gICAgICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgICAgICAgY29uc29sZS53YXJuKGBDb3VsZCBub3QgZmluZCBhIHZhbGlkICdjb2x1bW4uZmlsdGVyRm4nIGZvciBjb2x1bW4gd2l0aCB0aGUgSUQ6ICR7Y29sdW1uLmlkfS5gKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICByZXNvbHZlZENvbHVtbkZpbHRlcnMucHVzaCh7XG4gICAgICAgIGlkOiBkLmlkLFxuICAgICAgICBmaWx0ZXJGbixcbiAgICAgICAgcmVzb2x2ZWRWYWx1ZTogKF9maWx0ZXJGbiRyZXNvbHZlRmlsdCA9IGZpbHRlckZuLnJlc29sdmVGaWx0ZXJWYWx1ZSA9PSBudWxsID8gdm9pZCAwIDogZmlsdGVyRm4ucmVzb2x2ZUZpbHRlclZhbHVlKGQudmFsdWUpKSAhPSBudWxsID8gX2ZpbHRlckZuJHJlc29sdmVGaWx0IDogZC52YWx1ZVxuICAgICAgfSk7XG4gICAgfSk7XG4gICAgY29uc3QgZmlsdGVyYWJsZUlkcyA9IGNvbHVtbkZpbHRlcnMubWFwKGQgPT4gZC5pZCk7XG4gICAgY29uc3QgZ2xvYmFsRmlsdGVyRm4gPSB0YWJsZS5nZXRHbG9iYWxGaWx0ZXJGbigpO1xuICAgIGNvbnN0IGdsb2JhbGx5RmlsdGVyYWJsZUNvbHVtbnMgPSB0YWJsZS5nZXRBbGxMZWFmQ29sdW1ucygpLmZpbHRlcihjb2x1bW4gPT4gY29sdW1uLmdldENhbkdsb2JhbEZpbHRlcigpKTtcbiAgICBpZiAoZ2xvYmFsRmlsdGVyICYmIGdsb2JhbEZpbHRlckZuICYmIGdsb2JhbGx5RmlsdGVyYWJsZUNvbHVtbnMubGVuZ3RoKSB7XG4gICAgICBmaWx0ZXJhYmxlSWRzLnB1c2goJ19fZ2xvYmFsX18nKTtcbiAgICAgIGdsb2JhbGx5RmlsdGVyYWJsZUNvbHVtbnMuZm9yRWFjaChjb2x1bW4gPT4ge1xuICAgICAgICB2YXIgX2dsb2JhbEZpbHRlckZuJHJlc29sO1xuICAgICAgICByZXNvbHZlZEdsb2JhbEZpbHRlcnMucHVzaCh7XG4gICAgICAgICAgaWQ6IGNvbHVtbi5pZCxcbiAgICAgICAgICBmaWx0ZXJGbjogZ2xvYmFsRmlsdGVyRm4sXG4gICAgICAgICAgcmVzb2x2ZWRWYWx1ZTogKF9nbG9iYWxGaWx0ZXJGbiRyZXNvbCA9IGdsb2JhbEZpbHRlckZuLnJlc29sdmVGaWx0ZXJWYWx1ZSA9PSBudWxsID8gdm9pZCAwIDogZ2xvYmFsRmlsdGVyRm4ucmVzb2x2ZUZpbHRlclZhbHVlKGdsb2JhbEZpbHRlcikpICE9IG51bGwgPyBfZ2xvYmFsRmlsdGVyRm4kcmVzb2wgOiBnbG9iYWxGaWx0ZXJcbiAgICAgICAgfSk7XG4gICAgICB9KTtcbiAgICB9XG4gICAgbGV0IGN1cnJlbnRDb2x1bW5GaWx0ZXI7XG4gICAgbGV0IGN1cnJlbnRHbG9iYWxGaWx0ZXI7XG5cbiAgICAvLyBGbGFnIHRoZSBwcmVmaWx0ZXJlZCByb3cgbW9kZWwgd2l0aCBlYWNoIGZpbHRlciBzdGF0ZVxuICAgIGZvciAobGV0IGogPSAwOyBqIDwgcm93TW9kZWwuZmxhdFJvd3MubGVuZ3RoOyBqKyspIHtcbiAgICAgIGNvbnN0IHJvdyA9IHJvd01vZGVsLmZsYXRSb3dzW2pdO1xuICAgICAgcm93LmNvbHVtbkZpbHRlcnMgPSB7fTtcbiAgICAgIGlmIChyZXNvbHZlZENvbHVtbkZpbHRlcnMubGVuZ3RoKSB7XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgcmVzb2x2ZWRDb2x1bW5GaWx0ZXJzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgY3VycmVudENvbHVtbkZpbHRlciA9IHJlc29sdmVkQ29sdW1uRmlsdGVyc1tpXTtcbiAgICAgICAgICBjb25zdCBpZCA9IGN1cnJlbnRDb2x1bW5GaWx0ZXIuaWQ7XG5cbiAgICAgICAgICAvLyBUYWcgdGhlIHJvdyB3aXRoIHRoZSBjb2x1bW4gZmlsdGVyIHN0YXRlXG4gICAgICAgICAgcm93LmNvbHVtbkZpbHRlcnNbaWRdID0gY3VycmVudENvbHVtbkZpbHRlci5maWx0ZXJGbihyb3csIGlkLCBjdXJyZW50Q29sdW1uRmlsdGVyLnJlc29sdmVkVmFsdWUsIGZpbHRlck1ldGEgPT4ge1xuICAgICAgICAgICAgcm93LmNvbHVtbkZpbHRlcnNNZXRhW2lkXSA9IGZpbHRlck1ldGE7XG4gICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGlmIChyZXNvbHZlZEdsb2JhbEZpbHRlcnMubGVuZ3RoKSB7XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgcmVzb2x2ZWRHbG9iYWxGaWx0ZXJzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgY3VycmVudEdsb2JhbEZpbHRlciA9IHJlc29sdmVkR2xvYmFsRmlsdGVyc1tpXTtcbiAgICAgICAgICBjb25zdCBpZCA9IGN1cnJlbnRHbG9iYWxGaWx0ZXIuaWQ7XG4gICAgICAgICAgLy8gVGFnIHRoZSByb3cgd2l0aCB0aGUgZmlyc3QgdHJ1dGh5IGdsb2JhbCBmaWx0ZXIgc3RhdGVcbiAgICAgICAgICBpZiAoY3VycmVudEdsb2JhbEZpbHRlci5maWx0ZXJGbihyb3csIGlkLCBjdXJyZW50R2xvYmFsRmlsdGVyLnJlc29sdmVkVmFsdWUsIGZpbHRlck1ldGEgPT4ge1xuICAgICAgICAgICAgcm93LmNvbHVtbkZpbHRlcnNNZXRhW2lkXSA9IGZpbHRlck1ldGE7XG4gICAgICAgICAgfSkpIHtcbiAgICAgICAgICAgIHJvdy5jb2x1bW5GaWx0ZXJzLl9fZ2xvYmFsX18gPSB0cnVlO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmIChyb3cuY29sdW1uRmlsdGVycy5fX2dsb2JhbF9fICE9PSB0cnVlKSB7XG4gICAgICAgICAgcm93LmNvbHVtbkZpbHRlcnMuX19nbG9iYWxfXyA9IGZhbHNlO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAgIGNvbnN0IGZpbHRlclJvd3NJbXBsID0gcm93ID0+IHtcbiAgICAgIC8vIEhvcml6b250YWxseSBmaWx0ZXIgcm93cyB0aHJvdWdoIGVhY2ggY29sdW1uXG4gICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGZpbHRlcmFibGVJZHMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgaWYgKHJvdy5jb2x1bW5GaWx0ZXJzW2ZpbHRlcmFibGVJZHNbaV1dID09PSBmYWxzZSkge1xuICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfTtcblxuICAgIC8vIEZpbHRlciBmaW5hbCByb3dzIHVzaW5nIGFsbCBvZiB0aGUgYWN0aXZlIGZpbHRlcnNcbiAgICByZXR1cm4gZmlsdGVyUm93cyhyb3dNb2RlbC5yb3dzLCBmaWx0ZXJSb3dzSW1wbCwgdGFibGUpO1xuICB9LCB7XG4gICAga2V5OiBwcm9jZXNzLmVudi5OT0RFX0VOViA9PT0gJ2RldmVsb3BtZW50JyAmJiAnZ2V0RmlsdGVyZWRSb3dNb2RlbCcsXG4gICAgZGVidWc6ICgpID0+IHtcbiAgICAgIHZhciBfdGFibGUkb3B0aW9ucyRkZWJ1Z0E7XG4gICAgICByZXR1cm4gKF90YWJsZSRvcHRpb25zJGRlYnVnQSA9IHRhYmxlLm9wdGlvbnMuZGVidWdBbGwpICE9IG51bGwgPyBfdGFibGUkb3B0aW9ucyRkZWJ1Z0EgOiB0YWJsZS5vcHRpb25zLmRlYnVnVGFibGU7XG4gICAgfSxcbiAgICBvbkNoYW5nZTogKCkgPT4ge1xuICAgICAgdGFibGUuX2F1dG9SZXNldFBhZ2VJbmRleCgpO1xuICAgIH1cbiAgfSk7XG59XG5cbmZ1bmN0aW9uIGdldEZhY2V0ZWRSb3dNb2RlbCgpIHtcbiAgcmV0dXJuICh0YWJsZSwgY29sdW1uSWQpID0+IG1lbW8oKCkgPT4gW3RhYmxlLmdldFByZUZpbHRlcmVkUm93TW9kZWwoKSwgdGFibGUuZ2V0U3RhdGUoKS5jb2x1bW5GaWx0ZXJzLCB0YWJsZS5nZXRTdGF0ZSgpLmdsb2JhbEZpbHRlciwgdGFibGUuZ2V0RmlsdGVyZWRSb3dNb2RlbCgpXSwgKHByZVJvd01vZGVsLCBjb2x1bW5GaWx0ZXJzLCBnbG9iYWxGaWx0ZXIpID0+IHtcbiAgICBpZiAoIXByZVJvd01vZGVsLnJvd3MubGVuZ3RoIHx8ICEoY29sdW1uRmlsdGVycyAhPSBudWxsICYmIGNvbHVtbkZpbHRlcnMubGVuZ3RoKSAmJiAhZ2xvYmFsRmlsdGVyKSB7XG4gICAgICByZXR1cm4gcHJlUm93TW9kZWw7XG4gICAgfVxuICAgIGNvbnN0IGZpbHRlcmFibGVJZHMgPSBbLi4uY29sdW1uRmlsdGVycy5tYXAoZCA9PiBkLmlkKS5maWx0ZXIoZCA9PiBkICE9PSBjb2x1bW5JZCksIGdsb2JhbEZpbHRlciA/ICdfX2dsb2JhbF9fJyA6IHVuZGVmaW5lZF0uZmlsdGVyKEJvb2xlYW4pO1xuICAgIGNvbnN0IGZpbHRlclJvd3NJbXBsID0gcm93ID0+IHtcbiAgICAgIC8vIEhvcml6b250YWxseSBmaWx0ZXIgcm93cyB0aHJvdWdoIGVhY2ggY29sdW1uXG4gICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGZpbHRlcmFibGVJZHMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgaWYgKHJvdy5jb2x1bW5GaWx0ZXJzW2ZpbHRlcmFibGVJZHNbaV1dID09PSBmYWxzZSkge1xuICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfTtcbiAgICByZXR1cm4gZmlsdGVyUm93cyhwcmVSb3dNb2RlbC5yb3dzLCBmaWx0ZXJSb3dzSW1wbCwgdGFibGUpO1xuICB9LCB7XG4gICAga2V5OiBwcm9jZXNzLmVudi5OT0RFX0VOViA9PT0gJ2RldmVsb3BtZW50JyAmJiAnZ2V0RmFjZXRlZFJvd01vZGVsXycgKyBjb2x1bW5JZCxcbiAgICBkZWJ1ZzogKCkgPT4ge1xuICAgICAgdmFyIF90YWJsZSRvcHRpb25zJGRlYnVnQTtcbiAgICAgIHJldHVybiAoX3RhYmxlJG9wdGlvbnMkZGVidWdBID0gdGFibGUub3B0aW9ucy5kZWJ1Z0FsbCkgIT0gbnVsbCA/IF90YWJsZSRvcHRpb25zJGRlYnVnQSA6IHRhYmxlLm9wdGlvbnMuZGVidWdUYWJsZTtcbiAgICB9LFxuICAgIG9uQ2hhbmdlOiAoKSA9PiB7fVxuICB9KTtcbn1cblxuZnVuY3Rpb24gZ2V0RmFjZXRlZFVuaXF1ZVZhbHVlcygpIHtcbiAgcmV0dXJuICh0YWJsZSwgY29sdW1uSWQpID0+IG1lbW8oKCkgPT4ge1xuICAgIHZhciBfdGFibGUkZ2V0Q29sdW1uO1xuICAgIHJldHVybiBbKF90YWJsZSRnZXRDb2x1bW4gPSB0YWJsZS5nZXRDb2x1bW4oY29sdW1uSWQpKSA9PSBudWxsID8gdm9pZCAwIDogX3RhYmxlJGdldENvbHVtbi5nZXRGYWNldGVkUm93TW9kZWwoKV07XG4gIH0sIGZhY2V0ZWRSb3dNb2RlbCA9PiB7XG4gICAgaWYgKCFmYWNldGVkUm93TW9kZWwpIHJldHVybiBuZXcgTWFwKCk7XG4gICAgbGV0IGZhY2V0ZWRVbmlxdWVWYWx1ZXMgPSBuZXcgTWFwKCk7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBmYWNldGVkUm93TW9kZWwuZmxhdFJvd3MubGVuZ3RoOyBpKyspIHtcbiAgICAgIGNvbnN0IHZhbHVlcyA9IGZhY2V0ZWRSb3dNb2RlbC5mbGF0Um93c1tpXS5nZXRVbmlxdWVWYWx1ZXMoY29sdW1uSWQpO1xuICAgICAgZm9yIChsZXQgaiA9IDA7IGogPCB2YWx1ZXMubGVuZ3RoOyBqKyspIHtcbiAgICAgICAgY29uc3QgdmFsdWUgPSB2YWx1ZXNbal07XG4gICAgICAgIGlmIChmYWNldGVkVW5pcXVlVmFsdWVzLmhhcyh2YWx1ZSkpIHtcbiAgICAgICAgICB2YXIgX2ZhY2V0ZWRVbmlxdWVWYWx1ZXMkO1xuICAgICAgICAgIGZhY2V0ZWRVbmlxdWVWYWx1ZXMuc2V0KHZhbHVlLCAoKF9mYWNldGVkVW5pcXVlVmFsdWVzJCA9IGZhY2V0ZWRVbmlxdWVWYWx1ZXMuZ2V0KHZhbHVlKSkgIT0gbnVsbCA/IF9mYWNldGVkVW5pcXVlVmFsdWVzJCA6IDApICsgMSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgZmFjZXRlZFVuaXF1ZVZhbHVlcy5zZXQodmFsdWUsIDEpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBmYWNldGVkVW5pcXVlVmFsdWVzO1xuICB9LCB7XG4gICAga2V5OiBwcm9jZXNzLmVudi5OT0RFX0VOViA9PT0gJ2RldmVsb3BtZW50JyAmJiAnZ2V0RmFjZXRlZFVuaXF1ZVZhbHVlc18nICsgY29sdW1uSWQsXG4gICAgZGVidWc6ICgpID0+IHtcbiAgICAgIHZhciBfdGFibGUkb3B0aW9ucyRkZWJ1Z0E7XG4gICAgICByZXR1cm4gKF90YWJsZSRvcHRpb25zJGRlYnVnQSA9IHRhYmxlLm9wdGlvbnMuZGVidWdBbGwpICE9IG51bGwgPyBfdGFibGUkb3B0aW9ucyRkZWJ1Z0EgOiB0YWJsZS5vcHRpb25zLmRlYnVnVGFibGU7XG4gICAgfSxcbiAgICBvbkNoYW5nZTogKCkgPT4ge31cbiAgfSk7XG59XG5cbmZ1bmN0aW9uIGdldEZhY2V0ZWRNaW5NYXhWYWx1ZXMoKSB7XG4gIHJldHVybiAodGFibGUsIGNvbHVtbklkKSA9PiBtZW1vKCgpID0+IHtcbiAgICB2YXIgX3RhYmxlJGdldENvbHVtbjtcbiAgICByZXR1cm4gWyhfdGFibGUkZ2V0Q29sdW1uID0gdGFibGUuZ2V0Q29sdW1uKGNvbHVtbklkKSkgPT0gbnVsbCA/IHZvaWQgMCA6IF90YWJsZSRnZXRDb2x1bW4uZ2V0RmFjZXRlZFJvd01vZGVsKCldO1xuICB9LCBmYWNldGVkUm93TW9kZWwgPT4ge1xuICAgIHZhciBfZmFjZXRlZFJvd01vZGVsJGZsYXQ7XG4gICAgaWYgKCFmYWNldGVkUm93TW9kZWwpIHJldHVybiB1bmRlZmluZWQ7XG4gICAgY29uc3QgZmlyc3RWYWx1ZSA9IChfZmFjZXRlZFJvd01vZGVsJGZsYXQgPSBmYWNldGVkUm93TW9kZWwuZmxhdFJvd3NbMF0pID09IG51bGwgPyB2b2lkIDAgOiBfZmFjZXRlZFJvd01vZGVsJGZsYXQuZ2V0VW5pcXVlVmFsdWVzKGNvbHVtbklkKTtcbiAgICBpZiAodHlwZW9mIGZpcnN0VmFsdWUgPT09ICd1bmRlZmluZWQnKSB7XG4gICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgIH1cbiAgICBsZXQgZmFjZXRlZE1pbk1heFZhbHVlcyA9IFtmaXJzdFZhbHVlLCBmaXJzdFZhbHVlXTtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGZhY2V0ZWRSb3dNb2RlbC5mbGF0Um93cy5sZW5ndGg7IGkrKykge1xuICAgICAgY29uc3QgdmFsdWVzID0gZmFjZXRlZFJvd01vZGVsLmZsYXRSb3dzW2ldLmdldFVuaXF1ZVZhbHVlcyhjb2x1bW5JZCk7XG4gICAgICBmb3IgKGxldCBqID0gMDsgaiA8IHZhbHVlcy5sZW5ndGg7IGorKykge1xuICAgICAgICBjb25zdCB2YWx1ZSA9IHZhbHVlc1tqXTtcbiAgICAgICAgaWYgKHZhbHVlIDwgZmFjZXRlZE1pbk1heFZhbHVlc1swXSkge1xuICAgICAgICAgIGZhY2V0ZWRNaW5NYXhWYWx1ZXNbMF0gPSB2YWx1ZTtcbiAgICAgICAgfSBlbHNlIGlmICh2YWx1ZSA+IGZhY2V0ZWRNaW5NYXhWYWx1ZXNbMV0pIHtcbiAgICAgICAgICBmYWNldGVkTWluTWF4VmFsdWVzWzFdID0gdmFsdWU7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGZhY2V0ZWRNaW5NYXhWYWx1ZXM7XG4gIH0sIHtcbiAgICBrZXk6IHByb2Nlc3MuZW52Lk5PREVfRU5WID09PSAnZGV2ZWxvcG1lbnQnICYmICdnZXRGYWNldGVkTWluTWF4VmFsdWVzXycgKyBjb2x1bW5JZCxcbiAgICBkZWJ1ZzogKCkgPT4ge1xuICAgICAgdmFyIF90YWJsZSRvcHRpb25zJGRlYnVnQTtcbiAgICAgIHJldHVybiAoX3RhYmxlJG9wdGlvbnMkZGVidWdBID0gdGFibGUub3B0aW9ucy5kZWJ1Z0FsbCkgIT0gbnVsbCA/IF90YWJsZSRvcHRpb25zJGRlYnVnQSA6IHRhYmxlLm9wdGlvbnMuZGVidWdUYWJsZTtcbiAgICB9LFxuICAgIG9uQ2hhbmdlOiAoKSA9PiB7fVxuICB9KTtcbn1cblxuZnVuY3Rpb24gZ2V0U29ydGVkUm93TW9kZWwoKSB7XG4gIHJldHVybiB0YWJsZSA9PiBtZW1vKCgpID0+IFt0YWJsZS5nZXRTdGF0ZSgpLnNvcnRpbmcsIHRhYmxlLmdldFByZVNvcnRlZFJvd01vZGVsKCldLCAoc29ydGluZywgcm93TW9kZWwpID0+IHtcbiAgICBpZiAoIXJvd01vZGVsLnJvd3MubGVuZ3RoIHx8ICEoc29ydGluZyAhPSBudWxsICYmIHNvcnRpbmcubGVuZ3RoKSkge1xuICAgICAgcmV0dXJuIHJvd01vZGVsO1xuICAgIH1cbiAgICBjb25zdCBzb3J0aW5nU3RhdGUgPSB0YWJsZS5nZXRTdGF0ZSgpLnNvcnRpbmc7XG4gICAgY29uc3Qgc29ydGVkRmxhdFJvd3MgPSBbXTtcblxuICAgIC8vIEZpbHRlciBvdXQgc29ydGluZ3MgdGhhdCBjb3JyZXNwb25kIHRvIG5vbiBleGlzdGluZyBjb2x1bW5zXG4gICAgY29uc3QgYXZhaWxhYmxlU29ydGluZyA9IHNvcnRpbmdTdGF0ZS5maWx0ZXIoc29ydCA9PiB7XG4gICAgICB2YXIgX3RhYmxlJGdldENvbHVtbjtcbiAgICAgIHJldHVybiAoX3RhYmxlJGdldENvbHVtbiA9IHRhYmxlLmdldENvbHVtbihzb3J0LmlkKSkgPT0gbnVsbCA/IHZvaWQgMCA6IF90YWJsZSRnZXRDb2x1bW4uZ2V0Q2FuU29ydCgpO1xuICAgIH0pO1xuICAgIGNvbnN0IGNvbHVtbkluZm9CeUlkID0ge307XG4gICAgYXZhaWxhYmxlU29ydGluZy5mb3JFYWNoKHNvcnRFbnRyeSA9PiB7XG4gICAgICBjb25zdCBjb2x1bW4gPSB0YWJsZS5nZXRDb2x1bW4oc29ydEVudHJ5LmlkKTtcbiAgICAgIGlmICghY29sdW1uKSByZXR1cm47XG4gICAgICBjb2x1bW5JbmZvQnlJZFtzb3J0RW50cnkuaWRdID0ge1xuICAgICAgICBzb3J0VW5kZWZpbmVkOiBjb2x1bW4uY29sdW1uRGVmLnNvcnRVbmRlZmluZWQsXG4gICAgICAgIGludmVydFNvcnRpbmc6IGNvbHVtbi5jb2x1bW5EZWYuaW52ZXJ0U29ydGluZyxcbiAgICAgICAgc29ydGluZ0ZuOiBjb2x1bW4uZ2V0U29ydGluZ0ZuKClcbiAgICAgIH07XG4gICAgfSk7XG4gICAgY29uc3Qgc29ydERhdGEgPSByb3dzID0+IHtcbiAgICAgIC8vIFRoaXMgd2lsbCBhbHNvIHBlcmZvcm0gYSBzdGFibGUgc29ydGluZyB1c2luZyB0aGUgcm93IGluZGV4XG4gICAgICAvLyBpZiBuZWVkZWQuXG4gICAgICBjb25zdCBzb3J0ZWREYXRhID0gcm93cy5tYXAocm93ID0+ICh7XG4gICAgICAgIC4uLnJvd1xuICAgICAgfSkpO1xuICAgICAgc29ydGVkRGF0YS5zb3J0KChyb3dBLCByb3dCKSA9PiB7XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgYXZhaWxhYmxlU29ydGluZy5sZW5ndGg7IGkgKz0gMSkge1xuICAgICAgICAgIHZhciBfc29ydEVudHJ5JGRlc2M7XG4gICAgICAgICAgY29uc3Qgc29ydEVudHJ5ID0gYXZhaWxhYmxlU29ydGluZ1tpXTtcbiAgICAgICAgICBjb25zdCBjb2x1bW5JbmZvID0gY29sdW1uSW5mb0J5SWRbc29ydEVudHJ5LmlkXTtcbiAgICAgICAgICBjb25zdCBpc0Rlc2MgPSAoX3NvcnRFbnRyeSRkZXNjID0gc29ydEVudHJ5ID09IG51bGwgPyB2b2lkIDAgOiBzb3J0RW50cnkuZGVzYykgIT0gbnVsbCA/IF9zb3J0RW50cnkkZGVzYyA6IGZhbHNlO1xuICAgICAgICAgIGxldCBzb3J0SW50ID0gMDtcblxuICAgICAgICAgIC8vIEFsbCBzb3J0aW5nIGludHMgc2hvdWxkIGFsd2F5cyByZXR1cm4gaW4gYXNjZW5kaW5nIG9yZGVyXG4gICAgICAgICAgaWYgKGNvbHVtbkluZm8uc29ydFVuZGVmaW5lZCkge1xuICAgICAgICAgICAgY29uc3QgYVZhbHVlID0gcm93QS5nZXRWYWx1ZShzb3J0RW50cnkuaWQpO1xuICAgICAgICAgICAgY29uc3QgYlZhbHVlID0gcm93Qi5nZXRWYWx1ZShzb3J0RW50cnkuaWQpO1xuICAgICAgICAgICAgY29uc3QgYVVuZGVmaW5lZCA9IGFWYWx1ZSA9PT0gdW5kZWZpbmVkO1xuICAgICAgICAgICAgY29uc3QgYlVuZGVmaW5lZCA9IGJWYWx1ZSA9PT0gdW5kZWZpbmVkO1xuICAgICAgICAgICAgaWYgKGFVbmRlZmluZWQgfHwgYlVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICBzb3J0SW50ID0gYVVuZGVmaW5lZCAmJiBiVW5kZWZpbmVkID8gMCA6IGFVbmRlZmluZWQgPyBjb2x1bW5JbmZvLnNvcnRVbmRlZmluZWQgOiAtY29sdW1uSW5mby5zb3J0VW5kZWZpbmVkO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAoc29ydEludCA9PT0gMCkge1xuICAgICAgICAgICAgc29ydEludCA9IGNvbHVtbkluZm8uc29ydGluZ0ZuKHJvd0EsIHJvd0IsIHNvcnRFbnRyeS5pZCk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgLy8gSWYgc29ydGluZyBpcyBub24temVybywgdGFrZSBjYXJlIG9mIGRlc2MgYW5kIGludmVyc2lvblxuICAgICAgICAgIGlmIChzb3J0SW50ICE9PSAwKSB7XG4gICAgICAgICAgICBpZiAoaXNEZXNjKSB7XG4gICAgICAgICAgICAgIHNvcnRJbnQgKj0gLTE7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoY29sdW1uSW5mby5pbnZlcnRTb3J0aW5nKSB7XG4gICAgICAgICAgICAgIHNvcnRJbnQgKj0gLTE7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gc29ydEludDtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJvd0EuaW5kZXggLSByb3dCLmluZGV4O1xuICAgICAgfSk7XG5cbiAgICAgIC8vIElmIHRoZXJlIGFyZSBzdWItcm93cywgc29ydCB0aGVtXG4gICAgICBzb3J0ZWREYXRhLmZvckVhY2gocm93ID0+IHtcbiAgICAgICAgdmFyIF9yb3ckc3ViUm93cztcbiAgICAgICAgc29ydGVkRmxhdFJvd3MucHVzaChyb3cpO1xuICAgICAgICBpZiAoKF9yb3ckc3ViUm93cyA9IHJvdy5zdWJSb3dzKSAhPSBudWxsICYmIF9yb3ckc3ViUm93cy5sZW5ndGgpIHtcbiAgICAgICAgICByb3cuc3ViUm93cyA9IHNvcnREYXRhKHJvdy5zdWJSb3dzKTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgICByZXR1cm4gc29ydGVkRGF0YTtcbiAgICB9O1xuICAgIHJldHVybiB7XG4gICAgICByb3dzOiBzb3J0RGF0YShyb3dNb2RlbC5yb3dzKSxcbiAgICAgIGZsYXRSb3dzOiBzb3J0ZWRGbGF0Um93cyxcbiAgICAgIHJvd3NCeUlkOiByb3dNb2RlbC5yb3dzQnlJZFxuICAgIH07XG4gIH0sIHtcbiAgICBrZXk6IHByb2Nlc3MuZW52Lk5PREVfRU5WID09PSAnZGV2ZWxvcG1lbnQnICYmICdnZXRTb3J0ZWRSb3dNb2RlbCcsXG4gICAgZGVidWc6ICgpID0+IHtcbiAgICAgIHZhciBfdGFibGUkb3B0aW9ucyRkZWJ1Z0E7XG4gICAgICByZXR1cm4gKF90YWJsZSRvcHRpb25zJGRlYnVnQSA9IHRhYmxlLm9wdGlvbnMuZGVidWdBbGwpICE9IG51bGwgPyBfdGFibGUkb3B0aW9ucyRkZWJ1Z0EgOiB0YWJsZS5vcHRpb25zLmRlYnVnVGFibGU7XG4gICAgfSxcbiAgICBvbkNoYW5nZTogKCkgPT4ge1xuICAgICAgdGFibGUuX2F1dG9SZXNldFBhZ2VJbmRleCgpO1xuICAgIH1cbiAgfSk7XG59XG5cbmZ1bmN0aW9uIGdldEdyb3VwZWRSb3dNb2RlbCgpIHtcbiAgcmV0dXJuIHRhYmxlID0+IG1lbW8oKCkgPT4gW3RhYmxlLmdldFN0YXRlKCkuZ3JvdXBpbmcsIHRhYmxlLmdldFByZUdyb3VwZWRSb3dNb2RlbCgpXSwgKGdyb3VwaW5nLCByb3dNb2RlbCkgPT4ge1xuICAgIGlmICghcm93TW9kZWwucm93cy5sZW5ndGggfHwgIWdyb3VwaW5nLmxlbmd0aCkge1xuICAgICAgcmV0dXJuIHJvd01vZGVsO1xuICAgIH1cblxuICAgIC8vIEZpbHRlciB0aGUgZ3JvdXBpbmcgbGlzdCBkb3duIHRvIGNvbHVtbnMgdGhhdCBleGlzdFxuICAgIGNvbnN0IGV4aXN0aW5nR3JvdXBpbmcgPSBncm91cGluZy5maWx0ZXIoY29sdW1uSWQgPT4gdGFibGUuZ2V0Q29sdW1uKGNvbHVtbklkKSk7XG4gICAgY29uc3QgZ3JvdXBlZEZsYXRSb3dzID0gW107XG4gICAgY29uc3QgZ3JvdXBlZFJvd3NCeUlkID0ge307XG4gICAgLy8gY29uc3Qgb25seUdyb3VwZWRGbGF0Um93czogUm93W10gPSBbXTtcbiAgICAvLyBjb25zdCBvbmx5R3JvdXBlZFJvd3NCeUlkOiBSZWNvcmQ8Um93SWQsIFJvdz4gPSB7fTtcbiAgICAvLyBjb25zdCBub25Hcm91cGVkRmxhdFJvd3M6IFJvd1tdID0gW107XG4gICAgLy8gY29uc3Qgbm9uR3JvdXBlZFJvd3NCeUlkOiBSZWNvcmQ8Um93SWQsIFJvdz4gPSB7fTtcblxuICAgIC8vIFJlY3Vyc2l2ZWx5IGdyb3VwIHRoZSBkYXRhXG4gICAgY29uc3QgZ3JvdXBVcFJlY3Vyc2l2ZWx5ID0gZnVuY3Rpb24gKHJvd3MsIGRlcHRoLCBwYXJlbnRJZCkge1xuICAgICAgaWYgKGRlcHRoID09PSB2b2lkIDApIHtcbiAgICAgICAgZGVwdGggPSAwO1xuICAgICAgfVxuICAgICAgLy8gR3JvdXBpbmcgZGVwdGggaGFzIGJlZW4gYmVlbiBtZXRcbiAgICAgIC8vIFN0b3AgZ3JvdXBpbmcgYW5kIHNpbXBseSByZXdyaXRlIHRoZCBkZXB0aCBhbmQgcm93IHJlbGF0aW9uc2hpcHNcbiAgICAgIGlmIChkZXB0aCA+PSBleGlzdGluZ0dyb3VwaW5nLmxlbmd0aCkge1xuICAgICAgICByZXR1cm4gcm93cy5tYXAocm93ID0+IHtcbiAgICAgICAgICByb3cuZGVwdGggPSBkZXB0aDtcbiAgICAgICAgICBncm91cGVkRmxhdFJvd3MucHVzaChyb3cpO1xuICAgICAgICAgIGdyb3VwZWRSb3dzQnlJZFtyb3cuaWRdID0gcm93O1xuICAgICAgICAgIGlmIChyb3cuc3ViUm93cykge1xuICAgICAgICAgICAgcm93LnN1YlJvd3MgPSBncm91cFVwUmVjdXJzaXZlbHkocm93LnN1YlJvd3MsIGRlcHRoICsgMSwgcm93LmlkKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgcmV0dXJuIHJvdztcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgICBjb25zdCBjb2x1bW5JZCA9IGV4aXN0aW5nR3JvdXBpbmdbZGVwdGhdO1xuXG4gICAgICAvLyBHcm91cCB0aGUgcm93cyB0b2dldGhlciBmb3IgdGhpcyBsZXZlbFxuICAgICAgY29uc3Qgcm93R3JvdXBzTWFwID0gZ3JvdXBCeShyb3dzLCBjb2x1bW5JZCk7XG5cbiAgICAgIC8vIFBlZm9ybSBhZ2dyZWdhdGlvbnMgZm9yIGVhY2ggZ3JvdXBcbiAgICAgIGNvbnN0IGFnZ3JlZ2F0ZWRHcm91cGVkUm93cyA9IEFycmF5LmZyb20ocm93R3JvdXBzTWFwLmVudHJpZXMoKSkubWFwKChfcmVmLCBpbmRleCkgPT4ge1xuICAgICAgICBsZXQgW2dyb3VwaW5nVmFsdWUsIGdyb3VwZWRSb3dzXSA9IF9yZWY7XG4gICAgICAgIGxldCBpZCA9IGAke2NvbHVtbklkfToke2dyb3VwaW5nVmFsdWV9YDtcbiAgICAgICAgaWQgPSBwYXJlbnRJZCA/IGAke3BhcmVudElkfT4ke2lkfWAgOiBpZDtcblxuICAgICAgICAvLyBGaXJzdCwgUmVjdXJzZSB0byBncm91cCBzdWIgcm93cyBiZWZvcmUgYWdncmVnYXRpb25cbiAgICAgICAgY29uc3Qgc3ViUm93cyA9IGdyb3VwVXBSZWN1cnNpdmVseShncm91cGVkUm93cywgZGVwdGggKyAxLCBpZCk7XG5cbiAgICAgICAgLy8gRmxhdHRlbiB0aGUgbGVhZiByb3dzIG9mIHRoZSByb3dzIGluIHRoaXMgZ3JvdXBcbiAgICAgICAgY29uc3QgbGVhZlJvd3MgPSBkZXB0aCA/IGZsYXR0ZW5CeShncm91cGVkUm93cywgcm93ID0+IHJvdy5zdWJSb3dzKSA6IGdyb3VwZWRSb3dzO1xuICAgICAgICBjb25zdCByb3cgPSBjcmVhdGVSb3codGFibGUsIGlkLCBsZWFmUm93c1swXS5vcmlnaW5hbCwgaW5kZXgsIGRlcHRoLCB1bmRlZmluZWQsIHBhcmVudElkKTtcbiAgICAgICAgT2JqZWN0LmFzc2lnbihyb3csIHtcbiAgICAgICAgICBncm91cGluZ0NvbHVtbklkOiBjb2x1bW5JZCxcbiAgICAgICAgICBncm91cGluZ1ZhbHVlLFxuICAgICAgICAgIHN1YlJvd3MsXG4gICAgICAgICAgbGVhZlJvd3MsXG4gICAgICAgICAgZ2V0VmFsdWU6IGNvbHVtbklkID0+IHtcbiAgICAgICAgICAgIC8vIERvbid0IGFnZ3JlZ2F0ZSBjb2x1bW5zIHRoYXQgYXJlIGluIHRoZSBncm91cGluZ1xuICAgICAgICAgICAgaWYgKGV4aXN0aW5nR3JvdXBpbmcuaW5jbHVkZXMoY29sdW1uSWQpKSB7XG4gICAgICAgICAgICAgIGlmIChyb3cuX3ZhbHVlc0NhY2hlLmhhc093blByb3BlcnR5KGNvbHVtbklkKSkge1xuICAgICAgICAgICAgICAgIHJldHVybiByb3cuX3ZhbHVlc0NhY2hlW2NvbHVtbklkXTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBpZiAoZ3JvdXBlZFJvd3NbMF0pIHtcbiAgICAgICAgICAgICAgICB2YXIgX2dyb3VwZWRSb3dzJDAkZ2V0VmFsO1xuICAgICAgICAgICAgICAgIHJvdy5fdmFsdWVzQ2FjaGVbY29sdW1uSWRdID0gKF9ncm91cGVkUm93cyQwJGdldFZhbCA9IGdyb3VwZWRSb3dzWzBdLmdldFZhbHVlKGNvbHVtbklkKSkgIT0gbnVsbCA/IF9ncm91cGVkUm93cyQwJGdldFZhbCA6IHVuZGVmaW5lZDtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICByZXR1cm4gcm93Ll92YWx1ZXNDYWNoZVtjb2x1bW5JZF07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAocm93Ll9ncm91cGluZ1ZhbHVlc0NhY2hlLmhhc093blByb3BlcnR5KGNvbHVtbklkKSkge1xuICAgICAgICAgICAgICByZXR1cm4gcm93Ll9ncm91cGluZ1ZhbHVlc0NhY2hlW2NvbHVtbklkXTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLy8gQWdncmVnYXRlIHRoZSB2YWx1ZXNcbiAgICAgICAgICAgIGNvbnN0IGNvbHVtbiA9IHRhYmxlLmdldENvbHVtbihjb2x1bW5JZCk7XG4gICAgICAgICAgICBjb25zdCBhZ2dyZWdhdGVGbiA9IGNvbHVtbiA9PSBudWxsID8gdm9pZCAwIDogY29sdW1uLmdldEFnZ3JlZ2F0aW9uRm4oKTtcbiAgICAgICAgICAgIGlmIChhZ2dyZWdhdGVGbikge1xuICAgICAgICAgICAgICByb3cuX2dyb3VwaW5nVmFsdWVzQ2FjaGVbY29sdW1uSWRdID0gYWdncmVnYXRlRm4oY29sdW1uSWQsIGxlYWZSb3dzLCBncm91cGVkUm93cyk7XG4gICAgICAgICAgICAgIHJldHVybiByb3cuX2dyb3VwaW5nVmFsdWVzQ2FjaGVbY29sdW1uSWRdO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICAgIHN1YlJvd3MuZm9yRWFjaChzdWJSb3cgPT4ge1xuICAgICAgICAgIGdyb3VwZWRGbGF0Um93cy5wdXNoKHN1YlJvdyk7XG4gICAgICAgICAgZ3JvdXBlZFJvd3NCeUlkW3N1YlJvdy5pZF0gPSBzdWJSb3c7XG4gICAgICAgICAgLy8gaWYgKHN1YlJvdy5nZXRJc0dyb3VwZWQ/LigpKSB7XG4gICAgICAgICAgLy8gICBvbmx5R3JvdXBlZEZsYXRSb3dzLnB1c2goc3ViUm93KTtcbiAgICAgICAgICAvLyAgIG9ubHlHcm91cGVkUm93c0J5SWRbc3ViUm93LmlkXSA9IHN1YlJvdztcbiAgICAgICAgICAvLyB9IGVsc2Uge1xuICAgICAgICAgIC8vICAgbm9uR3JvdXBlZEZsYXRSb3dzLnB1c2goc3ViUm93KTtcbiAgICAgICAgICAvLyAgIG5vbkdyb3VwZWRSb3dzQnlJZFtzdWJSb3cuaWRdID0gc3ViUm93O1xuICAgICAgICAgIC8vIH1cbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiByb3c7XG4gICAgICB9KTtcbiAgICAgIHJldHVybiBhZ2dyZWdhdGVkR3JvdXBlZFJvd3M7XG4gICAgfTtcbiAgICBjb25zdCBncm91cGVkUm93cyA9IGdyb3VwVXBSZWN1cnNpdmVseShyb3dNb2RlbC5yb3dzLCAwKTtcbiAgICBncm91cGVkUm93cy5mb3JFYWNoKHN1YlJvdyA9PiB7XG4gICAgICBncm91cGVkRmxhdFJvd3MucHVzaChzdWJSb3cpO1xuICAgICAgZ3JvdXBlZFJvd3NCeUlkW3N1YlJvdy5pZF0gPSBzdWJSb3c7XG4gICAgICAvLyBpZiAoc3ViUm93LmdldElzR3JvdXBlZD8uKCkpIHtcbiAgICAgIC8vICAgb25seUdyb3VwZWRGbGF0Um93cy5wdXNoKHN1YlJvdyk7XG4gICAgICAvLyAgIG9ubHlHcm91cGVkUm93c0J5SWRbc3ViUm93LmlkXSA9IHN1YlJvdztcbiAgICAgIC8vIH0gZWxzZSB7XG4gICAgICAvLyAgIG5vbkdyb3VwZWRGbGF0Um93cy5wdXNoKHN1YlJvdyk7XG4gICAgICAvLyAgIG5vbkdyb3VwZWRSb3dzQnlJZFtzdWJSb3cuaWRdID0gc3ViUm93O1xuICAgICAgLy8gfVxuICAgIH0pO1xuICAgIHJldHVybiB7XG4gICAgICByb3dzOiBncm91cGVkUm93cyxcbiAgICAgIGZsYXRSb3dzOiBncm91cGVkRmxhdFJvd3MsXG4gICAgICByb3dzQnlJZDogZ3JvdXBlZFJvd3NCeUlkXG4gICAgfTtcbiAgfSwge1xuICAgIGtleTogcHJvY2Vzcy5lbnYuTk9ERV9FTlYgPT09ICdkZXZlbG9wbWVudCcgJiYgJ2dldEdyb3VwZWRSb3dNb2RlbCcsXG4gICAgZGVidWc6ICgpID0+IHtcbiAgICAgIHZhciBfdGFibGUkb3B0aW9ucyRkZWJ1Z0E7XG4gICAgICByZXR1cm4gKF90YWJsZSRvcHRpb25zJGRlYnVnQSA9IHRhYmxlLm9wdGlvbnMuZGVidWdBbGwpICE9IG51bGwgPyBfdGFibGUkb3B0aW9ucyRkZWJ1Z0EgOiB0YWJsZS5vcHRpb25zLmRlYnVnVGFibGU7XG4gICAgfSxcbiAgICBvbkNoYW5nZTogKCkgPT4ge1xuICAgICAgdGFibGUuX3F1ZXVlKCgpID0+IHtcbiAgICAgICAgdGFibGUuX2F1dG9SZXNldEV4cGFuZGVkKCk7XG4gICAgICAgIHRhYmxlLl9hdXRvUmVzZXRQYWdlSW5kZXgoKTtcbiAgICAgIH0pO1xuICAgIH1cbiAgfSk7XG59XG5mdW5jdGlvbiBncm91cEJ5KHJvd3MsIGNvbHVtbklkKSB7XG4gIGNvbnN0IGdyb3VwTWFwID0gbmV3IE1hcCgpO1xuICByZXR1cm4gcm93cy5yZWR1Y2UoKG1hcCwgcm93KSA9PiB7XG4gICAgY29uc3QgcmVzS2V5ID0gYCR7cm93LmdldEdyb3VwaW5nVmFsdWUoY29sdW1uSWQpfWA7XG4gICAgY29uc3QgcHJldmlvdXMgPSBtYXAuZ2V0KHJlc0tleSk7XG4gICAgaWYgKCFwcmV2aW91cykge1xuICAgICAgbWFwLnNldChyZXNLZXksIFtyb3ddKTtcbiAgICB9IGVsc2Uge1xuICAgICAgcHJldmlvdXMucHVzaChyb3cpO1xuICAgIH1cbiAgICByZXR1cm4gbWFwO1xuICB9LCBncm91cE1hcCk7XG59XG5cbmZ1bmN0aW9uIGdldEV4cGFuZGVkUm93TW9kZWwoKSB7XG4gIHJldHVybiB0YWJsZSA9PiBtZW1vKCgpID0+IFt0YWJsZS5nZXRTdGF0ZSgpLmV4cGFuZGVkLCB0YWJsZS5nZXRQcmVFeHBhbmRlZFJvd01vZGVsKCksIHRhYmxlLm9wdGlvbnMucGFnaW5hdGVFeHBhbmRlZFJvd3NdLCAoZXhwYW5kZWQsIHJvd01vZGVsLCBwYWdpbmF0ZUV4cGFuZGVkUm93cykgPT4ge1xuICAgIGlmICghcm93TW9kZWwucm93cy5sZW5ndGggfHwgZXhwYW5kZWQgIT09IHRydWUgJiYgIU9iamVjdC5rZXlzKGV4cGFuZGVkICE9IG51bGwgPyBleHBhbmRlZCA6IHt9KS5sZW5ndGgpIHtcbiAgICAgIHJldHVybiByb3dNb2RlbDtcbiAgICB9XG4gICAgaWYgKCFwYWdpbmF0ZUV4cGFuZGVkUm93cykge1xuICAgICAgLy8gT25seSBleHBhbmQgcm93cyBhdCB0aGlzIHBvaW50IGlmIHRoZXkgYXJlIGJlaW5nIHBhZ2luYXRlZFxuICAgICAgcmV0dXJuIHJvd01vZGVsO1xuICAgIH1cbiAgICByZXR1cm4gZXhwYW5kUm93cyhyb3dNb2RlbCk7XG4gIH0sIHtcbiAgICBrZXk6IHByb2Nlc3MuZW52Lk5PREVfRU5WID09PSAnZGV2ZWxvcG1lbnQnICYmICdnZXRFeHBhbmRlZFJvd01vZGVsJyxcbiAgICBkZWJ1ZzogKCkgPT4ge1xuICAgICAgdmFyIF90YWJsZSRvcHRpb25zJGRlYnVnQTtcbiAgICAgIHJldHVybiAoX3RhYmxlJG9wdGlvbnMkZGVidWdBID0gdGFibGUub3B0aW9ucy5kZWJ1Z0FsbCkgIT0gbnVsbCA/IF90YWJsZSRvcHRpb25zJGRlYnVnQSA6IHRhYmxlLm9wdGlvbnMuZGVidWdUYWJsZTtcbiAgICB9XG4gIH0pO1xufVxuZnVuY3Rpb24gZXhwYW5kUm93cyhyb3dNb2RlbCkge1xuICBjb25zdCBleHBhbmRlZFJvd3MgPSBbXTtcbiAgY29uc3QgaGFuZGxlUm93ID0gcm93ID0+IHtcbiAgICB2YXIgX3JvdyRzdWJSb3dzO1xuICAgIGV4cGFuZGVkUm93cy5wdXNoKHJvdyk7XG4gICAgaWYgKChfcm93JHN1YlJvd3MgPSByb3cuc3ViUm93cykgIT0gbnVsbCAmJiBfcm93JHN1YlJvd3MubGVuZ3RoICYmIHJvdy5nZXRJc0V4cGFuZGVkKCkpIHtcbiAgICAgIHJvdy5zdWJSb3dzLmZvckVhY2goaGFuZGxlUm93KTtcbiAgICB9XG4gIH07XG4gIHJvd01vZGVsLnJvd3MuZm9yRWFjaChoYW5kbGVSb3cpO1xuICByZXR1cm4ge1xuICAgIHJvd3M6IGV4cGFuZGVkUm93cyxcbiAgICBmbGF0Um93czogcm93TW9kZWwuZmxhdFJvd3MsXG4gICAgcm93c0J5SWQ6IHJvd01vZGVsLnJvd3NCeUlkXG4gIH07XG59XG5cbmZ1bmN0aW9uIGdldFBhZ2luYXRpb25Sb3dNb2RlbChvcHRzKSB7XG4gIHJldHVybiB0YWJsZSA9PiBtZW1vKCgpID0+IFt0YWJsZS5nZXRTdGF0ZSgpLnBhZ2luYXRpb24sIHRhYmxlLmdldFByZVBhZ2luYXRpb25Sb3dNb2RlbCgpLCB0YWJsZS5vcHRpb25zLnBhZ2luYXRlRXhwYW5kZWRSb3dzID8gdW5kZWZpbmVkIDogdGFibGUuZ2V0U3RhdGUoKS5leHBhbmRlZF0sIChwYWdpbmF0aW9uLCByb3dNb2RlbCkgPT4ge1xuICAgIGlmICghcm93TW9kZWwucm93cy5sZW5ndGgpIHtcbiAgICAgIHJldHVybiByb3dNb2RlbDtcbiAgICB9XG4gICAgY29uc3Qge1xuICAgICAgcGFnZVNpemUsXG4gICAgICBwYWdlSW5kZXhcbiAgICB9ID0gcGFnaW5hdGlvbjtcbiAgICBsZXQge1xuICAgICAgcm93cyxcbiAgICAgIGZsYXRSb3dzLFxuICAgICAgcm93c0J5SWRcbiAgICB9ID0gcm93TW9kZWw7XG4gICAgY29uc3QgcGFnZVN0YXJ0ID0gcGFnZVNpemUgKiBwYWdlSW5kZXg7XG4gICAgY29uc3QgcGFnZUVuZCA9IHBhZ2VTdGFydCArIHBhZ2VTaXplO1xuICAgIHJvd3MgPSByb3dzLnNsaWNlKHBhZ2VTdGFydCwgcGFnZUVuZCk7XG4gICAgbGV0IHBhZ2luYXRlZFJvd01vZGVsO1xuICAgIGlmICghdGFibGUub3B0aW9ucy5wYWdpbmF0ZUV4cGFuZGVkUm93cykge1xuICAgICAgcGFnaW5hdGVkUm93TW9kZWwgPSBleHBhbmRSb3dzKHtcbiAgICAgICAgcm93cyxcbiAgICAgICAgZmxhdFJvd3MsXG4gICAgICAgIHJvd3NCeUlkXG4gICAgICB9KTtcbiAgICB9IGVsc2Uge1xuICAgICAgcGFnaW5hdGVkUm93TW9kZWwgPSB7XG4gICAgICAgIHJvd3MsXG4gICAgICAgIGZsYXRSb3dzLFxuICAgICAgICByb3dzQnlJZFxuICAgICAgfTtcbiAgICB9XG4gICAgcGFnaW5hdGVkUm93TW9kZWwuZmxhdFJvd3MgPSBbXTtcbiAgICBjb25zdCBoYW5kbGVSb3cgPSByb3cgPT4ge1xuICAgICAgcGFnaW5hdGVkUm93TW9kZWwuZmxhdFJvd3MucHVzaChyb3cpO1xuICAgICAgaWYgKHJvdy5zdWJSb3dzLmxlbmd0aCkge1xuICAgICAgICByb3cuc3ViUm93cy5mb3JFYWNoKGhhbmRsZVJvdyk7XG4gICAgICB9XG4gICAgfTtcbiAgICBwYWdpbmF0ZWRSb3dNb2RlbC5yb3dzLmZvckVhY2goaGFuZGxlUm93KTtcbiAgICByZXR1cm4gcGFnaW5hdGVkUm93TW9kZWw7XG4gIH0sIHtcbiAgICBrZXk6IHByb2Nlc3MuZW52Lk5PREVfRU5WID09PSAnZGV2ZWxvcG1lbnQnICYmICdnZXRQYWdpbmF0aW9uUm93TW9kZWwnLFxuICAgIGRlYnVnOiAoKSA9PiB7XG4gICAgICB2YXIgX3RhYmxlJG9wdGlvbnMkZGVidWdBO1xuICAgICAgcmV0dXJuIChfdGFibGUkb3B0aW9ucyRkZWJ1Z0EgPSB0YWJsZS5vcHRpb25zLmRlYnVnQWxsKSAhPSBudWxsID8gX3RhYmxlJG9wdGlvbnMkZGVidWdBIDogdGFibGUub3B0aW9ucy5kZWJ1Z1RhYmxlO1xuICAgIH1cbiAgfSk7XG59XG5cbmV4cG9ydCB7IENvbHVtblNpemluZywgRXhwYW5kaW5nLCBGaWx0ZXJzLCBHcm91cGluZywgSGVhZGVycywgT3JkZXJpbmcsIFBhZ2luYXRpb24sIFBpbm5pbmcsIFJvd1NlbGVjdGlvbiwgU29ydGluZywgVmlzaWJpbGl0eSwgYWdncmVnYXRpb25GbnMsIGJ1aWxkSGVhZGVyR3JvdXBzLCBjcmVhdGVDZWxsLCBjcmVhdGVDb2x1bW4sIGNyZWF0ZUNvbHVtbkhlbHBlciwgY3JlYXRlUm93LCBjcmVhdGVUYWJsZSwgZGVmYXVsdENvbHVtblNpemluZywgZXhwYW5kUm93cywgZmlsdGVyRm5zLCBmbGF0dGVuQnksIGZ1bmN0aW9uYWxVcGRhdGUsIGdldENvcmVSb3dNb2RlbCwgZ2V0RXhwYW5kZWRSb3dNb2RlbCwgZ2V0RmFjZXRlZE1pbk1heFZhbHVlcywgZ2V0RmFjZXRlZFJvd01vZGVsLCBnZXRGYWNldGVkVW5pcXVlVmFsdWVzLCBnZXRGaWx0ZXJlZFJvd01vZGVsLCBnZXRHcm91cGVkUm93TW9kZWwsIGdldFBhZ2luYXRpb25Sb3dNb2RlbCwgZ2V0U29ydGVkUm93TW9kZWwsIGlzRnVuY3Rpb24sIGlzTnVtYmVyQXJyYXksIGlzUm93U2VsZWN0ZWQsIGlzU3ViUm93U2VsZWN0ZWQsIG1ha2VTdGF0ZVVwZGF0ZXIsIG1lbW8sIG5vb3AsIG9yZGVyQ29sdW1ucywgcGFzc2l2ZUV2ZW50U3VwcG9ydGVkLCByZVNwbGl0QWxwaGFOdW1lcmljLCBzZWxlY3RSb3dzRm4sIHNob3VsZEF1dG9SZW1vdmVGaWx0ZXIsIHNvcnRpbmdGbnMgfTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWluZGV4Lm1qcy5tYXBcbiJdLCJuYW1lcyI6WyJmdW5jdGlvbmFsVXBkYXRlIiwidXBkYXRlciIsImlucHV0Iiwibm9vcCIsIm1ha2VTdGF0ZVVwZGF0ZXIiLCJrZXkiLCJpbnN0YW5jZSIsInNldFN0YXRlIiwib2xkIiwiaXNGdW5jdGlvbiIsImQiLCJGdW5jdGlvbiIsImlzTnVtYmVyQXJyYXkiLCJBcnJheSIsImlzQXJyYXkiLCJldmVyeSIsInZhbCIsImZsYXR0ZW5CeSIsImFyciIsImdldENoaWxkcmVuIiwiZmxhdCIsInJlY3Vyc2UiLCJzdWJBcnIiLCJmb3JFYWNoIiwiaXRlbSIsInB1c2giLCJjaGlsZHJlbiIsImxlbmd0aCIsIm1lbW8iLCJnZXREZXBzIiwiZm4iLCJvcHRzIiwiZGVwcyIsInJlc3VsdCIsImRlcFRpbWUiLCJkZWJ1ZyIsIkRhdGUiLCJub3ciLCJuZXdEZXBzIiwiZGVwc0NoYW5nZWQiLCJzb21lIiwiZGVwIiwiaW5kZXgiLCJyZXN1bHRUaW1lIiwib25DaGFuZ2UiLCJkZXBFbmRUaW1lIiwiTWF0aCIsInJvdW5kIiwicmVzdWx0RW5kVGltZSIsInJlc3VsdEZwc1BlcmNlbnRhZ2UiLCJwYWQiLCJzdHIiLCJudW0iLCJTdHJpbmciLCJjb25zb2xlIiwiaW5mbyIsIm1heCIsIm1pbiIsImNyZWF0ZUNvbHVtbiIsInRhYmxlIiwiY29sdW1uRGVmIiwiZGVwdGgiLCJwYXJlbnQiLCJfcmVmIiwiX3Jlc29sdmVkQ29sdW1uRGVmJGlkIiwiZGVmYXVsdENvbHVtbiIsIl9nZXREZWZhdWx0Q29sdW1uRGVmIiwicmVzb2x2ZWRDb2x1bW5EZWYiLCJhY2Nlc3NvcktleSIsImlkIiwicmVwbGFjZSIsInVuZGVmaW5lZCIsImhlYWRlciIsImFjY2Vzc29yRm4iLCJpbmNsdWRlcyIsIm9yaWdpbmFsUm93Iiwic3BsaXQiLCJfcmVzdWx0IiwicHJvY2VzcyIsIndhcm4iLCJFcnJvciIsImNvbHVtbiIsImNvbHVtbnMiLCJnZXRGbGF0Q29sdW1ucyIsIl9jb2x1bW4kY29sdW1ucyIsImZsYXRNYXAiLCJfdGFibGUkb3B0aW9ucyRkZWJ1Z0EiLCJvcHRpb25zIiwiZGVidWdBbGwiLCJkZWJ1Z0NvbHVtbnMiLCJnZXRMZWFmQ29sdW1ucyIsIl9nZXRPcmRlckNvbHVtbnNGbiIsIm9yZGVyQ29sdW1ucyIsIl9jb2x1bW4kY29sdW1uczIiLCJsZWFmQ29sdW1ucyIsIl90YWJsZSRvcHRpb25zJGRlYnVnQTIiLCJmZWF0dXJlIiwiX2ZlYXR1cmVzIiwiY3JlYXRlSGVhZGVyIiwiX29wdGlvbnMkaWQiLCJpc1BsYWNlaG9sZGVyIiwicGxhY2Vob2xkZXJJZCIsInN1YkhlYWRlcnMiLCJjb2xTcGFuIiwicm93U3BhbiIsImhlYWRlckdyb3VwIiwiZ2V0TGVhZkhlYWRlcnMiLCJsZWFmSGVhZGVycyIsInJlY3Vyc2VIZWFkZXIiLCJoIiwibWFwIiwiZ2V0Q29udGV4dCIsIkhlYWRlcnMiLCJjcmVhdGVUYWJsZSIsImdldEhlYWRlckdyb3VwcyIsImdldEFsbENvbHVtbnMiLCJnZXRWaXNpYmxlTGVhZkNvbHVtbnMiLCJnZXRTdGF0ZSIsImNvbHVtblBpbm5pbmciLCJsZWZ0IiwicmlnaHQiLCJhbGxDb2x1bW5zIiwiX2xlZnQkbWFwJGZpbHRlciIsIl9yaWdodCRtYXAkZmlsdGVyIiwibGVmdENvbHVtbnMiLCJjb2x1bW5JZCIsImZpbmQiLCJmaWx0ZXIiLCJCb29sZWFuIiwicmlnaHRDb2x1bW5zIiwiY2VudGVyQ29sdW1ucyIsImhlYWRlckdyb3VwcyIsImJ1aWxkSGVhZGVyR3JvdXBzIiwiZGVidWdIZWFkZXJzIiwiZ2V0Q2VudGVySGVhZGVyR3JvdXBzIiwiZ2V0TGVmdEhlYWRlckdyb3VwcyIsIl9sZWZ0JG1hcCRmaWx0ZXIyIiwib3JkZXJlZExlYWZDb2x1bW5zIiwiX3RhYmxlJG9wdGlvbnMkZGVidWdBMyIsImdldFJpZ2h0SGVhZGVyR3JvdXBzIiwiX3JpZ2h0JG1hcCRmaWx0ZXIyIiwiX3RhYmxlJG9wdGlvbnMkZGVidWdBNCIsImdldEZvb3Rlckdyb3VwcyIsInJldmVyc2UiLCJfdGFibGUkb3B0aW9ucyRkZWJ1Z0E1IiwiZ2V0TGVmdEZvb3Rlckdyb3VwcyIsIl90YWJsZSRvcHRpb25zJGRlYnVnQTYiLCJnZXRDZW50ZXJGb290ZXJHcm91cHMiLCJfdGFibGUkb3B0aW9ucyRkZWJ1Z0E3IiwiZ2V0UmlnaHRGb290ZXJHcm91cHMiLCJfdGFibGUkb3B0aW9ucyRkZWJ1Z0E4IiwiZ2V0RmxhdEhlYWRlcnMiLCJoZWFkZXJzIiwiX3RhYmxlJG9wdGlvbnMkZGVidWdBOSIsImdldExlZnRGbGF0SGVhZGVycyIsIl90YWJsZSRvcHRpb25zJGRlYnVnQTEwIiwiZ2V0Q2VudGVyRmxhdEhlYWRlcnMiLCJfdGFibGUkb3B0aW9ucyRkZWJ1Z0ExMSIsImdldFJpZ2h0RmxhdEhlYWRlcnMiLCJfdGFibGUkb3B0aW9ucyRkZWJ1Z0ExMiIsImdldENlbnRlckxlYWZIZWFkZXJzIiwiZmxhdEhlYWRlcnMiLCJfaGVhZGVyJHN1YkhlYWRlcnMiLCJfdGFibGUkb3B0aW9ucyRkZWJ1Z0ExMyIsImdldExlZnRMZWFmSGVhZGVycyIsIl9oZWFkZXIkc3ViSGVhZGVyczIiLCJfdGFibGUkb3B0aW9ucyRkZWJ1Z0ExNCIsImdldFJpZ2h0TGVhZkhlYWRlcnMiLCJfaGVhZGVyJHN1YkhlYWRlcnMzIiwiX3RhYmxlJG9wdGlvbnMkZGVidWdBMTUiLCJjZW50ZXIiLCJfbGVmdCQwJGhlYWRlcnMiLCJfbGVmdCQiLCJfY2VudGVyJDAkaGVhZGVycyIsIl9jZW50ZXIkIiwiX3JpZ2h0JDAkaGVhZGVycyIsIl9yaWdodCQiLCJfdGFibGUkb3B0aW9ucyRkZWJ1Z0ExNiIsImNvbHVtbnNUb0dyb3VwIiwiaGVhZGVyRmFtaWx5IiwiX2hlYWRlckdyb3VwcyQwJGhlYWRlIiwiX2hlYWRlckdyb3VwcyQiLCJtYXhEZXB0aCIsImZpbmRNYXhEZXB0aCIsImdldElzVmlzaWJsZSIsImNyZWF0ZUhlYWRlckdyb3VwIiwiaGVhZGVyc1RvR3JvdXAiLCJqb2luIiwicGVuZGluZ1BhcmVudEhlYWRlcnMiLCJoZWFkZXJUb0dyb3VwIiwibGF0ZXN0UGVuZGluZ1BhcmVudEhlYWRlciIsImlzTGVhZkhlYWRlciIsImJvdHRvbUhlYWRlcnMiLCJyZWN1cnNlSGVhZGVyc0ZvclNwYW5zIiwiZmlsdGVyZWRIZWFkZXJzIiwiY2hpbGRSb3dTcGFucyIsImNoaWxkQ29sU3BhbiIsImNoaWxkUm93U3BhbiIsIm1pbkNoaWxkUm93U3BhbiIsImRlZmF1bHRDb2x1bW5TaXppbmciLCJzaXplIiwibWluU2l6ZSIsIm1heFNpemUiLCJOdW1iZXIiLCJNQVhfU0FGRV9JTlRFR0VSIiwiZ2V0RGVmYXVsdENvbHVtblNpemluZ0luZm9TdGF0ZSIsInN0YXJ0T2Zmc2V0Iiwic3RhcnRTaXplIiwiZGVsdGFPZmZzZXQiLCJkZWx0YVBlcmNlbnRhZ2UiLCJpc1Jlc2l6aW5nQ29sdW1uIiwiY29sdW1uU2l6aW5nU3RhcnQiLCJDb2x1bW5TaXppbmciLCJnZXREZWZhdWx0Q29sdW1uRGVmIiwiZ2V0SW5pdGlhbFN0YXRlIiwic3RhdGUiLCJjb2x1bW5TaXppbmciLCJjb2x1bW5TaXppbmdJbmZvIiwiZ2V0RGVmYXVsdE9wdGlvbnMiLCJjb2x1bW5SZXNpemVNb2RlIiwiY29sdW1uUmVzaXplRGlyZWN0aW9uIiwib25Db2x1bW5TaXppbmdDaGFuZ2UiLCJvbkNvbHVtblNpemluZ0luZm9DaGFuZ2UiLCJnZXRTaXplIiwiX2NvbHVtbiRjb2x1bW5EZWYkbWluIiwiX2NvbHVtbiRjb2x1bW5EZWYkbWF4IiwiY29sdW1uU2l6ZSIsImdldFN0YXJ0IiwicG9zaXRpb24iLCJnZXRMZWZ0VmlzaWJsZUxlYWZDb2x1bW5zIiwiZ2V0UmlnaHRWaXNpYmxlTGVhZkNvbHVtbnMiLCJmaW5kSW5kZXgiLCJwcmV2U2libGluZ0NvbHVtbiIsInJlc2V0U2l6ZSIsInNldENvbHVtblNpemluZyIsIl9yZWYyIiwiXyIsInJlc3QiLCJnZXRDYW5SZXNpemUiLCJfY29sdW1uJGNvbHVtbkRlZiRlbmEiLCJfdGFibGUkb3B0aW9ucyRlbmFibGUiLCJlbmFibGVSZXNpemluZyIsImVuYWJsZUNvbHVtblJlc2l6aW5nIiwiZ2V0SXNSZXNpemluZyIsInN1bSIsIl9oZWFkZXIkY29sdW1uJGdldFNpeiIsInByZXZTaWJsaW5nSGVhZGVyIiwiZ2V0UmVzaXplSGFuZGxlciIsImdldENvbHVtbiIsImNhblJlc2l6ZSIsImUiLCJwZXJzaXN0IiwiaXNUb3VjaFN0YXJ0RXZlbnQiLCJ0b3VjaGVzIiwiY2xpZW50WCIsIm5ld0NvbHVtblNpemluZyIsInVwZGF0ZU9mZnNldCIsImV2ZW50VHlwZSIsImNsaWVudFhQb3MiLCJzZXRDb2x1bW5TaXppbmdJbmZvIiwiX29sZCRzdGFydE9mZnNldCIsIl9vbGQkc3RhcnRTaXplIiwiZGVsdGFEaXJlY3Rpb24iLCJfcmVmMyIsImhlYWRlclNpemUiLCJvbk1vdmUiLCJvbkVuZCIsIm1vdXNlRXZlbnRzIiwibW92ZUhhbmRsZXIiLCJ1cEhhbmRsZXIiLCJkb2N1bWVudCIsInJlbW92ZUV2ZW50TGlzdGVuZXIiLCJ0b3VjaEV2ZW50cyIsImNhbmNlbGFibGUiLCJwcmV2ZW50RGVmYXVsdCIsInN0b3BQcm9wYWdhdGlvbiIsIl9lJHRvdWNoZXMkIiwicGFzc2l2ZUlmU3VwcG9ydGVkIiwicGFzc2l2ZUV2ZW50U3VwcG9ydGVkIiwicGFzc2l2ZSIsImFkZEV2ZW50TGlzdGVuZXIiLCJyZXNldENvbHVtblNpemluZyIsImRlZmF1bHRTdGF0ZSIsIl90YWJsZSRpbml0aWFsU3RhdGUkYyIsImluaXRpYWxTdGF0ZSIsInJlc2V0SGVhZGVyU2l6ZUluZm8iLCJfdGFibGUkaW5pdGlhbFN0YXRlJGMyIiwiZ2V0VG90YWxTaXplIiwiX3RhYmxlJGdldEhlYWRlckdyb3VwIiwiX3RhYmxlJGdldEhlYWRlckdyb3VwMiIsInJlZHVjZSIsImdldExlZnRUb3RhbFNpemUiLCJfdGFibGUkZ2V0TGVmdEhlYWRlckciLCJfdGFibGUkZ2V0TGVmdEhlYWRlckcyIiwiZ2V0Q2VudGVyVG90YWxTaXplIiwiX3RhYmxlJGdldENlbnRlckhlYWRlIiwiX3RhYmxlJGdldENlbnRlckhlYWRlMiIsImdldFJpZ2h0VG90YWxTaXplIiwiX3RhYmxlJGdldFJpZ2h0SGVhZGVyIiwiX3RhYmxlJGdldFJpZ2h0SGVhZGVyMiIsInBhc3NpdmVTdXBwb3J0ZWQiLCJzdXBwb3J0ZWQiLCJ3aW5kb3ciLCJlcnIiLCJ0eXBlIiwiRXhwYW5kaW5nIiwiZXhwYW5kZWQiLCJvbkV4cGFuZGVkQ2hhbmdlIiwicGFnaW5hdGVFeHBhbmRlZFJvd3MiLCJyZWdpc3RlcmVkIiwicXVldWVkIiwiX2F1dG9SZXNldEV4cGFuZGVkIiwiX3RhYmxlJG9wdGlvbnMkYXV0b1JlIiwiX3F1ZXVlIiwiYXV0b1Jlc2V0QWxsIiwiYXV0b1Jlc2V0RXhwYW5kZWQiLCJtYW51YWxFeHBhbmRpbmciLCJyZXNldEV4cGFuZGVkIiwic2V0RXhwYW5kZWQiLCJ0b2dnbGVBbGxSb3dzRXhwYW5kZWQiLCJnZXRJc0FsbFJvd3NFeHBhbmRlZCIsIl90YWJsZSRpbml0aWFsU3RhdGUkZSIsIl90YWJsZSRpbml0aWFsU3RhdGUiLCJnZXRDYW5Tb21lUm93c0V4cGFuZCIsImdldFByZVBhZ2luYXRpb25Sb3dNb2RlbCIsImZsYXRSb3dzIiwicm93IiwiZ2V0Q2FuRXhwYW5kIiwiZ2V0VG9nZ2xlQWxsUm93c0V4cGFuZGVkSGFuZGxlciIsImdldElzU29tZVJvd3NFeHBhbmRlZCIsIk9iamVjdCIsInZhbHVlcyIsImtleXMiLCJnZXRSb3dNb2RlbCIsImdldElzRXhwYW5kZWQiLCJnZXRFeHBhbmRlZERlcHRoIiwicm93SWRzIiwicm93c0J5SWQiLCJzcGxpdElkIiwiZ2V0UHJlRXhwYW5kZWRSb3dNb2RlbCIsImdldFNvcnRlZFJvd01vZGVsIiwiZ2V0RXhwYW5kZWRSb3dNb2RlbCIsIl9nZXRFeHBhbmRlZFJvd01vZGVsIiwiY3JlYXRlUm93IiwidG9nZ2xlRXhwYW5kZWQiLCJfZXhwYW5kZWQiLCJleGlzdHMiLCJvbGRFeHBhbmRlZCIsInJvd0lkIiwiX3RhYmxlJG9wdGlvbnMkZ2V0SXNSIiwiZ2V0SXNSb3dFeHBhbmRlZCIsIl90YWJsZSRvcHRpb25zJGdldFJvdyIsIl9yb3ckc3ViUm93cyIsImdldFJvd0NhbkV4cGFuZCIsImVuYWJsZUV4cGFuZGluZyIsInN1YlJvd3MiLCJnZXRJc0FsbFBhcmVudHNFeHBhbmRlZCIsImlzRnVsbHlFeHBhbmRlZCIsImN1cnJlbnRSb3ciLCJwYXJlbnRJZCIsImdldFJvdyIsImdldFRvZ2dsZUV4cGFuZGVkSGFuZGxlciIsImNhbkV4cGFuZCIsImluY2x1ZGVzU3RyaW5nIiwiZmlsdGVyVmFsdWUiLCJfcm93JGdldFZhbHVlIiwic2VhcmNoIiwidG9Mb3dlckNhc2UiLCJnZXRWYWx1ZSIsInRvU3RyaW5nIiwiYXV0b1JlbW92ZSIsInRlc3RGYWxzZXkiLCJpbmNsdWRlc1N0cmluZ1NlbnNpdGl2ZSIsIl9yb3ckZ2V0VmFsdWUyIiwiZXF1YWxzU3RyaW5nIiwiX3JvdyRnZXRWYWx1ZTMiLCJhcnJJbmNsdWRlcyIsIl9yb3ckZ2V0VmFsdWU0IiwiYXJySW5jbHVkZXNBbGwiLCJfcm93JGdldFZhbHVlNSIsImFyckluY2x1ZGVzU29tZSIsIl9yb3ckZ2V0VmFsdWU2IiwiZXF1YWxzIiwid2Vha0VxdWFscyIsImluTnVtYmVyUmFuZ2UiLCJyb3dWYWx1ZSIsInJlc29sdmVGaWx0ZXJWYWx1ZSIsInVuc2FmZU1pbiIsInVuc2FmZU1heCIsInBhcnNlZE1pbiIsInBhcnNlRmxvYXQiLCJwYXJzZWRNYXgiLCJpc05hTiIsIkluZmluaXR5IiwidGVtcCIsImZpbHRlckZucyIsIkZpbHRlcnMiLCJmaWx0ZXJGbiIsImNvbHVtbkZpbHRlcnMiLCJnbG9iYWxGaWx0ZXIiLCJvbkNvbHVtbkZpbHRlcnNDaGFuZ2UiLCJvbkdsb2JhbEZpbHRlckNoYW5nZSIsImZpbHRlckZyb21MZWFmUm93cyIsIm1heExlYWZSb3dGaWx0ZXJEZXB0aCIsImdsb2JhbEZpbHRlckZuIiwiZ2V0Q29sdW1uQ2FuR2xvYmFsRmlsdGVyIiwiX3RhYmxlJGdldENvcmVSb3dNb2RlIiwidmFsdWUiLCJnZXRDb3JlUm93TW9kZWwiLCJfZ2V0QWxsQ2VsbHNCeUNvbHVtbklkIiwiZ2V0QXV0b0ZpbHRlckZuIiwiZmlyc3RSb3ciLCJnZXRGaWx0ZXJGbiIsIl90YWJsZSRvcHRpb25zJGZpbHRlciIsIl90YWJsZSRvcHRpb25zJGZpbHRlcjIiLCJnZXRDYW5GaWx0ZXIiLCJfdGFibGUkb3B0aW9ucyRlbmFibGUyIiwiZW5hYmxlQ29sdW1uRmlsdGVyIiwiZW5hYmxlQ29sdW1uRmlsdGVycyIsImVuYWJsZUZpbHRlcnMiLCJnZXRDYW5HbG9iYWxGaWx0ZXIiLCJfY29sdW1uJGNvbHVtbkRlZiRlbmEyIiwiX3RhYmxlJG9wdGlvbnMkZW5hYmxlMyIsIl90YWJsZSRvcHRpb25zJGVuYWJsZTQiLCJfdGFibGUkb3B0aW9ucyRnZXRDb2wiLCJlbmFibGVHbG9iYWxGaWx0ZXIiLCJnZXRJc0ZpbHRlcmVkIiwiZ2V0RmlsdGVySW5kZXgiLCJnZXRGaWx0ZXJWYWx1ZSIsIl90YWJsZSRnZXRTdGF0ZSRjb2x1bSIsIl90YWJsZSRnZXRTdGF0ZSRjb2x1bTIiLCJfdGFibGUkZ2V0U3RhdGUkY29sdW0zIiwic2V0RmlsdGVyVmFsdWUiLCJzZXRDb2x1bW5GaWx0ZXJzIiwicHJldmlvdXNmaWx0ZXIiLCJuZXdGaWx0ZXIiLCJzaG91bGRBdXRvUmVtb3ZlRmlsdGVyIiwiX29sZCRmaWx0ZXIiLCJuZXdGaWx0ZXJPYmoiLCJfb2xkJG1hcCIsIl9nZXRGYWNldGVkUm93TW9kZWwiLCJnZXRGYWNldGVkUm93TW9kZWwiLCJnZXRQcmVGaWx0ZXJlZFJvd01vZGVsIiwiX2dldEZhY2V0ZWRVbmlxdWVWYWx1ZXMiLCJnZXRGYWNldGVkVW5pcXVlVmFsdWVzIiwiTWFwIiwiX2dldEZhY2V0ZWRNaW5NYXhWYWx1ZXMiLCJnZXRGYWNldGVkTWluTWF4VmFsdWVzIiwiY29sdW1uRmlsdGVyc01ldGEiLCJnZXRHbG9iYWxBdXRvRmlsdGVyRm4iLCJnZXRHbG9iYWxGaWx0ZXJGbiIsIl90YWJsZSRvcHRpb25zJGZpbHRlcjMiLCJfdGFibGUkb3B0aW9ucyRmaWx0ZXI0IiwiZ2V0QWxsTGVhZkNvbHVtbnMiLCJ1cGRhdGVGbiIsIl9mdW5jdGlvbmFsVXBkYXRlIiwic2V0R2xvYmFsRmlsdGVyIiwicmVzZXRHbG9iYWxGaWx0ZXIiLCJyZXNldENvbHVtbkZpbHRlcnMiLCJnZXRGaWx0ZXJlZFJvd01vZGVsIiwiX2dldEZpbHRlcmVkUm93TW9kZWwiLCJtYW51YWxGaWx0ZXJpbmciLCJfZ2V0R2xvYmFsRmFjZXRlZFJvd01vZGVsIiwiZ2V0R2xvYmFsRmFjZXRlZFJvd01vZGVsIiwiX2dldEdsb2JhbEZhY2V0ZWRVbmlxdWVWYWx1ZXMiLCJnZXRHbG9iYWxGYWNldGVkVW5pcXVlVmFsdWVzIiwiX2dldEdsb2JhbEZhY2V0ZWRNaW5NYXhWYWx1ZXMiLCJnZXRHbG9iYWxGYWNldGVkTWluTWF4VmFsdWVzIiwiX2xlYWZSb3dzIiwiY2hpbGRSb3dzIiwibmV4dCIsIm5leHRWYWx1ZSIsImV4dGVudCIsIm1lYW4iLCJsZWFmUm93cyIsImNvdW50IiwibWVkaWFuIiwibWlkIiwiZmxvb3IiLCJudW1zIiwic29ydCIsImEiLCJiIiwidW5pcXVlIiwiZnJvbSIsIlNldCIsInVuaXF1ZUNvdW50IiwiX2NvbHVtbklkIiwiYWdncmVnYXRpb25GbnMiLCJHcm91cGluZyIsImFnZ3JlZ2F0ZWRDZWxsIiwicHJvcHMiLCJfdG9TdHJpbmciLCJfcHJvcHMkZ2V0VmFsdWUiLCJhZ2dyZWdhdGlvbkZuIiwiZ3JvdXBpbmciLCJvbkdyb3VwaW5nQ2hhbmdlIiwiZ3JvdXBlZENvbHVtbk1vZGUiLCJ0b2dnbGVHcm91cGluZyIsInNldEdyb3VwaW5nIiwiZ2V0Q2FuR3JvdXAiLCJlbmFibGVHcm91cGluZyIsImdldElzR3JvdXBlZCIsIl90YWJsZSRnZXRTdGF0ZSRncm91cCIsImdldEdyb3VwZWRJbmRleCIsIl90YWJsZSRnZXRTdGF0ZSRncm91cDIiLCJpbmRleE9mIiwiZ2V0VG9nZ2xlR3JvdXBpbmdIYW5kbGVyIiwiY2FuR3JvdXAiLCJnZXRBdXRvQWdncmVnYXRpb25GbiIsInByb3RvdHlwZSIsImNhbGwiLCJnZXRBZ2dyZWdhdGlvbkZuIiwiX3RhYmxlJG9wdGlvbnMkYWdncmVnIiwiX3RhYmxlJG9wdGlvbnMkYWdncmVnMiIsInJlc2V0R3JvdXBpbmciLCJfdGFibGUkaW5pdGlhbFN0YXRlJGciLCJnZXRQcmVHcm91cGVkUm93TW9kZWwiLCJnZXRHcm91cGVkUm93TW9kZWwiLCJfZ2V0R3JvdXBlZFJvd01vZGVsIiwibWFudWFsR3JvdXBpbmciLCJncm91cGluZ0NvbHVtbklkIiwiZ2V0R3JvdXBpbmdWYWx1ZSIsIl9ncm91cGluZ1ZhbHVlc0NhY2hlIiwiaGFzT3duUHJvcGVydHkiLCJvcmlnaW5hbCIsImNyZWF0ZUNlbGwiLCJjZWxsIiwiZ2V0SXNQbGFjZWhvbGRlciIsImdldElzQWdncmVnYXRlZCIsIm5vbkdyb3VwaW5nQ29sdW1ucyIsImNvbCIsImdyb3VwaW5nQ29sdW1ucyIsImciLCJPcmRlcmluZyIsImNvbHVtbk9yZGVyIiwib25Db2x1bW5PcmRlckNoYW5nZSIsInNldENvbHVtbk9yZGVyIiwicmVzZXRDb2x1bW5PcmRlciIsIm9yZGVyZWRDb2x1bW5zIiwiY29sdW1uT3JkZXJDb3B5IiwiY29sdW1uc0NvcHkiLCJ0YXJnZXRDb2x1bW5JZCIsInNoaWZ0IiwiZm91bmRJbmRleCIsInNwbGljZSIsImRlZmF1bHRQYWdlSW5kZXgiLCJkZWZhdWx0UGFnZVNpemUiLCJnZXREZWZhdWx0UGFnaW5hdGlvblN0YXRlIiwicGFnZUluZGV4IiwicGFnZVNpemUiLCJQYWdpbmF0aW9uIiwicGFnaW5hdGlvbiIsIm9uUGFnaW5hdGlvbkNoYW5nZSIsIl9hdXRvUmVzZXRQYWdlSW5kZXgiLCJhdXRvUmVzZXRQYWdlSW5kZXgiLCJtYW51YWxQYWdpbmF0aW9uIiwicmVzZXRQYWdlSW5kZXgiLCJzZXRQYWdpbmF0aW9uIiwic2FmZVVwZGF0ZXIiLCJuZXdTdGF0ZSIsInJlc2V0UGFnaW5hdGlvbiIsIl90YWJsZSRpbml0aWFsU3RhdGUkcCIsInNldFBhZ2VJbmRleCIsIm1heFBhZ2VJbmRleCIsInBhZ2VDb3VudCIsIl90YWJsZSRpbml0aWFsU3RhdGUkcDIiLCJyZXNldFBhZ2VTaXplIiwiX3RhYmxlJGluaXRpYWxTdGF0ZSRwMyIsIl90YWJsZSRpbml0aWFsU3RhdGUyIiwic2V0UGFnZVNpemUiLCJ0b3BSb3dJbmRleCIsInNldFBhZ2VDb3VudCIsIl90YWJsZSRvcHRpb25zJHBhZ2VDbyIsIm5ld1BhZ2VDb3VudCIsImdldFBhZ2VPcHRpb25zIiwiZ2V0UGFnZUNvdW50IiwicGFnZU9wdGlvbnMiLCJmaWxsIiwiaSIsImRlYnVnVGFibGUiLCJnZXRDYW5QcmV2aW91c1BhZ2UiLCJnZXRDYW5OZXh0UGFnZSIsInByZXZpb3VzUGFnZSIsIm5leHRQYWdlIiwiZ2V0UGFnaW5hdGlvblJvd01vZGVsIiwiX2dldFBhZ2luYXRpb25Sb3dNb2RlbCIsIl90YWJsZSRvcHRpb25zJHBhZ2VDbzIiLCJjZWlsIiwicm93cyIsImdldERlZmF1bHRDb2x1bW5QaW5uaW5nU3RhdGUiLCJnZXREZWZhdWx0Um93UGlubmluZ1N0YXRlIiwidG9wIiwiYm90dG9tIiwiUGlubmluZyIsInJvd1Bpbm5pbmciLCJvbkNvbHVtblBpbm5pbmdDaGFuZ2UiLCJvblJvd1Bpbm5pbmdDaGFuZ2UiLCJwaW4iLCJjb2x1bW5JZHMiLCJzZXRDb2x1bW5QaW5uaW5nIiwiX29sZCRsZWZ0MyIsIl9vbGQkcmlnaHQzIiwiX29sZCRsZWZ0IiwiX29sZCRyaWdodCIsIl9vbGQkbGVmdDIiLCJfb2xkJHJpZ2h0MiIsImdldENhblBpbiIsIl9kJGNvbHVtbkRlZiRlbmFibGVQaSIsImVuYWJsZVBpbm5pbmciLCJlbmFibGVDb2x1bW5QaW5uaW5nIiwiZ2V0SXNQaW5uZWQiLCJsZWFmQ29sdW1uSWRzIiwiaXNMZWZ0IiwiaXNSaWdodCIsImdldFBpbm5lZEluZGV4IiwiaW5jbHVkZUxlYWZSb3dzIiwiaW5jbHVkZVBhcmVudFJvd3MiLCJsZWFmUm93SWRzIiwiZ2V0TGVhZlJvd3MiLCJwYXJlbnRSb3dJZHMiLCJnZXRQYXJlbnRSb3dzIiwic2V0Um93UGlubmluZyIsIl9vbGQkdG9wMyIsIl9vbGQkYm90dG9tMyIsIl9vbGQkdG9wIiwiX29sZCRib3R0b20iLCJoYXMiLCJfb2xkJHRvcDIiLCJfb2xkJGJvdHRvbTIiLCJfcmVmNCIsImVuYWJsZVJvd1Bpbm5pbmciLCJpc1RvcCIsImlzQm90dG9tIiwiX3RhYmxlJF9nZXRQaW5uZWRSb3dzIiwiX3Zpc2libGVQaW5uZWRSb3dJZHMkIiwidmlzaWJsZVBpbm5lZFJvd0lkcyIsIl9nZXRQaW5uZWRSb3dzIiwiX3JlZjUiLCJnZXRDZW50ZXJWaXNpYmxlQ2VsbHMiLCJfZ2V0QWxsVmlzaWJsZUNlbGxzIiwiYWxsQ2VsbHMiLCJsZWZ0QW5kUmlnaHQiLCJkZWJ1Z1Jvd3MiLCJnZXRMZWZ0VmlzaWJsZUNlbGxzIiwiY2VsbHMiLCJnZXRSaWdodFZpc2libGVDZWxscyIsInJlc2V0Q29sdW1uUGlubmluZyIsImdldElzU29tZUNvbHVtbnNQaW5uZWQiLCJfcGlubmluZ1N0YXRlJHBvc2l0aW8iLCJwaW5uaW5nU3RhdGUiLCJfcGlubmluZ1N0YXRlJGxlZnQiLCJfcGlubmluZ1N0YXRlJHJpZ2h0IiwiZ2V0TGVmdExlYWZDb2x1bW5zIiwiZ2V0UmlnaHRMZWFmQ29sdW1ucyIsImdldENlbnRlckxlYWZDb2x1bW5zIiwicmVzZXRSb3dQaW5uaW5nIiwiX3RhYmxlJGluaXRpYWxTdGF0ZSRyIiwiZ2V0SXNTb21lUm93c1Bpbm5lZCIsIl9waW5uaW5nU3RhdGUkcG9zaXRpbzIiLCJfcGlubmluZ1N0YXRlJHRvcCIsIl9waW5uaW5nU3RhdGUkYm90dG9tIiwidmlzaWJsZVJvd3MiLCJwaW5uZWRSb3dJZHMiLCJfdGFibGUkb3B0aW9ucyRrZWVwUGkiLCJrZWVwUGlubmVkUm93cyIsImdldFRvcFJvd3MiLCJnZXRCb3R0b21Sb3dzIiwiZ2V0Q2VudGVyUm93cyIsImFsbFJvd3MiLCJ0b3BBbmRCb3R0b20iLCJSb3dTZWxlY3Rpb24iLCJyb3dTZWxlY3Rpb24iLCJvblJvd1NlbGVjdGlvbkNoYW5nZSIsImVuYWJsZVJvd1NlbGVjdGlvbiIsImVuYWJsZU11bHRpUm93U2VsZWN0aW9uIiwiZW5hYmxlU3ViUm93U2VsZWN0aW9uIiwic2V0Um93U2VsZWN0aW9uIiwicmVzZXRSb3dTZWxlY3Rpb24iLCJ0b2dnbGVBbGxSb3dzU2VsZWN0ZWQiLCJnZXRJc0FsbFJvd3NTZWxlY3RlZCIsInByZUdyb3VwZWRGbGF0Um93cyIsImdldENhblNlbGVjdCIsInRvZ2dsZUFsbFBhZ2VSb3dzU2VsZWN0ZWQiLCJyZXNvbHZlZFZhbHVlIiwiZ2V0SXNBbGxQYWdlUm93c1NlbGVjdGVkIiwibXV0YXRlUm93SXNTZWxlY3RlZCIsImdldFByZVNlbGVjdGVkUm93TW9kZWwiLCJnZXRTZWxlY3RlZFJvd01vZGVsIiwicm93TW9kZWwiLCJzZWxlY3RSb3dzRm4iLCJnZXRGaWx0ZXJlZFNlbGVjdGVkUm93TW9kZWwiLCJnZXRHcm91cGVkU2VsZWN0ZWRSb3dNb2RlbCIsImlzQWxsUm93c1NlbGVjdGVkIiwicGFnaW5hdGlvbkZsYXRSb3dzIiwiaXNBbGxQYWdlUm93c1NlbGVjdGVkIiwiZ2V0SXNTb21lUm93c1NlbGVjdGVkIiwiX3RhYmxlJGdldFN0YXRlJHJvd1NlIiwidG90YWxTZWxlY3RlZCIsImdldElzU29tZVBhZ2VSb3dzU2VsZWN0ZWQiLCJnZXRJc1NlbGVjdGVkIiwiZ2V0SXNTb21lU2VsZWN0ZWQiLCJnZXRUb2dnbGVBbGxSb3dzU2VsZWN0ZWRIYW5kbGVyIiwidGFyZ2V0IiwiY2hlY2tlZCIsImdldFRvZ2dsZUFsbFBhZ2VSb3dzU2VsZWN0ZWRIYW5kbGVyIiwidG9nZ2xlU2VsZWN0ZWQiLCJpc1NlbGVjdGVkIiwiX29wdHMkc2VsZWN0Q2hpbGRyZW4iLCJzZWxlY3RlZFJvd0lkcyIsInNlbGVjdENoaWxkcmVuIiwiaXNSb3dTZWxlY3RlZCIsImlzU3ViUm93U2VsZWN0ZWQiLCJnZXRJc0FsbFN1YlJvd3NTZWxlY3RlZCIsImdldENhblNlbGVjdFN1YlJvd3MiLCJnZXRDYW5NdWx0aVNlbGVjdCIsImdldFRvZ2dsZVNlbGVjdGVkSGFuZGxlciIsImNhblNlbGVjdCIsIl90YXJnZXQiLCJpbmNsdWRlQ2hpbGRyZW4iLCJuZXdTZWxlY3RlZEZsYXRSb3dzIiwibmV3U2VsZWN0ZWRSb3dzQnlJZCIsInJlY3Vyc2VSb3dzIiwiX3JvdyRzdWJSb3dzMiIsInNlbGVjdGlvbiIsIl9zZWxlY3Rpb24kcm93JGlkIiwiX3JvdyRzdWJSb3dzMyIsImFsbENoaWxkcmVuU2VsZWN0ZWQiLCJzb21lU2VsZWN0ZWQiLCJzdWJSb3ciLCJzdWJSb3dDaGlsZHJlblNlbGVjdGVkIiwicmVTcGxpdEFscGhhTnVtZXJpYyIsImFscGhhbnVtZXJpYyIsInJvd0EiLCJyb3dCIiwiY29tcGFyZUFscGhhbnVtZXJpYyIsImFscGhhbnVtZXJpY0Nhc2VTZW5zaXRpdmUiLCJ0ZXh0IiwiY29tcGFyZUJhc2ljIiwidGV4dENhc2VTZW5zaXRpdmUiLCJkYXRldGltZSIsImJhc2ljIiwiYVN0ciIsImJTdHIiLCJhYSIsImJiIiwiYW4iLCJwYXJzZUludCIsImJuIiwiY29tYm8iLCJzb3J0aW5nRm5zIiwiU29ydGluZyIsInNvcnRpbmciLCJzb3J0aW5nRm4iLCJzb3J0VW5kZWZpbmVkIiwib25Tb3J0aW5nQ2hhbmdlIiwiaXNNdWx0aVNvcnRFdmVudCIsInNoaWZ0S2V5IiwiZ2V0QXV0b1NvcnRpbmdGbiIsImZpcnN0Um93cyIsInNsaWNlIiwiaXNTdHJpbmciLCJnZXRBdXRvU29ydERpciIsImdldFNvcnRpbmdGbiIsIl90YWJsZSRvcHRpb25zJHNvcnRpbiIsIl90YWJsZSRvcHRpb25zJHNvcnRpbjIiLCJ0b2dnbGVTb3J0aW5nIiwiZGVzYyIsIm11bHRpIiwibmV4dFNvcnRpbmdPcmRlciIsImdldE5leHRTb3J0aW5nT3JkZXIiLCJoYXNNYW51YWxWYWx1ZSIsInNldFNvcnRpbmciLCJleGlzdGluZ1NvcnRpbmciLCJleGlzdGluZ0luZGV4IiwibmV3U29ydGluZyIsInNvcnRBY3Rpb24iLCJuZXh0RGVzYyIsImdldENhbk11bHRpU29ydCIsIl90YWJsZSRvcHRpb25zJG1heE11bCIsIm1heE11bHRpU29ydENvbENvdW50IiwiZ2V0Rmlyc3RTb3J0RGlyIiwiX2NvbHVtbiRjb2x1bW5EZWYkc29yIiwic29ydERlc2NGaXJzdCIsImZpcnN0U29ydERpcmVjdGlvbiIsImlzU29ydGVkIiwiZ2V0SXNTb3J0ZWQiLCJlbmFibGVTb3J0aW5nUmVtb3ZhbCIsImVuYWJsZU11bHRpUmVtb3ZlIiwiZ2V0Q2FuU29ydCIsImVuYWJsZVNvcnRpbmciLCJlbmFibGVNdWx0aVNvcnQiLCJfdGFibGUkZ2V0U3RhdGUkc29ydGkiLCJjb2x1bW5Tb3J0IiwiZ2V0U29ydEluZGV4IiwiX3RhYmxlJGdldFN0YXRlJHNvcnRpMiIsIl90YWJsZSRnZXRTdGF0ZSRzb3J0aTMiLCJjbGVhclNvcnRpbmciLCJnZXRUb2dnbGVTb3J0aW5nSGFuZGxlciIsImNhblNvcnQiLCJyZXNldFNvcnRpbmciLCJfdGFibGUkaW5pdGlhbFN0YXRlJHMiLCJnZXRQcmVTb3J0ZWRSb3dNb2RlbCIsIl9nZXRTb3J0ZWRSb3dNb2RlbCIsIm1hbnVhbFNvcnRpbmciLCJWaXNpYmlsaXR5IiwiY29sdW1uVmlzaWJpbGl0eSIsIm9uQ29sdW1uVmlzaWJpbGl0eUNoYW5nZSIsInRvZ2dsZVZpc2liaWxpdHkiLCJnZXRDYW5IaWRlIiwic2V0Q29sdW1uVmlzaWJpbGl0eSIsImVuYWJsZUhpZGluZyIsImdldFRvZ2dsZVZpc2liaWxpdHlIYW5kbGVyIiwiZ2V0QWxsQ2VsbHMiLCJnZXRWaXNpYmxlQ2VsbHMiLCJtYWtlVmlzaWJsZUNvbHVtbnNNZXRob2QiLCJnZXRDb2x1bW5zIiwiZ2V0VmlzaWJsZUZsYXRDb2x1bW5zIiwiZ2V0QWxsRmxhdENvbHVtbnMiLCJnZXRDZW50ZXJWaXNpYmxlTGVhZkNvbHVtbnMiLCJyZXNldENvbHVtblZpc2liaWxpdHkiLCJ0b2dnbGVBbGxDb2x1bW5zVmlzaWJsZSIsIl92YWx1ZSIsImdldElzQWxsQ29sdW1uc1Zpc2libGUiLCJvYmoiLCJnZXRJc1NvbWVDb2x1bW5zVmlzaWJsZSIsImdldFRvZ2dsZUFsbENvbHVtbnNWaXNpYmlsaXR5SGFuZGxlciIsImZlYXR1cmVzIiwiX29wdGlvbnMkaW5pdGlhbFN0YXRlIiwiZGVmYXVsdE9wdGlvbnMiLCJhc3NpZ24iLCJtZXJnZU9wdGlvbnMiLCJjb3JlSW5pdGlhbFN0YXRlIiwiX2ZlYXR1cmUkZ2V0SW5pdGlhbFN0IiwicXVldWVkVGltZW91dCIsImNvcmVJbnN0YW5jZSIsImNiIiwiUHJvbWlzZSIsInJlc29sdmUiLCJ0aGVuIiwiY2F0Y2giLCJlcnJvciIsInNldFRpbWVvdXQiLCJyZXNldCIsInNldE9wdGlvbnMiLCJuZXdPcHRpb25zIiwib25TdGF0ZUNoYW5nZSIsIl9nZXRSb3dJZCIsImdldFJvd0lkIiwiX2dldENvcmVSb3dNb2RlbCIsInNlYXJjaEFsbCIsIl9kZWZhdWx0Q29sdW1uIiwiX3Byb3BzJHJlbmRlclZhbHVlJHRvIiwiX3Byb3BzJHJlbmRlclZhbHVlIiwicmVuZGVyVmFsdWUiLCJfZ2V0Q29sdW1uRGVmcyIsImNvbHVtbkRlZnMiLCJyZWN1cnNlQ29sdW1ucyIsImdyb3VwaW5nQ29sdW1uRGVmIiwiX2dldEFsbEZsYXRDb2x1bW5zQnlJZCIsImZsYXRDb2x1bW5zIiwiYWNjIiwiZ2V0UmVuZGVyVmFsdWUiLCJfY2VsbCRnZXRWYWx1ZSIsInJlbmRlckZhbGxiYWNrVmFsdWUiLCJyb3dJbmRleCIsIl92YWx1ZXNDYWNoZSIsIl91bmlxdWVWYWx1ZXNDYWNoZSIsImdldFVuaXF1ZVZhbHVlcyIsImdldFBhcmVudFJvdyIsInBhcmVudFJvd3MiLCJwYXJlbnRSb3ciLCJjcmVhdGVDb2x1bW5IZWxwZXIiLCJhY2Nlc3NvciIsImRpc3BsYXkiLCJncm91cCIsImRhdGEiLCJhY2Nlc3NSb3dzIiwib3JpZ2luYWxSb3dzIiwiZ2V0U3ViUm93cyIsIl9yb3ckb3JpZ2luYWxTdWJSb3dzIiwib3JpZ2luYWxTdWJSb3dzIiwiZmlsdGVyUm93cyIsImZpbHRlclJvd0ltcGwiLCJmaWx0ZXJSb3dNb2RlbEZyb21MZWFmcyIsImZpbHRlclJvd01vZGVsRnJvbVJvb3QiLCJyb3dzVG9GaWx0ZXIiLCJmaWx0ZXJSb3ciLCJfdGFibGUkb3B0aW9ucyRtYXhMZWEiLCJuZXdGaWx0ZXJlZEZsYXRSb3dzIiwibmV3RmlsdGVyZWRSb3dzQnlJZCIsInJlY3Vyc2VGaWx0ZXJSb3dzIiwibmV3Um93IiwiX3RhYmxlJG9wdGlvbnMkbWF4TGVhMiIsInBhc3MiLCJyZXNvbHZlZENvbHVtbkZpbHRlcnMiLCJyZXNvbHZlZEdsb2JhbEZpbHRlcnMiLCJfZmlsdGVyRm4kcmVzb2x2ZUZpbHQiLCJmaWx0ZXJhYmxlSWRzIiwiZ2xvYmFsbHlGaWx0ZXJhYmxlQ29sdW1ucyIsIl9nbG9iYWxGaWx0ZXJGbiRyZXNvbCIsImN1cnJlbnRDb2x1bW5GaWx0ZXIiLCJjdXJyZW50R2xvYmFsRmlsdGVyIiwiaiIsImZpbHRlck1ldGEiLCJfX2dsb2JhbF9fIiwiZmlsdGVyUm93c0ltcGwiLCJwcmVSb3dNb2RlbCIsIl90YWJsZSRnZXRDb2x1bW4iLCJmYWNldGVkUm93TW9kZWwiLCJmYWNldGVkVW5pcXVlVmFsdWVzIiwiX2ZhY2V0ZWRVbmlxdWVWYWx1ZXMkIiwic2V0IiwiZ2V0IiwiX2ZhY2V0ZWRSb3dNb2RlbCRmbGF0IiwiZmlyc3RWYWx1ZSIsImZhY2V0ZWRNaW5NYXhWYWx1ZXMiLCJzb3J0aW5nU3RhdGUiLCJzb3J0ZWRGbGF0Um93cyIsImF2YWlsYWJsZVNvcnRpbmciLCJjb2x1bW5JbmZvQnlJZCIsInNvcnRFbnRyeSIsImludmVydFNvcnRpbmciLCJzb3J0RGF0YSIsInNvcnRlZERhdGEiLCJfc29ydEVudHJ5JGRlc2MiLCJjb2x1bW5JbmZvIiwiaXNEZXNjIiwic29ydEludCIsImFWYWx1ZSIsImJWYWx1ZSIsImFVbmRlZmluZWQiLCJiVW5kZWZpbmVkIiwiZXhpc3RpbmdHcm91cGluZyIsImdyb3VwZWRGbGF0Um93cyIsImdyb3VwZWRSb3dzQnlJZCIsImdyb3VwVXBSZWN1cnNpdmVseSIsInJvd0dyb3Vwc01hcCIsImdyb3VwQnkiLCJhZ2dyZWdhdGVkR3JvdXBlZFJvd3MiLCJlbnRyaWVzIiwiZ3JvdXBpbmdWYWx1ZSIsImdyb3VwZWRSb3dzIiwiX2dyb3VwZWRSb3dzJDAkZ2V0VmFsIiwiYWdncmVnYXRlRm4iLCJncm91cE1hcCIsInJlc0tleSIsInByZXZpb3VzIiwiZXhwYW5kUm93cyIsImV4cGFuZGVkUm93cyIsImhhbmRsZVJvdyIsInBhZ2VTdGFydCIsInBhZ2VFbmQiLCJwYWdpbmF0ZWRSb3dNb2RlbCJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@tanstack/table-core/build/lib/index.mjs\n");

/***/ }),

/***/ "(ssr)/./node_modules/@tanstack/virtual-core/build/lib/_virtual/_rollupPluginBabelHelpers.mjs":
/*!**********************************************************************************************!*\
  !*** ./node_modules/@tanstack/virtual-core/build/lib/_virtual/_rollupPluginBabelHelpers.mjs ***!
  \**********************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"extends\": () => (/* binding */ _extends)\n/* harmony export */ });\n/**\n * virtual-core\n *\n * Copyright (c) TanStack\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE.md file in the root directory of this source tree.\n *\n * @license MIT\n */ function _extends() {\n    _extends = Object.assign ? Object.assign.bind() : function(target) {\n        for(var i = 1; i < arguments.length; i++){\n            var source = arguments[i];\n            for(var key in source){\n                if (Object.prototype.hasOwnProperty.call(source, key)) {\n                    target[key] = source[key];\n                }\n            }\n        }\n        return target;\n    };\n    return _extends.apply(this, arguments);\n}\n //# sourceMappingURL=_rollupPluginBabelHelpers.mjs.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQHRhbnN0YWNrL3ZpcnR1YWwtY29yZS9idWlsZC9saWIvX3ZpcnR1YWwvX3JvbGx1cFBsdWdpbkJhYmVsSGVscGVycy5tanMiLCJtYXBwaW5ncyI6Ijs7OztBQUFBOzs7Ozs7Ozs7Q0FTQyxHQUNELFNBQVNBO0lBQ1BBLFdBQVdDLE9BQU9DLE1BQU0sR0FBR0QsT0FBT0MsTUFBTSxDQUFDQyxJQUFJLEtBQUssU0FBVUMsTUFBTTtRQUNoRSxJQUFLLElBQUlDLElBQUksR0FBR0EsSUFBSUMsVUFBVUMsTUFBTSxFQUFFRixJQUFLO1lBQ3pDLElBQUlHLFNBQVNGLFNBQVMsQ0FBQ0QsRUFBRTtZQUN6QixJQUFLLElBQUlJLE9BQU9ELE9BQVE7Z0JBQ3RCLElBQUlQLE9BQU9TLFNBQVMsQ0FBQ0MsY0FBYyxDQUFDQyxJQUFJLENBQUNKLFFBQVFDLE1BQU07b0JBQ3JETCxNQUFNLENBQUNLLElBQUksR0FBR0QsTUFBTSxDQUFDQyxJQUFJO2dCQUMzQjtZQUNGO1FBQ0Y7UUFDQSxPQUFPTDtJQUNUO0lBQ0EsT0FBT0osU0FBU2EsS0FBSyxDQUFDLElBQUksRUFBRVA7QUFDOUI7QUFFK0IsQ0FDL0Isc0RBQXNEIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vdmlzaW9uLy4vbm9kZV9tb2R1bGVzL0B0YW5zdGFjay92aXJ0dWFsLWNvcmUvYnVpbGQvbGliL192aXJ0dWFsL19yb2xsdXBQbHVnaW5CYWJlbEhlbHBlcnMubWpzPzhhYmYiXSwic291cmNlc0NvbnRlbnQiOlsiLyoqXG4gKiB2aXJ0dWFsLWNvcmVcbiAqXG4gKiBDb3B5cmlnaHQgKGMpIFRhblN0YWNrXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgTUlUIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFLm1kIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuXG4gKlxuICogQGxpY2Vuc2UgTUlUXG4gKi9cbmZ1bmN0aW9uIF9leHRlbmRzKCkge1xuICBfZXh0ZW5kcyA9IE9iamVjdC5hc3NpZ24gPyBPYmplY3QuYXNzaWduLmJpbmQoKSA6IGZ1bmN0aW9uICh0YXJnZXQpIHtcbiAgICBmb3IgKHZhciBpID0gMTsgaSA8IGFyZ3VtZW50cy5sZW5ndGg7IGkrKykge1xuICAgICAgdmFyIHNvdXJjZSA9IGFyZ3VtZW50c1tpXTtcbiAgICAgIGZvciAodmFyIGtleSBpbiBzb3VyY2UpIHtcbiAgICAgICAgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChzb3VyY2UsIGtleSkpIHtcbiAgICAgICAgICB0YXJnZXRba2V5XSA9IHNvdXJjZVtrZXldO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiB0YXJnZXQ7XG4gIH07XG4gIHJldHVybiBfZXh0ZW5kcy5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xufVxuXG5leHBvcnQgeyBfZXh0ZW5kcyBhcyBleHRlbmRzIH07XG4vLyMgc291cmNlTWFwcGluZ1VSTD1fcm9sbHVwUGx1Z2luQmFiZWxIZWxwZXJzLm1qcy5tYXBcbiJdLCJuYW1lcyI6WyJfZXh0ZW5kcyIsIk9iamVjdCIsImFzc2lnbiIsImJpbmQiLCJ0YXJnZXQiLCJpIiwiYXJndW1lbnRzIiwibGVuZ3RoIiwic291cmNlIiwia2V5IiwicHJvdG90eXBlIiwiaGFzT3duUHJvcGVydHkiLCJjYWxsIiwiYXBwbHkiLCJleHRlbmRzIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@tanstack/virtual-core/build/lib/_virtual/_rollupPluginBabelHelpers.mjs\n");

/***/ }),

/***/ "(ssr)/./node_modules/@tanstack/virtual-core/build/lib/index.mjs":
/*!*****************************************************************!*\
  !*** ./node_modules/@tanstack/virtual-core/build/lib/index.mjs ***!
  \*****************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   Virtualizer: () => (/* binding */ Virtualizer),\n/* harmony export */   approxEqual: () => (/* reexport safe */ _utils_mjs__WEBPACK_IMPORTED_MODULE_0__.approxEqual),\n/* harmony export */   defaultKeyExtractor: () => (/* binding */ defaultKeyExtractor),\n/* harmony export */   defaultRangeExtractor: () => (/* binding */ defaultRangeExtractor),\n/* harmony export */   elementScroll: () => (/* binding */ elementScroll),\n/* harmony export */   measureElement: () => (/* binding */ measureElement),\n/* harmony export */   memo: () => (/* reexport safe */ _utils_mjs__WEBPACK_IMPORTED_MODULE_0__.memo),\n/* harmony export */   notUndefined: () => (/* reexport safe */ _utils_mjs__WEBPACK_IMPORTED_MODULE_0__.notUndefined),\n/* harmony export */   observeElementOffset: () => (/* binding */ observeElementOffset),\n/* harmony export */   observeElementRect: () => (/* binding */ observeElementRect),\n/* harmony export */   observeWindowOffset: () => (/* binding */ observeWindowOffset),\n/* harmony export */   observeWindowRect: () => (/* binding */ observeWindowRect),\n/* harmony export */   windowScroll: () => (/* binding */ windowScroll)\n/* harmony export */ });\n/* harmony import */ var _virtual_rollupPluginBabelHelpers_mjs__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./_virtual/_rollupPluginBabelHelpers.mjs */ \"(ssr)/./node_modules/@tanstack/virtual-core/build/lib/_virtual/_rollupPluginBabelHelpers.mjs\");\n/* harmony import */ var _utils_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./utils.mjs */ \"(ssr)/./node_modules/@tanstack/virtual-core/build/lib/utils.mjs\");\n/**\n * virtual-core\n *\n * Copyright (c) TanStack\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE.md file in the root directory of this source tree.\n *\n * @license MIT\n */ \n\n\n//\n//\nvar defaultKeyExtractor = function defaultKeyExtractor(index) {\n    return index;\n};\nvar defaultRangeExtractor = function defaultRangeExtractor(range) {\n    var start = Math.max(range.startIndex - range.overscan, 0);\n    var end = Math.min(range.endIndex + range.overscan, range.count - 1);\n    var arr = [];\n    for(var _i = start; _i <= end; _i++){\n        arr.push(_i);\n    }\n    return arr;\n};\nvar observeElementRect = function observeElementRect(instance, cb) {\n    var element = instance.scrollElement;\n    if (!element) {\n        return;\n    }\n    var handler = function handler(rect) {\n        var width = rect.width, height = rect.height;\n        cb({\n            width: Math.round(width),\n            height: Math.round(height)\n        });\n    };\n    handler(element.getBoundingClientRect());\n    var observer = new ResizeObserver(function(entries) {\n        var entry = entries[0];\n        if (entry != null && entry.borderBoxSize) {\n            var box = entry.borderBoxSize[0];\n            if (box) {\n                handler({\n                    width: box.inlineSize,\n                    height: box.blockSize\n                });\n                return;\n            }\n        }\n        handler(element.getBoundingClientRect());\n    });\n    observer.observe(element, {\n        box: \"border-box\"\n    });\n    return function() {\n        observer.unobserve(element);\n    };\n};\nvar observeWindowRect = function observeWindowRect(instance, cb) {\n    var element = instance.scrollElement;\n    if (!element) {\n        return;\n    }\n    var handler = function handler() {\n        cb({\n            width: element.innerWidth,\n            height: element.innerHeight\n        });\n    };\n    handler();\n    element.addEventListener(\"resize\", handler, {\n        passive: true\n    });\n    return function() {\n        element.removeEventListener(\"resize\", handler);\n    };\n};\nvar observeElementOffset = function observeElementOffset(instance, cb) {\n    var element = instance.scrollElement;\n    if (!element) {\n        return;\n    }\n    var handler = function handler() {\n        cb(element[instance.options.horizontal ? \"scrollLeft\" : \"scrollTop\"]);\n    };\n    handler();\n    element.addEventListener(\"scroll\", handler, {\n        passive: true\n    });\n    return function() {\n        element.removeEventListener(\"scroll\", handler);\n    };\n};\nvar observeWindowOffset = function observeWindowOffset(instance, cb) {\n    var element = instance.scrollElement;\n    if (!element) {\n        return;\n    }\n    var handler = function handler() {\n        cb(element[instance.options.horizontal ? \"scrollX\" : \"scrollY\"]);\n    };\n    handler();\n    element.addEventListener(\"scroll\", handler, {\n        passive: true\n    });\n    return function() {\n        element.removeEventListener(\"scroll\", handler);\n    };\n};\nvar measureElement = function measureElement(element, entry, instance) {\n    if (entry != null && entry.borderBoxSize) {\n        var box = entry.borderBoxSize[0];\n        if (box) {\n            var size = Math.round(box[instance.options.horizontal ? \"inlineSize\" : \"blockSize\"]);\n            return size;\n        }\n    }\n    return Math.round(element.getBoundingClientRect()[instance.options.horizontal ? \"width\" : \"height\"]);\n};\nvar windowScroll = function windowScroll(offset, _ref, instance) {\n    var _instance$scrollEleme, _instance$scrollEleme2;\n    var _ref$adjustments = _ref.adjustments, adjustments = _ref$adjustments === void 0 ? 0 : _ref$adjustments, behavior = _ref.behavior;\n    var toOffset = offset + adjustments;\n    (_instance$scrollEleme = instance.scrollElement) == null || _instance$scrollEleme.scrollTo == null || _instance$scrollEleme.scrollTo((_instance$scrollEleme2 = {}, _instance$scrollEleme2[instance.options.horizontal ? \"left\" : \"top\"] = toOffset, _instance$scrollEleme2.behavior = behavior, _instance$scrollEleme2));\n};\nvar elementScroll = function elementScroll(offset, _ref2, instance) {\n    var _instance$scrollEleme3, _instance$scrollEleme4;\n    var _ref2$adjustments = _ref2.adjustments, adjustments = _ref2$adjustments === void 0 ? 0 : _ref2$adjustments, behavior = _ref2.behavior;\n    var toOffset = offset + adjustments;\n    (_instance$scrollEleme3 = instance.scrollElement) == null || _instance$scrollEleme3.scrollTo == null || _instance$scrollEleme3.scrollTo((_instance$scrollEleme4 = {}, _instance$scrollEleme4[instance.options.horizontal ? \"left\" : \"top\"] = toOffset, _instance$scrollEleme4.behavior = behavior, _instance$scrollEleme4));\n};\nvar Virtualizer = function Virtualizer(_opts) {\n    var _this = this;\n    this.unsubs = [];\n    this.scrollElement = null;\n    this.isScrolling = false;\n    this.isScrollingTimeoutId = null;\n    this.scrollToIndexTimeoutId = null;\n    this.measurementsCache = [];\n    this.itemSizeCache = new Map();\n    this.pendingMeasuredCacheIndexes = [];\n    this.scrollDirection = null;\n    this.scrollAdjustments = 0;\n    this.measureElementCache = new Map();\n    this.observer = function() {\n        var _ro = null;\n        var get = function get() {\n            if (_ro) {\n                return _ro;\n            } else if (typeof ResizeObserver !== \"undefined\") {\n                return _ro = new ResizeObserver(function(entries) {\n                    entries.forEach(function(entry) {\n                        _this._measureElement(entry.target, entry);\n                    });\n                });\n            } else {\n                return null;\n            }\n        };\n        return {\n            disconnect: function disconnect() {\n                var _get;\n                return (_get = get()) == null ? void 0 : _get.disconnect();\n            },\n            observe: function observe(target) {\n                var _get2;\n                return (_get2 = get()) == null ? void 0 : _get2.observe(target, {\n                    box: \"border-box\"\n                });\n            },\n            unobserve: function unobserve(target) {\n                var _get3;\n                return (_get3 = get()) == null ? void 0 : _get3.unobserve(target);\n            }\n        };\n    }();\n    this.range = null;\n    this.setOptions = function(opts) {\n        Object.entries(opts).forEach(function(_ref3) {\n            var key = _ref3[0], value = _ref3[1];\n            if (typeof value === \"undefined\") delete opts[key];\n        });\n        _this.options = (0,_virtual_rollupPluginBabelHelpers_mjs__WEBPACK_IMPORTED_MODULE_1__[\"extends\"])({\n            debug: false,\n            initialOffset: 0,\n            overscan: 1,\n            paddingStart: 0,\n            paddingEnd: 0,\n            scrollPaddingStart: 0,\n            scrollPaddingEnd: 0,\n            horizontal: false,\n            getItemKey: defaultKeyExtractor,\n            rangeExtractor: defaultRangeExtractor,\n            onChange: function onChange() {},\n            measureElement: measureElement,\n            initialRect: {\n                width: 0,\n                height: 0\n            },\n            scrollMargin: 0,\n            scrollingDelay: 150,\n            indexAttribute: \"data-index\",\n            initialMeasurementsCache: [],\n            lanes: 1\n        }, opts);\n    };\n    this.notify = function(sync) {\n        _this.options.onChange == null || _this.options.onChange(_this, sync);\n    };\n    this.maybeNotify = (0,_utils_mjs__WEBPACK_IMPORTED_MODULE_0__.memo)(function() {\n        _this.calculateRange();\n        return [\n            _this.isScrolling,\n            _this.range ? _this.range.startIndex : null,\n            _this.range ? _this.range.endIndex : null\n        ];\n    }, function(isScrolling) {\n        _this.notify(isScrolling);\n    }, {\n        key:  true && \"maybeNotify\",\n        debug: function debug() {\n            return _this.options.debug;\n        },\n        initialDeps: [\n            this.isScrolling,\n            this.range ? this.range.startIndex : null,\n            this.range ? this.range.endIndex : null\n        ]\n    });\n    this.cleanup = function() {\n        _this.unsubs.filter(Boolean).forEach(function(d) {\n            return d();\n        });\n        _this.unsubs = [];\n        _this.scrollElement = null;\n    };\n    this._didMount = function() {\n        _this.measureElementCache.forEach(_this.observer.observe);\n        return function() {\n            _this.observer.disconnect();\n            _this.cleanup();\n        };\n    };\n    this._willUpdate = function() {\n        var scrollElement = _this.options.getScrollElement();\n        if (_this.scrollElement !== scrollElement) {\n            _this.cleanup();\n            _this.scrollElement = scrollElement;\n            _this._scrollToOffset(_this.scrollOffset, {\n                adjustments: undefined,\n                behavior: undefined\n            });\n            _this.unsubs.push(_this.options.observeElementRect(_this, function(rect) {\n                _this.scrollRect = rect;\n                _this.maybeNotify();\n            }));\n            _this.unsubs.push(_this.options.observeElementOffset(_this, function(offset) {\n                _this.scrollAdjustments = 0;\n                if (_this.scrollOffset === offset) {\n                    return;\n                }\n                if (_this.isScrollingTimeoutId !== null) {\n                    clearTimeout(_this.isScrollingTimeoutId);\n                    _this.isScrollingTimeoutId = null;\n                }\n                _this.isScrolling = true;\n                _this.scrollDirection = _this.scrollOffset < offset ? \"forward\" : \"backward\";\n                _this.scrollOffset = offset;\n                _this.maybeNotify();\n                _this.isScrollingTimeoutId = setTimeout(function() {\n                    _this.isScrollingTimeoutId = null;\n                    _this.isScrolling = false;\n                    _this.scrollDirection = null;\n                    _this.maybeNotify();\n                }, _this.options.scrollingDelay);\n            }));\n        }\n    };\n    this.getSize = function() {\n        return _this.scrollRect[_this.options.horizontal ? \"width\" : \"height\"];\n    };\n    this.memoOptions = (0,_utils_mjs__WEBPACK_IMPORTED_MODULE_0__.memo)(function() {\n        return [\n            _this.options.count,\n            _this.options.paddingStart,\n            _this.options.scrollMargin,\n            _this.options.getItemKey\n        ];\n    }, function(count, paddingStart, scrollMargin, getItemKey) {\n        _this.pendingMeasuredCacheIndexes = [];\n        return {\n            count: count,\n            paddingStart: paddingStart,\n            scrollMargin: scrollMargin,\n            getItemKey: getItemKey\n        };\n    }, {\n        key: false\n    });\n    this.getFurthestMeasurement = function(measurements, index) {\n        var furthestMeasurementsFound = new Map();\n        var furthestMeasurements = new Map();\n        for(var m = index - 1; m >= 0; m--){\n            var measurement = measurements[m];\n            if (furthestMeasurementsFound.has(measurement.lane)) {\n                continue;\n            }\n            var previousFurthestMeasurement = furthestMeasurements.get(measurement.lane);\n            if (previousFurthestMeasurement == null || measurement.end > previousFurthestMeasurement.end) {\n                furthestMeasurements.set(measurement.lane, measurement);\n            } else if (measurement.end < previousFurthestMeasurement.end) {\n                furthestMeasurementsFound.set(measurement.lane, true);\n            }\n            if (furthestMeasurementsFound.size === _this.options.lanes) {\n                break;\n            }\n        }\n        return furthestMeasurements.size === _this.options.lanes ? Array.from(furthestMeasurements.values()).sort(function(a, b) {\n            return a.end - b.end;\n        })[0] : undefined;\n    };\n    this.getMeasurements = (0,_utils_mjs__WEBPACK_IMPORTED_MODULE_0__.memo)(function() {\n        return [\n            _this.memoOptions(),\n            _this.itemSizeCache\n        ];\n    }, function(_ref4, itemSizeCache) {\n        var count = _ref4.count, paddingStart = _ref4.paddingStart, scrollMargin = _ref4.scrollMargin, getItemKey = _ref4.getItemKey;\n        var min = _this.pendingMeasuredCacheIndexes.length > 0 ? Math.min.apply(Math, _this.pendingMeasuredCacheIndexes) : 0;\n        _this.pendingMeasuredCacheIndexes = [];\n        var measurements = _this.measurementsCache.slice(0, min);\n        for(var _i2 = min; _i2 < count; _i2++){\n            var key = getItemKey(_i2);\n            var furthestMeasurement = _this.options.lanes === 1 ? measurements[_i2 - 1] : _this.getFurthestMeasurement(measurements, _i2);\n            var start = furthestMeasurement ? furthestMeasurement.end : paddingStart + scrollMargin;\n            var measuredSize = itemSizeCache.get(key);\n            var size = typeof measuredSize === \"number\" ? measuredSize : _this.options.estimateSize(_i2);\n            var end = start + size;\n            var lane = furthestMeasurement ? furthestMeasurement.lane : _i2 % _this.options.lanes;\n            measurements[_i2] = {\n                index: _i2,\n                start: start,\n                size: size,\n                end: end,\n                key: key,\n                lane: lane\n            };\n        }\n        _this.measurementsCache = measurements;\n        return measurements;\n    }, {\n        key:  true && \"getMeasurements\",\n        debug: function debug() {\n            return _this.options.debug;\n        }\n    });\n    this.calculateRange = (0,_utils_mjs__WEBPACK_IMPORTED_MODULE_0__.memo)(function() {\n        return [\n            _this.getMeasurements(),\n            _this.getSize(),\n            _this.scrollOffset\n        ];\n    }, function(measurements, outerSize, scrollOffset) {\n        return _this.range = measurements.length > 0 && outerSize > 0 ? calculateRange({\n            measurements: measurements,\n            outerSize: outerSize,\n            scrollOffset: scrollOffset\n        }) : null;\n    }, {\n        key:  true && \"calculateRange\",\n        debug: function debug() {\n            return _this.options.debug;\n        }\n    });\n    this.getIndexes = (0,_utils_mjs__WEBPACK_IMPORTED_MODULE_0__.memo)(function() {\n        return [\n            _this.options.rangeExtractor,\n            _this.calculateRange(),\n            _this.options.overscan,\n            _this.options.count\n        ];\n    }, function(rangeExtractor, range, overscan, count) {\n        return range === null ? [] : rangeExtractor((0,_virtual_rollupPluginBabelHelpers_mjs__WEBPACK_IMPORTED_MODULE_1__[\"extends\"])({}, range, {\n            overscan: overscan,\n            count: count\n        }));\n    }, {\n        key:  true && \"getIndexes\",\n        debug: function debug() {\n            return _this.options.debug;\n        }\n    });\n    this.indexFromElement = function(node) {\n        var attributeName = _this.options.indexAttribute;\n        var indexStr = node.getAttribute(attributeName);\n        if (!indexStr) {\n            console.warn(\"Missing attribute name '\" + attributeName + \"={index}' on measured element.\");\n            return -1;\n        }\n        return parseInt(indexStr, 10);\n    };\n    this._measureElement = function(node, entry) {\n        var item = _this.measurementsCache[_this.indexFromElement(node)];\n        if (!item || !node.isConnected) {\n            _this.measureElementCache.forEach(function(cached, key) {\n                if (cached === node) {\n                    _this.observer.unobserve(node);\n                    _this.measureElementCache[\"delete\"](key);\n                }\n            });\n            return;\n        }\n        var prevNode = _this.measureElementCache.get(item.key);\n        if (prevNode !== node) {\n            if (prevNode) {\n                _this.observer.unobserve(prevNode);\n            }\n            _this.observer.observe(node);\n            _this.measureElementCache.set(item.key, node);\n        }\n        var measuredItemSize = _this.options.measureElement(node, entry, _this);\n        _this.resizeItem(item, measuredItemSize);\n    };\n    this.resizeItem = function(item, size) {\n        var _this$itemSizeCache$g;\n        var itemSize = (_this$itemSizeCache$g = _this.itemSizeCache.get(item.key)) != null ? _this$itemSizeCache$g : item.size;\n        var delta = size - itemSize;\n        if (delta !== 0) {\n            if (item.start < _this.scrollOffset) {\n                if ( true && _this.options.debug) {\n                    console.info(\"correction\", delta);\n                }\n                _this._scrollToOffset(_this.scrollOffset, {\n                    adjustments: _this.scrollAdjustments += delta,\n                    behavior: undefined\n                });\n            }\n            _this.pendingMeasuredCacheIndexes.push(item.index);\n            _this.itemSizeCache = new Map(_this.itemSizeCache.set(item.key, size));\n            _this.notify(false);\n        }\n    };\n    this.measureElement = function(node) {\n        if (!node) {\n            return;\n        }\n        _this._measureElement(node, undefined);\n    };\n    this.getVirtualItems = (0,_utils_mjs__WEBPACK_IMPORTED_MODULE_0__.memo)(function() {\n        return [\n            _this.getIndexes(),\n            _this.getMeasurements()\n        ];\n    }, function(indexes, measurements) {\n        var virtualItems = [];\n        for(var k = 0, len = indexes.length; k < len; k++){\n            var _i3 = indexes[k];\n            var measurement = measurements[_i3];\n            virtualItems.push(measurement);\n        }\n        return virtualItems;\n    }, {\n        key:  true && \"getIndexes\",\n        debug: function debug() {\n            return _this.options.debug;\n        }\n    });\n    this.getVirtualItemForOffset = function(offset) {\n        var measurements = _this.getMeasurements();\n        return (0,_utils_mjs__WEBPACK_IMPORTED_MODULE_0__.notUndefined)(measurements[findNearestBinarySearch(0, measurements.length - 1, function(index) {\n            return (0,_utils_mjs__WEBPACK_IMPORTED_MODULE_0__.notUndefined)(measurements[index]).start;\n        }, offset)]);\n    };\n    this.getOffsetForAlignment = function(toOffset, align) {\n        var size = _this.getSize();\n        if (align === \"auto\") {\n            if (toOffset <= _this.scrollOffset) {\n                align = \"start\";\n            } else if (toOffset >= _this.scrollOffset + size) {\n                align = \"end\";\n            } else {\n                align = \"start\";\n            }\n        }\n        if (align === \"start\") {\n            toOffset = toOffset;\n        } else if (align === \"end\") {\n            toOffset = toOffset - size;\n        } else if (align === \"center\") {\n            toOffset = toOffset - size / 2;\n        }\n        var scrollSizeProp = _this.options.horizontal ? \"scrollWidth\" : \"scrollHeight\";\n        var scrollSize = _this.scrollElement ? \"document\" in _this.scrollElement ? _this.scrollElement.document.documentElement[scrollSizeProp] : _this.scrollElement[scrollSizeProp] : 0;\n        var maxOffset = scrollSize - _this.getSize();\n        return Math.max(Math.min(maxOffset, toOffset), 0);\n    };\n    this.getOffsetForIndex = function(index, align) {\n        if (align === void 0) {\n            align = \"auto\";\n        }\n        index = Math.max(0, Math.min(index, _this.options.count - 1));\n        var measurement = (0,_utils_mjs__WEBPACK_IMPORTED_MODULE_0__.notUndefined)(_this.getMeasurements()[index]);\n        if (align === \"auto\") {\n            if (measurement.end >= _this.scrollOffset + _this.getSize() - _this.options.scrollPaddingEnd) {\n                align = \"end\";\n            } else if (measurement.start <= _this.scrollOffset + _this.options.scrollPaddingStart) {\n                align = \"start\";\n            } else {\n                return [\n                    _this.scrollOffset,\n                    align\n                ];\n            }\n        }\n        var toOffset = align === \"end\" ? measurement.end + _this.options.scrollPaddingEnd : measurement.start - _this.options.scrollPaddingStart;\n        return [\n            _this.getOffsetForAlignment(toOffset, align),\n            align\n        ];\n    };\n    this.isDynamicMode = function() {\n        return _this.measureElementCache.size > 0;\n    };\n    this.cancelScrollToIndex = function() {\n        if (_this.scrollToIndexTimeoutId !== null) {\n            clearTimeout(_this.scrollToIndexTimeoutId);\n            _this.scrollToIndexTimeoutId = null;\n        }\n    };\n    this.scrollToOffset = function(toOffset, _temp) {\n        var _ref5 = _temp === void 0 ? {} : _temp, _ref5$align = _ref5.align, align = _ref5$align === void 0 ? \"start\" : _ref5$align, behavior = _ref5.behavior;\n        _this.cancelScrollToIndex();\n        if (behavior === \"smooth\" && _this.isDynamicMode()) {\n            console.warn(\"The `smooth` scroll behavior is not fully supported with dynamic size.\");\n        }\n        _this._scrollToOffset(_this.getOffsetForAlignment(toOffset, align), {\n            adjustments: undefined,\n            behavior: behavior\n        });\n    };\n    this.scrollToIndex = function(index, _temp2) {\n        var _ref6 = _temp2 === void 0 ? {} : _temp2, _ref6$align = _ref6.align, initialAlign = _ref6$align === void 0 ? \"auto\" : _ref6$align, behavior = _ref6.behavior;\n        index = Math.max(0, Math.min(index, _this.options.count - 1));\n        _this.cancelScrollToIndex();\n        if (behavior === \"smooth\" && _this.isDynamicMode()) {\n            console.warn(\"The `smooth` scroll behavior is not fully supported with dynamic size.\");\n        }\n        var _this$getOffsetForInd = _this.getOffsetForIndex(index, initialAlign), toOffset = _this$getOffsetForInd[0], align = _this$getOffsetForInd[1];\n        _this._scrollToOffset(toOffset, {\n            adjustments: undefined,\n            behavior: behavior\n        });\n        if (behavior !== \"smooth\" && _this.isDynamicMode()) {\n            _this.scrollToIndexTimeoutId = setTimeout(function() {\n                _this.scrollToIndexTimeoutId = null;\n                var elementInDOM = _this.measureElementCache.has(_this.options.getItemKey(index));\n                if (elementInDOM) {\n                    var _this$getOffsetForInd2 = _this.getOffsetForIndex(index, align), _toOffset = _this$getOffsetForInd2[0];\n                    if (!(0,_utils_mjs__WEBPACK_IMPORTED_MODULE_0__.approxEqual)(_toOffset, _this.scrollOffset)) {\n                        _this.scrollToIndex(index, {\n                            align: align,\n                            behavior: behavior\n                        });\n                    }\n                } else {\n                    _this.scrollToIndex(index, {\n                        align: align,\n                        behavior: behavior\n                    });\n                }\n            });\n        }\n    };\n    this.scrollBy = function(delta, _temp3) {\n        var _ref7 = _temp3 === void 0 ? {} : _temp3, behavior = _ref7.behavior;\n        _this.cancelScrollToIndex();\n        if (behavior === \"smooth\" && _this.isDynamicMode()) {\n            console.warn(\"The `smooth` scroll behavior is not fully supported with dynamic size.\");\n        }\n        _this._scrollToOffset(_this.scrollOffset + delta, {\n            adjustments: undefined,\n            behavior: behavior\n        });\n    };\n    this.getTotalSize = function() {\n        var _this$getMeasurements;\n        return (((_this$getMeasurements = _this.getMeasurements()[_this.options.count - 1]) == null ? void 0 : _this$getMeasurements.end) || _this.options.paddingStart) - _this.options.scrollMargin + _this.options.paddingEnd;\n    };\n    this._scrollToOffset = function(offset, _ref8) {\n        var adjustments = _ref8.adjustments, behavior = _ref8.behavior;\n        _this.options.scrollToFn(offset, {\n            behavior: behavior,\n            adjustments: adjustments\n        }, _this);\n    };\n    this.measure = function() {\n        _this.itemSizeCache = new Map();\n        _this.notify(false);\n    };\n    this.setOptions(_opts);\n    this.scrollRect = this.options.initialRect;\n    this.scrollOffset = this.options.initialOffset;\n    this.measurementsCache = this.options.initialMeasurementsCache;\n    this.measurementsCache.forEach(function(item) {\n        _this.itemSizeCache.set(item.key, item.size);\n    });\n    this.maybeNotify();\n};\nvar findNearestBinarySearch = function findNearestBinarySearch(low, high, getCurrentValue, value) {\n    while(low <= high){\n        var middle = (low + high) / 2 | 0;\n        var currentValue = getCurrentValue(middle);\n        if (currentValue < value) {\n            low = middle + 1;\n        } else if (currentValue > value) {\n            high = middle - 1;\n        } else {\n            return middle;\n        }\n    }\n    if (low > 0) {\n        return low - 1;\n    } else {\n        return 0;\n    }\n};\nfunction calculateRange(_ref9) {\n    var measurements = _ref9.measurements, outerSize = _ref9.outerSize, scrollOffset = _ref9.scrollOffset;\n    var count = measurements.length - 1;\n    var getOffset = function getOffset(index) {\n        return measurements[index].start;\n    };\n    var startIndex = findNearestBinarySearch(0, count, getOffset, scrollOffset);\n    var endIndex = startIndex;\n    while(endIndex < count && measurements[endIndex].end < scrollOffset + outerSize){\n        endIndex++;\n    }\n    return {\n        startIndex: startIndex,\n        endIndex: endIndex\n    };\n}\n //# sourceMappingURL=index.mjs.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQHRhbnN0YWNrL3ZpcnR1YWwtY29yZS9idWlsZC9saWIvaW5kZXgubWpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQUFBOzs7Ozs7Ozs7Q0FTQyxHQUM4RTtBQUNqQjtBQUNBO0FBRTlELEVBQUU7QUFFRixFQUFFO0FBRUYsSUFBSUssc0JBQXNCLFNBQVNBLG9CQUFvQkMsS0FBSztJQUMxRCxPQUFPQTtBQUNUO0FBQ0EsSUFBSUMsd0JBQXdCLFNBQVNBLHNCQUFzQkMsS0FBSztJQUM5RCxJQUFJQyxRQUFRQyxLQUFLQyxHQUFHLENBQUNILE1BQU1JLFVBQVUsR0FBR0osTUFBTUssUUFBUSxFQUFFO0lBQ3hELElBQUlDLE1BQU1KLEtBQUtLLEdBQUcsQ0FBQ1AsTUFBTVEsUUFBUSxHQUFHUixNQUFNSyxRQUFRLEVBQUVMLE1BQU1TLEtBQUssR0FBRztJQUNsRSxJQUFJQyxNQUFNLEVBQUU7SUFDWixJQUFLLElBQUlDLEtBQUtWLE9BQU9VLE1BQU1MLEtBQUtLLEtBQU07UUFDcENELElBQUlFLElBQUksQ0FBQ0Q7SUFDWDtJQUNBLE9BQU9EO0FBQ1Q7QUFDQSxJQUFJRyxxQkFBcUIsU0FBU0EsbUJBQW1CQyxRQUFRLEVBQUVDLEVBQUU7SUFDL0QsSUFBSUMsVUFBVUYsU0FBU0csYUFBYTtJQUNwQyxJQUFJLENBQUNELFNBQVM7UUFDWjtJQUNGO0lBQ0EsSUFBSUUsVUFBVSxTQUFTQSxRQUFRQyxJQUFJO1FBQ2pDLElBQUlDLFFBQVFELEtBQUtDLEtBQUssRUFDcEJDLFNBQVNGLEtBQUtFLE1BQU07UUFDdEJOLEdBQUc7WUFDREssT0FBT2xCLEtBQUtvQixLQUFLLENBQUNGO1lBQ2xCQyxRQUFRbkIsS0FBS29CLEtBQUssQ0FBQ0Q7UUFDckI7SUFDRjtJQUNBSCxRQUFRRixRQUFRTyxxQkFBcUI7SUFDckMsSUFBSUMsV0FBVyxJQUFJQyxlQUFlLFNBQVVDLE9BQU87UUFDakQsSUFBSUMsUUFBUUQsT0FBTyxDQUFDLEVBQUU7UUFDdEIsSUFBSUMsU0FBUyxRQUFRQSxNQUFNQyxhQUFhLEVBQUU7WUFDeEMsSUFBSUMsTUFBTUYsTUFBTUMsYUFBYSxDQUFDLEVBQUU7WUFDaEMsSUFBSUMsS0FBSztnQkFDUFgsUUFBUTtvQkFDTkUsT0FBT1MsSUFBSUMsVUFBVTtvQkFDckJULFFBQVFRLElBQUlFLFNBQVM7Z0JBQ3ZCO2dCQUNBO1lBQ0Y7UUFDRjtRQUNBYixRQUFRRixRQUFRTyxxQkFBcUI7SUFDdkM7SUFDQUMsU0FBU1EsT0FBTyxDQUFDaEIsU0FBUztRQUN4QmEsS0FBSztJQUNQO0lBQ0EsT0FBTztRQUNMTCxTQUFTUyxTQUFTLENBQUNqQjtJQUNyQjtBQUNGO0FBQ0EsSUFBSWtCLG9CQUFvQixTQUFTQSxrQkFBa0JwQixRQUFRLEVBQUVDLEVBQUU7SUFDN0QsSUFBSUMsVUFBVUYsU0FBU0csYUFBYTtJQUNwQyxJQUFJLENBQUNELFNBQVM7UUFDWjtJQUNGO0lBQ0EsSUFBSUUsVUFBVSxTQUFTQTtRQUNyQkgsR0FBRztZQUNESyxPQUFPSixRQUFRbUIsVUFBVTtZQUN6QmQsUUFBUUwsUUFBUW9CLFdBQVc7UUFDN0I7SUFDRjtJQUNBbEI7SUFDQUYsUUFBUXFCLGdCQUFnQixDQUFDLFVBQVVuQixTQUFTO1FBQzFDb0IsU0FBUztJQUNYO0lBQ0EsT0FBTztRQUNMdEIsUUFBUXVCLG1CQUFtQixDQUFDLFVBQVVyQjtJQUN4QztBQUNGO0FBQ0EsSUFBSXNCLHVCQUF1QixTQUFTQSxxQkFBcUIxQixRQUFRLEVBQUVDLEVBQUU7SUFDbkUsSUFBSUMsVUFBVUYsU0FBU0csYUFBYTtJQUNwQyxJQUFJLENBQUNELFNBQVM7UUFDWjtJQUNGO0lBQ0EsSUFBSUUsVUFBVSxTQUFTQTtRQUNyQkgsR0FBR0MsT0FBTyxDQUFDRixTQUFTMkIsT0FBTyxDQUFDQyxVQUFVLEdBQUcsZUFBZSxZQUFZO0lBQ3RFO0lBQ0F4QjtJQUNBRixRQUFRcUIsZ0JBQWdCLENBQUMsVUFBVW5CLFNBQVM7UUFDMUNvQixTQUFTO0lBQ1g7SUFDQSxPQUFPO1FBQ0x0QixRQUFRdUIsbUJBQW1CLENBQUMsVUFBVXJCO0lBQ3hDO0FBQ0Y7QUFDQSxJQUFJeUIsc0JBQXNCLFNBQVNBLG9CQUFvQjdCLFFBQVEsRUFBRUMsRUFBRTtJQUNqRSxJQUFJQyxVQUFVRixTQUFTRyxhQUFhO0lBQ3BDLElBQUksQ0FBQ0QsU0FBUztRQUNaO0lBQ0Y7SUFDQSxJQUFJRSxVQUFVLFNBQVNBO1FBQ3JCSCxHQUFHQyxPQUFPLENBQUNGLFNBQVMyQixPQUFPLENBQUNDLFVBQVUsR0FBRyxZQUFZLFVBQVU7SUFDakU7SUFDQXhCO0lBQ0FGLFFBQVFxQixnQkFBZ0IsQ0FBQyxVQUFVbkIsU0FBUztRQUMxQ29CLFNBQVM7SUFDWDtJQUNBLE9BQU87UUFDTHRCLFFBQVF1QixtQkFBbUIsQ0FBQyxVQUFVckI7SUFDeEM7QUFDRjtBQUNBLElBQUkwQixpQkFBaUIsU0FBU0EsZUFBZTVCLE9BQU8sRUFBRVcsS0FBSyxFQUFFYixRQUFRO0lBQ25FLElBQUlhLFNBQVMsUUFBUUEsTUFBTUMsYUFBYSxFQUFFO1FBQ3hDLElBQUlDLE1BQU1GLE1BQU1DLGFBQWEsQ0FBQyxFQUFFO1FBQ2hDLElBQUlDLEtBQUs7WUFDUCxJQUFJZ0IsT0FBTzNDLEtBQUtvQixLQUFLLENBQUNPLEdBQUcsQ0FBQ2YsU0FBUzJCLE9BQU8sQ0FBQ0MsVUFBVSxHQUFHLGVBQWUsWUFBWTtZQUNuRixPQUFPRztRQUNUO0lBQ0Y7SUFDQSxPQUFPM0MsS0FBS29CLEtBQUssQ0FBQ04sUUFBUU8scUJBQXFCLEVBQUUsQ0FBQ1QsU0FBUzJCLE9BQU8sQ0FBQ0MsVUFBVSxHQUFHLFVBQVUsU0FBUztBQUNyRztBQUNBLElBQUlJLGVBQWUsU0FBU0EsYUFBYUMsTUFBTSxFQUFFQyxJQUFJLEVBQUVsQyxRQUFRO0lBQzdELElBQUltQyx1QkFBdUJDO0lBQzNCLElBQUlDLG1CQUFtQkgsS0FBS0ksV0FBVyxFQUNyQ0EsY0FBY0QscUJBQXFCLEtBQUssSUFBSSxJQUFJQSxrQkFDaERFLFdBQVdMLEtBQUtLLFFBQVE7SUFDMUIsSUFBSUMsV0FBV1AsU0FBU0s7SUFDdkJILENBQUFBLHdCQUF3Qm5DLFNBQVNHLGFBQWEsS0FBSyxRQUFRZ0Msc0JBQXNCTSxRQUFRLElBQUksUUFBUU4sc0JBQXNCTSxRQUFRLENBQUVMLENBQUFBLHlCQUF5QixDQUFDLEdBQUdBLHNCQUFzQixDQUFDcEMsU0FBUzJCLE9BQU8sQ0FBQ0MsVUFBVSxHQUFHLFNBQVMsTUFBTSxHQUFHWSxVQUFVSix1QkFBdUJHLFFBQVEsR0FBR0EsVUFBVUgsc0JBQXFCO0FBQ3ZUO0FBQ0EsSUFBSU0sZ0JBQWdCLFNBQVNBLGNBQWNULE1BQU0sRUFBRVUsS0FBSyxFQUFFM0MsUUFBUTtJQUNoRSxJQUFJNEMsd0JBQXdCQztJQUM1QixJQUFJQyxvQkFBb0JILE1BQU1MLFdBQVcsRUFDdkNBLGNBQWNRLHNCQUFzQixLQUFLLElBQUksSUFBSUEsbUJBQ2pEUCxXQUFXSSxNQUFNSixRQUFRO0lBQzNCLElBQUlDLFdBQVdQLFNBQVNLO0lBQ3ZCTSxDQUFBQSx5QkFBeUI1QyxTQUFTRyxhQUFhLEtBQUssUUFBUXlDLHVCQUF1QkgsUUFBUSxJQUFJLFFBQVFHLHVCQUF1QkgsUUFBUSxDQUFFSSxDQUFBQSx5QkFBeUIsQ0FBQyxHQUFHQSxzQkFBc0IsQ0FBQzdDLFNBQVMyQixPQUFPLENBQUNDLFVBQVUsR0FBRyxTQUFTLE1BQU0sR0FBR1ksVUFBVUssdUJBQXVCTixRQUFRLEdBQUdBLFVBQVVNLHNCQUFxQjtBQUMxVDtBQUNBLElBQUlFLGNBQWMsU0FBU0EsWUFBWUMsS0FBSztJQUMxQyxJQUFJQyxRQUFRLElBQUk7SUFDaEIsSUFBSSxDQUFDQyxNQUFNLEdBQUcsRUFBRTtJQUNoQixJQUFJLENBQUMvQyxhQUFhLEdBQUc7SUFDckIsSUFBSSxDQUFDZ0QsV0FBVyxHQUFHO0lBQ25CLElBQUksQ0FBQ0Msb0JBQW9CLEdBQUc7SUFDNUIsSUFBSSxDQUFDQyxzQkFBc0IsR0FBRztJQUM5QixJQUFJLENBQUNDLGlCQUFpQixHQUFHLEVBQUU7SUFDM0IsSUFBSSxDQUFDQyxhQUFhLEdBQUcsSUFBSUM7SUFDekIsSUFBSSxDQUFDQywyQkFBMkIsR0FBRyxFQUFFO0lBQ3JDLElBQUksQ0FBQ0MsZUFBZSxHQUFHO0lBQ3ZCLElBQUksQ0FBQ0MsaUJBQWlCLEdBQUc7SUFDekIsSUFBSSxDQUFDQyxtQkFBbUIsR0FBRyxJQUFJSjtJQUMvQixJQUFJLENBQUM5QyxRQUFRLEdBQUc7UUFDZCxJQUFJbUQsTUFBTTtRQUNWLElBQUlDLE1BQU0sU0FBU0E7WUFDakIsSUFBSUQsS0FBSztnQkFDUCxPQUFPQTtZQUNULE9BQU8sSUFBSSxPQUFPbEQsbUJBQW1CLGFBQWE7Z0JBQ2hELE9BQU9rRCxNQUFNLElBQUlsRCxlQUFlLFNBQVVDLE9BQU87b0JBQy9DQSxRQUFRbUQsT0FBTyxDQUFDLFNBQVVsRCxLQUFLO3dCQUM3Qm9DLE1BQU1lLGVBQWUsQ0FBQ25ELE1BQU1vRCxNQUFNLEVBQUVwRDtvQkFDdEM7Z0JBQ0Y7WUFDRixPQUFPO2dCQUNMLE9BQU87WUFDVDtRQUNGO1FBQ0EsT0FBTztZQUNMcUQsWUFBWSxTQUFTQTtnQkFDbkIsSUFBSUM7Z0JBQ0osT0FBTyxDQUFDQSxPQUFPTCxLQUFJLEtBQU0sT0FBTyxLQUFLLElBQUlLLEtBQUtELFVBQVU7WUFDMUQ7WUFDQWhELFNBQVMsU0FBU0EsUUFBUStDLE1BQU07Z0JBQzlCLElBQUlHO2dCQUNKLE9BQU8sQ0FBQ0EsUUFBUU4sS0FBSSxLQUFNLE9BQU8sS0FBSyxJQUFJTSxNQUFNbEQsT0FBTyxDQUFDK0MsUUFBUTtvQkFDOURsRCxLQUFLO2dCQUNQO1lBQ0Y7WUFDQUksV0FBVyxTQUFTQSxVQUFVOEMsTUFBTTtnQkFDbEMsSUFBSUk7Z0JBQ0osT0FBTyxDQUFDQSxRQUFRUCxLQUFJLEtBQU0sT0FBTyxLQUFLLElBQUlPLE1BQU1sRCxTQUFTLENBQUM4QztZQUM1RDtRQUNGO0lBQ0Y7SUFDQSxJQUFJLENBQUMvRSxLQUFLLEdBQUc7SUFDYixJQUFJLENBQUNvRixVQUFVLEdBQUcsU0FBVUMsSUFBSTtRQUM5QkMsT0FBTzVELE9BQU8sQ0FBQzJELE1BQU1SLE9BQU8sQ0FBQyxTQUFVVSxLQUFLO1lBQzFDLElBQUlDLE1BQU1ELEtBQUssQ0FBQyxFQUFFLEVBQ2hCRSxRQUFRRixLQUFLLENBQUMsRUFBRTtZQUNsQixJQUFJLE9BQU9FLFVBQVUsYUFBYSxPQUFPSixJQUFJLENBQUNHLElBQUk7UUFDcEQ7UUFDQXpCLE1BQU10QixPQUFPLEdBQUdoRCxpRkFBUUEsQ0FBQztZQUN2QmlHLE9BQU87WUFDUEMsZUFBZTtZQUNmdEYsVUFBVTtZQUNWdUYsY0FBYztZQUNkQyxZQUFZO1lBQ1pDLG9CQUFvQjtZQUNwQkMsa0JBQWtCO1lBQ2xCckQsWUFBWTtZQUNac0QsWUFBWW5HO1lBQ1pvRyxnQkFBZ0JsRztZQUNoQm1HLFVBQVUsU0FBU0EsWUFBWTtZQUMvQnRELGdCQUFnQkE7WUFDaEJ1RCxhQUFhO2dCQUNYL0UsT0FBTztnQkFDUEMsUUFBUTtZQUNWO1lBQ0ErRSxjQUFjO1lBQ2RDLGdCQUFnQjtZQUNoQkMsZ0JBQWdCO1lBQ2hCQywwQkFBMEIsRUFBRTtZQUM1QkMsT0FBTztRQUNULEdBQUduQjtJQUNMO0lBQ0EsSUFBSSxDQUFDb0IsTUFBTSxHQUFHLFNBQVVDLElBQUk7UUFDMUIzQyxNQUFNdEIsT0FBTyxDQUFDeUQsUUFBUSxJQUFJLFFBQVFuQyxNQUFNdEIsT0FBTyxDQUFDeUQsUUFBUSxDQUFDbkMsT0FBTzJDO0lBQ2xFO0lBQ0EsSUFBSSxDQUFDQyxXQUFXLEdBQUdqSCxnREFBSUEsQ0FBQztRQUN0QnFFLE1BQU02QyxjQUFjO1FBQ3BCLE9BQU87WUFBQzdDLE1BQU1FLFdBQVc7WUFBRUYsTUFBTS9ELEtBQUssR0FBRytELE1BQU0vRCxLQUFLLENBQUNJLFVBQVUsR0FBRztZQUFNMkQsTUFBTS9ELEtBQUssR0FBRytELE1BQU0vRCxLQUFLLENBQUNRLFFBQVEsR0FBRztTQUFLO0lBQ3BILEdBQUcsU0FBVXlELFdBQVc7UUFDdEJGLE1BQU0wQyxNQUFNLENBQUN4QztJQUNmLEdBQUc7UUFDRHVCLEtBQUtxQixLQUF5QixJQUFnQjtRQUM5Q25CLE9BQU8sU0FBU0E7WUFDZCxPQUFPM0IsTUFBTXRCLE9BQU8sQ0FBQ2lELEtBQUs7UUFDNUI7UUFDQW9CLGFBQWE7WUFBQyxJQUFJLENBQUM3QyxXQUFXO1lBQUUsSUFBSSxDQUFDakUsS0FBSyxHQUFHLElBQUksQ0FBQ0EsS0FBSyxDQUFDSSxVQUFVLEdBQUc7WUFBTSxJQUFJLENBQUNKLEtBQUssR0FBRyxJQUFJLENBQUNBLEtBQUssQ0FBQ1EsUUFBUSxHQUFHO1NBQUs7SUFDckg7SUFDQSxJQUFJLENBQUN1RyxPQUFPLEdBQUc7UUFDYmhELE1BQU1DLE1BQU0sQ0FBQ2dELE1BQU0sQ0FBQ0MsU0FBU3BDLE9BQU8sQ0FBQyxTQUFVcUMsQ0FBQztZQUM5QyxPQUFPQTtRQUNUO1FBQ0FuRCxNQUFNQyxNQUFNLEdBQUcsRUFBRTtRQUNqQkQsTUFBTTlDLGFBQWEsR0FBRztJQUN4QjtJQUNBLElBQUksQ0FBQ2tHLFNBQVMsR0FBRztRQUNmcEQsTUFBTVcsbUJBQW1CLENBQUNHLE9BQU8sQ0FBQ2QsTUFBTXZDLFFBQVEsQ0FBQ1EsT0FBTztRQUN4RCxPQUFPO1lBQ0wrQixNQUFNdkMsUUFBUSxDQUFDd0QsVUFBVTtZQUN6QmpCLE1BQU1nRCxPQUFPO1FBQ2Y7SUFDRjtJQUNBLElBQUksQ0FBQ0ssV0FBVyxHQUFHO1FBQ2pCLElBQUluRyxnQkFBZ0I4QyxNQUFNdEIsT0FBTyxDQUFDNEUsZ0JBQWdCO1FBQ2xELElBQUl0RCxNQUFNOUMsYUFBYSxLQUFLQSxlQUFlO1lBQ3pDOEMsTUFBTWdELE9BQU87WUFDYmhELE1BQU05QyxhQUFhLEdBQUdBO1lBQ3RCOEMsTUFBTXVELGVBQWUsQ0FBQ3ZELE1BQU13RCxZQUFZLEVBQUU7Z0JBQ3hDbkUsYUFBYW9FO2dCQUNibkUsVUFBVW1FO1lBQ1o7WUFDQXpELE1BQU1DLE1BQU0sQ0FBQ3BELElBQUksQ0FBQ21ELE1BQU10QixPQUFPLENBQUM1QixrQkFBa0IsQ0FBQ2tELE9BQU8sU0FBVTVDLElBQUk7Z0JBQ3RFNEMsTUFBTTBELFVBQVUsR0FBR3RHO2dCQUNuQjRDLE1BQU00QyxXQUFXO1lBQ25CO1lBQ0E1QyxNQUFNQyxNQUFNLENBQUNwRCxJQUFJLENBQUNtRCxNQUFNdEIsT0FBTyxDQUFDRCxvQkFBb0IsQ0FBQ3VCLE9BQU8sU0FBVWhCLE1BQU07Z0JBQzFFZ0IsTUFBTVUsaUJBQWlCLEdBQUc7Z0JBQzFCLElBQUlWLE1BQU13RCxZQUFZLEtBQUt4RSxRQUFRO29CQUNqQztnQkFDRjtnQkFDQSxJQUFJZ0IsTUFBTUcsb0JBQW9CLEtBQUssTUFBTTtvQkFDdkN3RCxhQUFhM0QsTUFBTUcsb0JBQW9CO29CQUN2Q0gsTUFBTUcsb0JBQW9CLEdBQUc7Z0JBQy9CO2dCQUNBSCxNQUFNRSxXQUFXLEdBQUc7Z0JBQ3BCRixNQUFNUyxlQUFlLEdBQUdULE1BQU13RCxZQUFZLEdBQUd4RSxTQUFTLFlBQVk7Z0JBQ2xFZ0IsTUFBTXdELFlBQVksR0FBR3hFO2dCQUNyQmdCLE1BQU00QyxXQUFXO2dCQUNqQjVDLE1BQU1HLG9CQUFvQixHQUFHeUQsV0FBVztvQkFDdEM1RCxNQUFNRyxvQkFBb0IsR0FBRztvQkFDN0JILE1BQU1FLFdBQVcsR0FBRztvQkFDcEJGLE1BQU1TLGVBQWUsR0FBRztvQkFDeEJULE1BQU00QyxXQUFXO2dCQUNuQixHQUFHNUMsTUFBTXRCLE9BQU8sQ0FBQzRELGNBQWM7WUFDakM7UUFDRjtJQUNGO0lBQ0EsSUFBSSxDQUFDdUIsT0FBTyxHQUFHO1FBQ2IsT0FBTzdELE1BQU0wRCxVQUFVLENBQUMxRCxNQUFNdEIsT0FBTyxDQUFDQyxVQUFVLEdBQUcsVUFBVSxTQUFTO0lBQ3hFO0lBQ0EsSUFBSSxDQUFDbUYsV0FBVyxHQUFHbkksZ0RBQUlBLENBQUM7UUFDdEIsT0FBTztZQUFDcUUsTUFBTXRCLE9BQU8sQ0FBQ2hDLEtBQUs7WUFBRXNELE1BQU10QixPQUFPLENBQUNtRCxZQUFZO1lBQUU3QixNQUFNdEIsT0FBTyxDQUFDMkQsWUFBWTtZQUFFckMsTUFBTXRCLE9BQU8sQ0FBQ3VELFVBQVU7U0FBQztJQUNoSCxHQUFHLFNBQVV2RixLQUFLLEVBQUVtRixZQUFZLEVBQUVRLFlBQVksRUFBRUosVUFBVTtRQUN4RGpDLE1BQU1RLDJCQUEyQixHQUFHLEVBQUU7UUFDdEMsT0FBTztZQUNMOUQsT0FBT0E7WUFDUG1GLGNBQWNBO1lBQ2RRLGNBQWNBO1lBQ2RKLFlBQVlBO1FBQ2Q7SUFDRixHQUFHO1FBQ0RSLEtBQUs7SUFDUDtJQUNBLElBQUksQ0FBQ3NDLHNCQUFzQixHQUFHLFNBQVVDLFlBQVksRUFBRWpJLEtBQUs7UUFDekQsSUFBSWtJLDRCQUE0QixJQUFJMUQ7UUFDcEMsSUFBSTJELHVCQUF1QixJQUFJM0Q7UUFDL0IsSUFBSyxJQUFJNEQsSUFBSXBJLFFBQVEsR0FBR29JLEtBQUssR0FBR0EsSUFBSztZQUNuQyxJQUFJQyxjQUFjSixZQUFZLENBQUNHLEVBQUU7WUFDakMsSUFBSUYsMEJBQTBCSSxHQUFHLENBQUNELFlBQVlFLElBQUksR0FBRztnQkFDbkQ7WUFDRjtZQUNBLElBQUlDLDhCQUE4QkwscUJBQXFCckQsR0FBRyxDQUFDdUQsWUFBWUUsSUFBSTtZQUMzRSxJQUFJQywrQkFBK0IsUUFBUUgsWUFBWTdILEdBQUcsR0FBR2dJLDRCQUE0QmhJLEdBQUcsRUFBRTtnQkFDNUYySCxxQkFBcUJNLEdBQUcsQ0FBQ0osWUFBWUUsSUFBSSxFQUFFRjtZQUM3QyxPQUFPLElBQUlBLFlBQVk3SCxHQUFHLEdBQUdnSSw0QkFBNEJoSSxHQUFHLEVBQUU7Z0JBQzVEMEgsMEJBQTBCTyxHQUFHLENBQUNKLFlBQVlFLElBQUksRUFBRTtZQUNsRDtZQUNBLElBQUlMLDBCQUEwQm5GLElBQUksS0FBS2tCLE1BQU10QixPQUFPLENBQUMrRCxLQUFLLEVBQUU7Z0JBQzFEO1lBQ0Y7UUFDRjtRQUNBLE9BQU95QixxQkFBcUJwRixJQUFJLEtBQUtrQixNQUFNdEIsT0FBTyxDQUFDK0QsS0FBSyxHQUFHZ0MsTUFBTUMsSUFBSSxDQUFDUixxQkFBcUJTLE1BQU0sSUFBSUMsSUFBSSxDQUFDLFNBQVVDLENBQUMsRUFBRUMsQ0FBQztZQUN0SCxPQUFPRCxFQUFFdEksR0FBRyxHQUFHdUksRUFBRXZJLEdBQUc7UUFDdEIsRUFBRSxDQUFDLEVBQUUsR0FBR2tIO0lBQ1Y7SUFDQSxJQUFJLENBQUNzQixlQUFlLEdBQUdwSixnREFBSUEsQ0FBQztRQUMxQixPQUFPO1lBQUNxRSxNQUFNOEQsV0FBVztZQUFJOUQsTUFBTU0sYUFBYTtTQUFDO0lBQ25ELEdBQUcsU0FBVTBFLEtBQUssRUFBRTFFLGFBQWE7UUFDL0IsSUFBSTVELFFBQVFzSSxNQUFNdEksS0FBSyxFQUNyQm1GLGVBQWVtRCxNQUFNbkQsWUFBWSxFQUNqQ1EsZUFBZTJDLE1BQU0zQyxZQUFZLEVBQ2pDSixhQUFhK0MsTUFBTS9DLFVBQVU7UUFDL0IsSUFBSXpGLE1BQU13RCxNQUFNUSwyQkFBMkIsQ0FBQ3lFLE1BQU0sR0FBRyxJQUFJOUksS0FBS0ssR0FBRyxDQUFDMEksS0FBSyxDQUFDL0ksTUFBTTZELE1BQU1RLDJCQUEyQixJQUFJO1FBQ25IUixNQUFNUSwyQkFBMkIsR0FBRyxFQUFFO1FBQ3RDLElBQUl3RCxlQUFlaEUsTUFBTUssaUJBQWlCLENBQUM4RSxLQUFLLENBQUMsR0FBRzNJO1FBQ3BELElBQUssSUFBSTRJLE1BQU01SSxLQUFLNEksTUFBTTFJLE9BQU8wSSxNQUFPO1lBQ3RDLElBQUkzRCxNQUFNUSxXQUFXbUQ7WUFDckIsSUFBSUMsc0JBQXNCckYsTUFBTXRCLE9BQU8sQ0FBQytELEtBQUssS0FBSyxJQUFJdUIsWUFBWSxDQUFDb0IsTUFBTSxFQUFFLEdBQUdwRixNQUFNK0Qsc0JBQXNCLENBQUNDLGNBQWNvQjtZQUN6SCxJQUFJbEosUUFBUW1KLHNCQUFzQkEsb0JBQW9COUksR0FBRyxHQUFHc0YsZUFBZVE7WUFDM0UsSUFBSWlELGVBQWVoRixjQUFjTyxHQUFHLENBQUNZO1lBQ3JDLElBQUkzQyxPQUFPLE9BQU93RyxpQkFBaUIsV0FBV0EsZUFBZXRGLE1BQU10QixPQUFPLENBQUM2RyxZQUFZLENBQUNIO1lBQ3hGLElBQUk3SSxNQUFNTCxRQUFRNEM7WUFDbEIsSUFBSXdGLE9BQU9lLHNCQUFzQkEsb0JBQW9CZixJQUFJLEdBQUdjLE1BQU1wRixNQUFNdEIsT0FBTyxDQUFDK0QsS0FBSztZQUNyRnVCLFlBQVksQ0FBQ29CLElBQUksR0FBRztnQkFDbEJySixPQUFPcUo7Z0JBQ1BsSixPQUFPQTtnQkFDUDRDLE1BQU1BO2dCQUNOdkMsS0FBS0E7Z0JBQ0xrRixLQUFLQTtnQkFDTDZDLE1BQU1BO1lBQ1I7UUFDRjtRQUNBdEUsTUFBTUssaUJBQWlCLEdBQUcyRDtRQUMxQixPQUFPQTtJQUNULEdBQUc7UUFDRHZDLEtBQUtxQixLQUF5QixJQUFnQjtRQUM5Q25CLE9BQU8sU0FBU0E7WUFDZCxPQUFPM0IsTUFBTXRCLE9BQU8sQ0FBQ2lELEtBQUs7UUFDNUI7SUFDRjtJQUNBLElBQUksQ0FBQ2tCLGNBQWMsR0FBR2xILGdEQUFJQSxDQUFDO1FBQ3pCLE9BQU87WUFBQ3FFLE1BQU0rRSxlQUFlO1lBQUkvRSxNQUFNNkQsT0FBTztZQUFJN0QsTUFBTXdELFlBQVk7U0FBQztJQUN2RSxHQUFHLFNBQVVRLFlBQVksRUFBRXdCLFNBQVMsRUFBRWhDLFlBQVk7UUFDaEQsT0FBT3hELE1BQU0vRCxLQUFLLEdBQUcrSCxhQUFhaUIsTUFBTSxHQUFHLEtBQUtPLFlBQVksSUFBSTNDLGVBQWU7WUFDN0VtQixjQUFjQTtZQUNkd0IsV0FBV0E7WUFDWGhDLGNBQWNBO1FBQ2hCLEtBQUs7SUFDUCxHQUFHO1FBQ0QvQixLQUFLcUIsS0FBeUIsSUFBZ0I7UUFDOUNuQixPQUFPLFNBQVNBO1lBQ2QsT0FBTzNCLE1BQU10QixPQUFPLENBQUNpRCxLQUFLO1FBQzVCO0lBQ0Y7SUFDQSxJQUFJLENBQUM4RCxVQUFVLEdBQUc5SixnREFBSUEsQ0FBQztRQUNyQixPQUFPO1lBQUNxRSxNQUFNdEIsT0FBTyxDQUFDd0QsY0FBYztZQUFFbEMsTUFBTTZDLGNBQWM7WUFBSTdDLE1BQU10QixPQUFPLENBQUNwQyxRQUFRO1lBQUUwRCxNQUFNdEIsT0FBTyxDQUFDaEMsS0FBSztTQUFDO0lBQzVHLEdBQUcsU0FBVXdGLGNBQWMsRUFBRWpHLEtBQUssRUFBRUssUUFBUSxFQUFFSSxLQUFLO1FBQ2pELE9BQU9ULFVBQVUsT0FBTyxFQUFFLEdBQUdpRyxlQUFleEcsaUZBQVFBLENBQUMsQ0FBQyxHQUFHTyxPQUFPO1lBQzlESyxVQUFVQTtZQUNWSSxPQUFPQTtRQUNUO0lBQ0YsR0FBRztRQUNEK0UsS0FBS3FCLEtBQXlCLElBQWdCO1FBQzlDbkIsT0FBTyxTQUFTQTtZQUNkLE9BQU8zQixNQUFNdEIsT0FBTyxDQUFDaUQsS0FBSztRQUM1QjtJQUNGO0lBQ0EsSUFBSSxDQUFDK0QsZ0JBQWdCLEdBQUcsU0FBVUMsSUFBSTtRQUNwQyxJQUFJQyxnQkFBZ0I1RixNQUFNdEIsT0FBTyxDQUFDNkQsY0FBYztRQUNoRCxJQUFJc0QsV0FBV0YsS0FBS0csWUFBWSxDQUFDRjtRQUNqQyxJQUFJLENBQUNDLFVBQVU7WUFDYkUsUUFBUUMsSUFBSSxDQUFDLDZCQUE2QkosZ0JBQWdCO1lBQzFELE9BQU8sQ0FBQztRQUNWO1FBQ0EsT0FBT0ssU0FBU0osVUFBVTtJQUM1QjtJQUNBLElBQUksQ0FBQzlFLGVBQWUsR0FBRyxTQUFVNEUsSUFBSSxFQUFFL0gsS0FBSztRQUMxQyxJQUFJc0ksT0FBT2xHLE1BQU1LLGlCQUFpQixDQUFDTCxNQUFNMEYsZ0JBQWdCLENBQUNDLE1BQU07UUFDaEUsSUFBSSxDQUFDTyxRQUFRLENBQUNQLEtBQUtRLFdBQVcsRUFBRTtZQUM5Qm5HLE1BQU1XLG1CQUFtQixDQUFDRyxPQUFPLENBQUMsU0FBVXNGLE1BQU0sRUFBRTNFLEdBQUc7Z0JBQ3JELElBQUkyRSxXQUFXVCxNQUFNO29CQUNuQjNGLE1BQU12QyxRQUFRLENBQUNTLFNBQVMsQ0FBQ3lIO29CQUN6QjNGLE1BQU1XLG1CQUFtQixDQUFDLFNBQVMsQ0FBQ2M7Z0JBQ3RDO1lBQ0Y7WUFDQTtRQUNGO1FBQ0EsSUFBSTRFLFdBQVdyRyxNQUFNVyxtQkFBbUIsQ0FBQ0UsR0FBRyxDQUFDcUYsS0FBS3pFLEdBQUc7UUFDckQsSUFBSTRFLGFBQWFWLE1BQU07WUFDckIsSUFBSVUsVUFBVTtnQkFDWnJHLE1BQU12QyxRQUFRLENBQUNTLFNBQVMsQ0FBQ21JO1lBQzNCO1lBQ0FyRyxNQUFNdkMsUUFBUSxDQUFDUSxPQUFPLENBQUMwSDtZQUN2QjNGLE1BQU1XLG1CQUFtQixDQUFDNkQsR0FBRyxDQUFDMEIsS0FBS3pFLEdBQUcsRUFBRWtFO1FBQzFDO1FBQ0EsSUFBSVcsbUJBQW1CdEcsTUFBTXRCLE9BQU8sQ0FBQ0csY0FBYyxDQUFDOEcsTUFBTS9ILE9BQU9vQztRQUNqRUEsTUFBTXVHLFVBQVUsQ0FBQ0wsTUFBTUk7SUFDekI7SUFDQSxJQUFJLENBQUNDLFVBQVUsR0FBRyxTQUFVTCxJQUFJLEVBQUVwSCxJQUFJO1FBQ3BDLElBQUkwSDtRQUNKLElBQUlDLFdBQVcsQ0FBQ0Qsd0JBQXdCeEcsTUFBTU0sYUFBYSxDQUFDTyxHQUFHLENBQUNxRixLQUFLekUsR0FBRyxNQUFNLE9BQU8rRSx3QkFBd0JOLEtBQUtwSCxJQUFJO1FBQ3RILElBQUk0SCxRQUFRNUgsT0FBTzJIO1FBQ25CLElBQUlDLFVBQVUsR0FBRztZQUNmLElBQUlSLEtBQUtoSyxLQUFLLEdBQUc4RCxNQUFNd0QsWUFBWSxFQUFFO2dCQUNuQyxJQUFJVixLQUF5QixJQUFnQjlDLE1BQU10QixPQUFPLENBQUNpRCxLQUFLLEVBQUU7b0JBQ2hFb0UsUUFBUVksSUFBSSxDQUFDLGNBQWNEO2dCQUM3QjtnQkFDQTFHLE1BQU11RCxlQUFlLENBQUN2RCxNQUFNd0QsWUFBWSxFQUFFO29CQUN4Q25FLGFBQWFXLE1BQU1VLGlCQUFpQixJQUFJZ0c7b0JBQ3hDcEgsVUFBVW1FO2dCQUNaO1lBQ0Y7WUFDQXpELE1BQU1RLDJCQUEyQixDQUFDM0QsSUFBSSxDQUFDcUosS0FBS25LLEtBQUs7WUFDakRpRSxNQUFNTSxhQUFhLEdBQUcsSUFBSUMsSUFBSVAsTUFBTU0sYUFBYSxDQUFDa0UsR0FBRyxDQUFDMEIsS0FBS3pFLEdBQUcsRUFBRTNDO1lBQ2hFa0IsTUFBTTBDLE1BQU0sQ0FBQztRQUNmO0lBQ0Y7SUFDQSxJQUFJLENBQUM3RCxjQUFjLEdBQUcsU0FBVThHLElBQUk7UUFDbEMsSUFBSSxDQUFDQSxNQUFNO1lBQ1Q7UUFDRjtRQUNBM0YsTUFBTWUsZUFBZSxDQUFDNEUsTUFBTWxDO0lBQzlCO0lBQ0EsSUFBSSxDQUFDbUQsZUFBZSxHQUFHakwsZ0RBQUlBLENBQUM7UUFDMUIsT0FBTztZQUFDcUUsTUFBTXlGLFVBQVU7WUFBSXpGLE1BQU0rRSxlQUFlO1NBQUc7SUFDdEQsR0FBRyxTQUFVOEIsT0FBTyxFQUFFN0MsWUFBWTtRQUNoQyxJQUFJOEMsZUFBZSxFQUFFO1FBQ3JCLElBQUssSUFBSUMsSUFBSSxHQUFHQyxNQUFNSCxRQUFRNUIsTUFBTSxFQUFFOEIsSUFBSUMsS0FBS0QsSUFBSztZQUNsRCxJQUFJRSxNQUFNSixPQUFPLENBQUNFLEVBQUU7WUFDcEIsSUFBSTNDLGNBQWNKLFlBQVksQ0FBQ2lELElBQUk7WUFDbkNILGFBQWFqSyxJQUFJLENBQUN1SDtRQUNwQjtRQUNBLE9BQU8wQztJQUNULEdBQUc7UUFDRHJGLEtBQUtxQixLQUF5QixJQUFnQjtRQUM5Q25CLE9BQU8sU0FBU0E7WUFDZCxPQUFPM0IsTUFBTXRCLE9BQU8sQ0FBQ2lELEtBQUs7UUFDNUI7SUFDRjtJQUNBLElBQUksQ0FBQ3VGLHVCQUF1QixHQUFHLFNBQVVsSSxNQUFNO1FBQzdDLElBQUlnRixlQUFlaEUsTUFBTStFLGVBQWU7UUFDeEMsT0FBT25KLHdEQUFZQSxDQUFDb0ksWUFBWSxDQUFDbUQsd0JBQXdCLEdBQUduRCxhQUFhaUIsTUFBTSxHQUFHLEdBQUcsU0FBVWxKLEtBQUs7WUFDbEcsT0FBT0gsd0RBQVlBLENBQUNvSSxZQUFZLENBQUNqSSxNQUFNLEVBQUVHLEtBQUs7UUFDaEQsR0FBRzhDLFFBQVE7SUFDYjtJQUNBLElBQUksQ0FBQ29JLHFCQUFxQixHQUFHLFNBQVU3SCxRQUFRLEVBQUU4SCxLQUFLO1FBQ3BELElBQUl2SSxPQUFPa0IsTUFBTTZELE9BQU87UUFDeEIsSUFBSXdELFVBQVUsUUFBUTtZQUNwQixJQUFJOUgsWUFBWVMsTUFBTXdELFlBQVksRUFBRTtnQkFDbEM2RCxRQUFRO1lBQ1YsT0FBTyxJQUFJOUgsWUFBWVMsTUFBTXdELFlBQVksR0FBRzFFLE1BQU07Z0JBQ2hEdUksUUFBUTtZQUNWLE9BQU87Z0JBQ0xBLFFBQVE7WUFDVjtRQUNGO1FBQ0EsSUFBSUEsVUFBVSxTQUFTO1lBQ3JCOUgsV0FBV0E7UUFDYixPQUFPLElBQUk4SCxVQUFVLE9BQU87WUFDMUI5SCxXQUFXQSxXQUFXVDtRQUN4QixPQUFPLElBQUl1SSxVQUFVLFVBQVU7WUFDN0I5SCxXQUFXQSxXQUFXVCxPQUFPO1FBQy9CO1FBQ0EsSUFBSXdJLGlCQUFpQnRILE1BQU10QixPQUFPLENBQUNDLFVBQVUsR0FBRyxnQkFBZ0I7UUFDaEUsSUFBSTRJLGFBQWF2SCxNQUFNOUMsYUFBYSxHQUFHLGNBQWM4QyxNQUFNOUMsYUFBYSxHQUFHOEMsTUFBTTlDLGFBQWEsQ0FBQ3NLLFFBQVEsQ0FBQ0MsZUFBZSxDQUFDSCxlQUFlLEdBQUd0SCxNQUFNOUMsYUFBYSxDQUFDb0ssZUFBZSxHQUFHO1FBQ2hMLElBQUlJLFlBQVlILGFBQWF2SCxNQUFNNkQsT0FBTztRQUMxQyxPQUFPMUgsS0FBS0MsR0FBRyxDQUFDRCxLQUFLSyxHQUFHLENBQUNrTCxXQUFXbkksV0FBVztJQUNqRDtJQUNBLElBQUksQ0FBQ29JLGlCQUFpQixHQUFHLFNBQVU1TCxLQUFLLEVBQUVzTCxLQUFLO1FBQzdDLElBQUlBLFVBQVUsS0FBSyxHQUFHO1lBQ3BCQSxRQUFRO1FBQ1Y7UUFDQXRMLFFBQVFJLEtBQUtDLEdBQUcsQ0FBQyxHQUFHRCxLQUFLSyxHQUFHLENBQUNULE9BQU9pRSxNQUFNdEIsT0FBTyxDQUFDaEMsS0FBSyxHQUFHO1FBQzFELElBQUkwSCxjQUFjeEksd0RBQVlBLENBQUNvRSxNQUFNK0UsZUFBZSxFQUFFLENBQUNoSixNQUFNO1FBQzdELElBQUlzTCxVQUFVLFFBQVE7WUFDcEIsSUFBSWpELFlBQVk3SCxHQUFHLElBQUl5RCxNQUFNd0QsWUFBWSxHQUFHeEQsTUFBTTZELE9BQU8sS0FBSzdELE1BQU10QixPQUFPLENBQUNzRCxnQkFBZ0IsRUFBRTtnQkFDNUZxRixRQUFRO1lBQ1YsT0FBTyxJQUFJakQsWUFBWWxJLEtBQUssSUFBSThELE1BQU13RCxZQUFZLEdBQUd4RCxNQUFNdEIsT0FBTyxDQUFDcUQsa0JBQWtCLEVBQUU7Z0JBQ3JGc0YsUUFBUTtZQUNWLE9BQU87Z0JBQ0wsT0FBTztvQkFBQ3JILE1BQU13RCxZQUFZO29CQUFFNkQ7aUJBQU07WUFDcEM7UUFDRjtRQUNBLElBQUk5SCxXQUFXOEgsVUFBVSxRQUFRakQsWUFBWTdILEdBQUcsR0FBR3lELE1BQU10QixPQUFPLENBQUNzRCxnQkFBZ0IsR0FBR29DLFlBQVlsSSxLQUFLLEdBQUc4RCxNQUFNdEIsT0FBTyxDQUFDcUQsa0JBQWtCO1FBQ3hJLE9BQU87WUFBQy9CLE1BQU1vSCxxQkFBcUIsQ0FBQzdILFVBQVU4SDtZQUFRQTtTQUFNO0lBQzlEO0lBQ0EsSUFBSSxDQUFDTyxhQUFhLEdBQUc7UUFDbkIsT0FBTzVILE1BQU1XLG1CQUFtQixDQUFDN0IsSUFBSSxHQUFHO0lBQzFDO0lBQ0EsSUFBSSxDQUFDK0ksbUJBQW1CLEdBQUc7UUFDekIsSUFBSTdILE1BQU1JLHNCQUFzQixLQUFLLE1BQU07WUFDekN1RCxhQUFhM0QsTUFBTUksc0JBQXNCO1lBQ3pDSixNQUFNSSxzQkFBc0IsR0FBRztRQUNqQztJQUNGO0lBQ0EsSUFBSSxDQUFDMEgsY0FBYyxHQUFHLFNBQVV2SSxRQUFRLEVBQUV3SSxLQUFLO1FBQzdDLElBQUlDLFFBQVFELFVBQVUsS0FBSyxJQUFJLENBQUMsSUFBSUEsT0FDbENFLGNBQWNELE1BQU1YLEtBQUssRUFDekJBLFFBQVFZLGdCQUFnQixLQUFLLElBQUksVUFBVUEsYUFDM0MzSSxXQUFXMEksTUFBTTFJLFFBQVE7UUFDM0JVLE1BQU02SCxtQkFBbUI7UUFDekIsSUFBSXZJLGFBQWEsWUFBWVUsTUFBTTRILGFBQWEsSUFBSTtZQUNsRDdCLFFBQVFDLElBQUksQ0FBQztRQUNmO1FBQ0FoRyxNQUFNdUQsZUFBZSxDQUFDdkQsTUFBTW9ILHFCQUFxQixDQUFDN0gsVUFBVThILFFBQVE7WUFDbEVoSSxhQUFhb0U7WUFDYm5FLFVBQVVBO1FBQ1o7SUFDRjtJQUNBLElBQUksQ0FBQzRJLGFBQWEsR0FBRyxTQUFVbk0sS0FBSyxFQUFFb00sTUFBTTtRQUMxQyxJQUFJQyxRQUFRRCxXQUFXLEtBQUssSUFBSSxDQUFDLElBQUlBLFFBQ25DRSxjQUFjRCxNQUFNZixLQUFLLEVBQ3pCaUIsZUFBZUQsZ0JBQWdCLEtBQUssSUFBSSxTQUFTQSxhQUNqRC9JLFdBQVc4SSxNQUFNOUksUUFBUTtRQUMzQnZELFFBQVFJLEtBQUtDLEdBQUcsQ0FBQyxHQUFHRCxLQUFLSyxHQUFHLENBQUNULE9BQU9pRSxNQUFNdEIsT0FBTyxDQUFDaEMsS0FBSyxHQUFHO1FBQzFEc0QsTUFBTTZILG1CQUFtQjtRQUN6QixJQUFJdkksYUFBYSxZQUFZVSxNQUFNNEgsYUFBYSxJQUFJO1lBQ2xEN0IsUUFBUUMsSUFBSSxDQUFDO1FBQ2Y7UUFDQSxJQUFJdUMsd0JBQXdCdkksTUFBTTJILGlCQUFpQixDQUFDNUwsT0FBT3VNLGVBQ3pEL0ksV0FBV2dKLHFCQUFxQixDQUFDLEVBQUUsRUFDbkNsQixRQUFRa0IscUJBQXFCLENBQUMsRUFBRTtRQUNsQ3ZJLE1BQU11RCxlQUFlLENBQUNoRSxVQUFVO1lBQzlCRixhQUFhb0U7WUFDYm5FLFVBQVVBO1FBQ1o7UUFDQSxJQUFJQSxhQUFhLFlBQVlVLE1BQU00SCxhQUFhLElBQUk7WUFDbEQ1SCxNQUFNSSxzQkFBc0IsR0FBR3dELFdBQVc7Z0JBQ3hDNUQsTUFBTUksc0JBQXNCLEdBQUc7Z0JBQy9CLElBQUlvSSxlQUFleEksTUFBTVcsbUJBQW1CLENBQUMwRCxHQUFHLENBQUNyRSxNQUFNdEIsT0FBTyxDQUFDdUQsVUFBVSxDQUFDbEc7Z0JBQzFFLElBQUl5TSxjQUFjO29CQUNoQixJQUFJQyx5QkFBeUJ6SSxNQUFNMkgsaUJBQWlCLENBQUM1TCxPQUFPc0wsUUFDMURxQixZQUFZRCxzQkFBc0IsQ0FBQyxFQUFFO29CQUN2QyxJQUFJLENBQUM1TSx1REFBV0EsQ0FBQzZNLFdBQVcxSSxNQUFNd0QsWUFBWSxHQUFHO3dCQUMvQ3hELE1BQU1rSSxhQUFhLENBQUNuTSxPQUFPOzRCQUN6QnNMLE9BQU9BOzRCQUNQL0gsVUFBVUE7d0JBQ1o7b0JBQ0Y7Z0JBQ0YsT0FBTztvQkFDTFUsTUFBTWtJLGFBQWEsQ0FBQ25NLE9BQU87d0JBQ3pCc0wsT0FBT0E7d0JBQ1AvSCxVQUFVQTtvQkFDWjtnQkFDRjtZQUNGO1FBQ0Y7SUFDRjtJQUNBLElBQUksQ0FBQ3FKLFFBQVEsR0FBRyxTQUFVakMsS0FBSyxFQUFFa0MsTUFBTTtRQUNyQyxJQUFJQyxRQUFRRCxXQUFXLEtBQUssSUFBSSxDQUFDLElBQUlBLFFBQ25DdEosV0FBV3VKLE1BQU12SixRQUFRO1FBQzNCVSxNQUFNNkgsbUJBQW1CO1FBQ3pCLElBQUl2SSxhQUFhLFlBQVlVLE1BQU00SCxhQUFhLElBQUk7WUFDbEQ3QixRQUFRQyxJQUFJLENBQUM7UUFDZjtRQUNBaEcsTUFBTXVELGVBQWUsQ0FBQ3ZELE1BQU13RCxZQUFZLEdBQUdrRCxPQUFPO1lBQ2hEckgsYUFBYW9FO1lBQ2JuRSxVQUFVQTtRQUNaO0lBQ0Y7SUFDQSxJQUFJLENBQUN3SixZQUFZLEdBQUc7UUFDbEIsSUFBSUM7UUFDSixPQUFPLENBQUMsQ0FBQyxDQUFDQSx3QkFBd0IvSSxNQUFNK0UsZUFBZSxFQUFFLENBQUMvRSxNQUFNdEIsT0FBTyxDQUFDaEMsS0FBSyxHQUFHLEVBQUUsS0FBSyxPQUFPLEtBQUssSUFBSXFNLHNCQUFzQnhNLEdBQUcsS0FBS3lELE1BQU10QixPQUFPLENBQUNtRCxZQUFZLElBQUk3QixNQUFNdEIsT0FBTyxDQUFDMkQsWUFBWSxHQUFHckMsTUFBTXRCLE9BQU8sQ0FBQ29ELFVBQVU7SUFDMU47SUFDQSxJQUFJLENBQUN5QixlQUFlLEdBQUcsU0FBVXZFLE1BQU0sRUFBRWdLLEtBQUs7UUFDNUMsSUFBSTNKLGNBQWMySixNQUFNM0osV0FBVyxFQUNqQ0MsV0FBVzBKLE1BQU0xSixRQUFRO1FBQzNCVSxNQUFNdEIsT0FBTyxDQUFDdUssVUFBVSxDQUFDakssUUFBUTtZQUMvQk0sVUFBVUE7WUFDVkQsYUFBYUE7UUFDZixHQUFHVztJQUNMO0lBQ0EsSUFBSSxDQUFDa0osT0FBTyxHQUFHO1FBQ2JsSixNQUFNTSxhQUFhLEdBQUcsSUFBSUM7UUFDMUJQLE1BQU0wQyxNQUFNLENBQUM7SUFDZjtJQUNBLElBQUksQ0FBQ3JCLFVBQVUsQ0FBQ3RCO0lBQ2hCLElBQUksQ0FBQzJELFVBQVUsR0FBRyxJQUFJLENBQUNoRixPQUFPLENBQUMwRCxXQUFXO0lBQzFDLElBQUksQ0FBQ29CLFlBQVksR0FBRyxJQUFJLENBQUM5RSxPQUFPLENBQUNrRCxhQUFhO0lBQzlDLElBQUksQ0FBQ3ZCLGlCQUFpQixHQUFHLElBQUksQ0FBQzNCLE9BQU8sQ0FBQzhELHdCQUF3QjtJQUM5RCxJQUFJLENBQUNuQyxpQkFBaUIsQ0FBQ1MsT0FBTyxDQUFDLFNBQVVvRixJQUFJO1FBQzNDbEcsTUFBTU0sYUFBYSxDQUFDa0UsR0FBRyxDQUFDMEIsS0FBS3pFLEdBQUcsRUFBRXlFLEtBQUtwSCxJQUFJO0lBQzdDO0lBQ0EsSUFBSSxDQUFDOEQsV0FBVztBQUNsQjtBQUNBLElBQUl1RSwwQkFBMEIsU0FBU0Esd0JBQXdCZ0MsR0FBRyxFQUFFQyxJQUFJLEVBQUVDLGVBQWUsRUFBRTNILEtBQUs7SUFDOUYsTUFBT3lILE9BQU9DLEtBQU07UUFDbEIsSUFBSUUsU0FBUyxDQUFDSCxNQUFNQyxJQUFHLElBQUssSUFBSTtRQUNoQyxJQUFJRyxlQUFlRixnQkFBZ0JDO1FBQ25DLElBQUlDLGVBQWU3SCxPQUFPO1lBQ3hCeUgsTUFBTUcsU0FBUztRQUNqQixPQUFPLElBQUlDLGVBQWU3SCxPQUFPO1lBQy9CMEgsT0FBT0UsU0FBUztRQUNsQixPQUFPO1lBQ0wsT0FBT0E7UUFDVDtJQUNGO0lBQ0EsSUFBSUgsTUFBTSxHQUFHO1FBQ1gsT0FBT0EsTUFBTTtJQUNmLE9BQU87UUFDTCxPQUFPO0lBQ1Q7QUFDRjtBQUNBLFNBQVN0RyxlQUFlMkcsS0FBSztJQUMzQixJQUFJeEYsZUFBZXdGLE1BQU14RixZQUFZLEVBQ25Dd0IsWUFBWWdFLE1BQU1oRSxTQUFTLEVBQzNCaEMsZUFBZWdHLE1BQU1oRyxZQUFZO0lBQ25DLElBQUk5RyxRQUFRc0gsYUFBYWlCLE1BQU0sR0FBRztJQUNsQyxJQUFJd0UsWUFBWSxTQUFTQSxVQUFVMU4sS0FBSztRQUN0QyxPQUFPaUksWUFBWSxDQUFDakksTUFBTSxDQUFDRyxLQUFLO0lBQ2xDO0lBQ0EsSUFBSUcsYUFBYThLLHdCQUF3QixHQUFHekssT0FBTytNLFdBQVdqRztJQUM5RCxJQUFJL0csV0FBV0o7SUFDZixNQUFPSSxXQUFXQyxTQUFTc0gsWUFBWSxDQUFDdkgsU0FBUyxDQUFDRixHQUFHLEdBQUdpSCxlQUFlZ0MsVUFBVztRQUNoRi9JO0lBQ0Y7SUFDQSxPQUFPO1FBQ0xKLFlBQVlBO1FBQ1pJLFVBQVVBO0lBQ1o7QUFDRjtBQUVrTSxDQUNsTSxrQ0FBa0MiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly92aXNpb24vLi9ub2RlX21vZHVsZXMvQHRhbnN0YWNrL3ZpcnR1YWwtY29yZS9idWlsZC9saWIvaW5kZXgubWpzP2RmMjQiXSwic291cmNlc0NvbnRlbnQiOlsiLyoqXG4gKiB2aXJ0dWFsLWNvcmVcbiAqXG4gKiBDb3B5cmlnaHQgKGMpIFRhblN0YWNrXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgTUlUIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFLm1kIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuXG4gKlxuICogQGxpY2Vuc2UgTUlUXG4gKi9cbmltcG9ydCB7IGV4dGVuZHMgYXMgX2V4dGVuZHMgfSBmcm9tICcuL192aXJ0dWFsL19yb2xsdXBQbHVnaW5CYWJlbEhlbHBlcnMubWpzJztcbmltcG9ydCB7IG1lbW8sIG5vdFVuZGVmaW5lZCwgYXBwcm94RXF1YWwgfSBmcm9tICcuL3V0aWxzLm1qcyc7XG5leHBvcnQgeyBhcHByb3hFcXVhbCwgbWVtbywgbm90VW5kZWZpbmVkIH0gZnJvbSAnLi91dGlscy5tanMnO1xuXG4vL1xuXG4vL1xuXG52YXIgZGVmYXVsdEtleUV4dHJhY3RvciA9IGZ1bmN0aW9uIGRlZmF1bHRLZXlFeHRyYWN0b3IoaW5kZXgpIHtcbiAgcmV0dXJuIGluZGV4O1xufTtcbnZhciBkZWZhdWx0UmFuZ2VFeHRyYWN0b3IgPSBmdW5jdGlvbiBkZWZhdWx0UmFuZ2VFeHRyYWN0b3IocmFuZ2UpIHtcbiAgdmFyIHN0YXJ0ID0gTWF0aC5tYXgocmFuZ2Uuc3RhcnRJbmRleCAtIHJhbmdlLm92ZXJzY2FuLCAwKTtcbiAgdmFyIGVuZCA9IE1hdGgubWluKHJhbmdlLmVuZEluZGV4ICsgcmFuZ2Uub3ZlcnNjYW4sIHJhbmdlLmNvdW50IC0gMSk7XG4gIHZhciBhcnIgPSBbXTtcbiAgZm9yICh2YXIgX2kgPSBzdGFydDsgX2kgPD0gZW5kOyBfaSsrKSB7XG4gICAgYXJyLnB1c2goX2kpO1xuICB9XG4gIHJldHVybiBhcnI7XG59O1xudmFyIG9ic2VydmVFbGVtZW50UmVjdCA9IGZ1bmN0aW9uIG9ic2VydmVFbGVtZW50UmVjdChpbnN0YW5jZSwgY2IpIHtcbiAgdmFyIGVsZW1lbnQgPSBpbnN0YW5jZS5zY3JvbGxFbGVtZW50O1xuICBpZiAoIWVsZW1lbnQpIHtcbiAgICByZXR1cm47XG4gIH1cbiAgdmFyIGhhbmRsZXIgPSBmdW5jdGlvbiBoYW5kbGVyKHJlY3QpIHtcbiAgICB2YXIgd2lkdGggPSByZWN0LndpZHRoLFxuICAgICAgaGVpZ2h0ID0gcmVjdC5oZWlnaHQ7XG4gICAgY2Ioe1xuICAgICAgd2lkdGg6IE1hdGgucm91bmQod2lkdGgpLFxuICAgICAgaGVpZ2h0OiBNYXRoLnJvdW5kKGhlaWdodClcbiAgICB9KTtcbiAgfTtcbiAgaGFuZGxlcihlbGVtZW50LmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpKTtcbiAgdmFyIG9ic2VydmVyID0gbmV3IFJlc2l6ZU9ic2VydmVyKGZ1bmN0aW9uIChlbnRyaWVzKSB7XG4gICAgdmFyIGVudHJ5ID0gZW50cmllc1swXTtcbiAgICBpZiAoZW50cnkgIT0gbnVsbCAmJiBlbnRyeS5ib3JkZXJCb3hTaXplKSB7XG4gICAgICB2YXIgYm94ID0gZW50cnkuYm9yZGVyQm94U2l6ZVswXTtcbiAgICAgIGlmIChib3gpIHtcbiAgICAgICAgaGFuZGxlcih7XG4gICAgICAgICAgd2lkdGg6IGJveC5pbmxpbmVTaXplLFxuICAgICAgICAgIGhlaWdodDogYm94LmJsb2NrU2l6ZVxuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgIH1cbiAgICBoYW5kbGVyKGVsZW1lbnQuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCkpO1xuICB9KTtcbiAgb2JzZXJ2ZXIub2JzZXJ2ZShlbGVtZW50LCB7XG4gICAgYm94OiAnYm9yZGVyLWJveCdcbiAgfSk7XG4gIHJldHVybiBmdW5jdGlvbiAoKSB7XG4gICAgb2JzZXJ2ZXIudW5vYnNlcnZlKGVsZW1lbnQpO1xuICB9O1xufTtcbnZhciBvYnNlcnZlV2luZG93UmVjdCA9IGZ1bmN0aW9uIG9ic2VydmVXaW5kb3dSZWN0KGluc3RhbmNlLCBjYikge1xuICB2YXIgZWxlbWVudCA9IGluc3RhbmNlLnNjcm9sbEVsZW1lbnQ7XG4gIGlmICghZWxlbWVudCkge1xuICAgIHJldHVybjtcbiAgfVxuICB2YXIgaGFuZGxlciA9IGZ1bmN0aW9uIGhhbmRsZXIoKSB7XG4gICAgY2Ioe1xuICAgICAgd2lkdGg6IGVsZW1lbnQuaW5uZXJXaWR0aCxcbiAgICAgIGhlaWdodDogZWxlbWVudC5pbm5lckhlaWdodFxuICAgIH0pO1xuICB9O1xuICBoYW5kbGVyKCk7XG4gIGVsZW1lbnQuYWRkRXZlbnRMaXN0ZW5lcigncmVzaXplJywgaGFuZGxlciwge1xuICAgIHBhc3NpdmU6IHRydWVcbiAgfSk7XG4gIHJldHVybiBmdW5jdGlvbiAoKSB7XG4gICAgZWxlbWVudC5yZW1vdmVFdmVudExpc3RlbmVyKCdyZXNpemUnLCBoYW5kbGVyKTtcbiAgfTtcbn07XG52YXIgb2JzZXJ2ZUVsZW1lbnRPZmZzZXQgPSBmdW5jdGlvbiBvYnNlcnZlRWxlbWVudE9mZnNldChpbnN0YW5jZSwgY2IpIHtcbiAgdmFyIGVsZW1lbnQgPSBpbnN0YW5jZS5zY3JvbGxFbGVtZW50O1xuICBpZiAoIWVsZW1lbnQpIHtcbiAgICByZXR1cm47XG4gIH1cbiAgdmFyIGhhbmRsZXIgPSBmdW5jdGlvbiBoYW5kbGVyKCkge1xuICAgIGNiKGVsZW1lbnRbaW5zdGFuY2Uub3B0aW9ucy5ob3Jpem9udGFsID8gJ3Njcm9sbExlZnQnIDogJ3Njcm9sbFRvcCddKTtcbiAgfTtcbiAgaGFuZGxlcigpO1xuICBlbGVtZW50LmFkZEV2ZW50TGlzdGVuZXIoJ3Njcm9sbCcsIGhhbmRsZXIsIHtcbiAgICBwYXNzaXZlOiB0cnVlXG4gIH0pO1xuICByZXR1cm4gZnVuY3Rpb24gKCkge1xuICAgIGVsZW1lbnQucmVtb3ZlRXZlbnRMaXN0ZW5lcignc2Nyb2xsJywgaGFuZGxlcik7XG4gIH07XG59O1xudmFyIG9ic2VydmVXaW5kb3dPZmZzZXQgPSBmdW5jdGlvbiBvYnNlcnZlV2luZG93T2Zmc2V0KGluc3RhbmNlLCBjYikge1xuICB2YXIgZWxlbWVudCA9IGluc3RhbmNlLnNjcm9sbEVsZW1lbnQ7XG4gIGlmICghZWxlbWVudCkge1xuICAgIHJldHVybjtcbiAgfVxuICB2YXIgaGFuZGxlciA9IGZ1bmN0aW9uIGhhbmRsZXIoKSB7XG4gICAgY2IoZWxlbWVudFtpbnN0YW5jZS5vcHRpb25zLmhvcml6b250YWwgPyAnc2Nyb2xsWCcgOiAnc2Nyb2xsWSddKTtcbiAgfTtcbiAgaGFuZGxlcigpO1xuICBlbGVtZW50LmFkZEV2ZW50TGlzdGVuZXIoJ3Njcm9sbCcsIGhhbmRsZXIsIHtcbiAgICBwYXNzaXZlOiB0cnVlXG4gIH0pO1xuICByZXR1cm4gZnVuY3Rpb24gKCkge1xuICAgIGVsZW1lbnQucmVtb3ZlRXZlbnRMaXN0ZW5lcignc2Nyb2xsJywgaGFuZGxlcik7XG4gIH07XG59O1xudmFyIG1lYXN1cmVFbGVtZW50ID0gZnVuY3Rpb24gbWVhc3VyZUVsZW1lbnQoZWxlbWVudCwgZW50cnksIGluc3RhbmNlKSB7XG4gIGlmIChlbnRyeSAhPSBudWxsICYmIGVudHJ5LmJvcmRlckJveFNpemUpIHtcbiAgICB2YXIgYm94ID0gZW50cnkuYm9yZGVyQm94U2l6ZVswXTtcbiAgICBpZiAoYm94KSB7XG4gICAgICB2YXIgc2l6ZSA9IE1hdGgucm91bmQoYm94W2luc3RhbmNlLm9wdGlvbnMuaG9yaXpvbnRhbCA/ICdpbmxpbmVTaXplJyA6ICdibG9ja1NpemUnXSk7XG4gICAgICByZXR1cm4gc2l6ZTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIE1hdGgucm91bmQoZWxlbWVudC5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKVtpbnN0YW5jZS5vcHRpb25zLmhvcml6b250YWwgPyAnd2lkdGgnIDogJ2hlaWdodCddKTtcbn07XG52YXIgd2luZG93U2Nyb2xsID0gZnVuY3Rpb24gd2luZG93U2Nyb2xsKG9mZnNldCwgX3JlZiwgaW5zdGFuY2UpIHtcbiAgdmFyIF9pbnN0YW5jZSRzY3JvbGxFbGVtZSwgX2luc3RhbmNlJHNjcm9sbEVsZW1lMjtcbiAgdmFyIF9yZWYkYWRqdXN0bWVudHMgPSBfcmVmLmFkanVzdG1lbnRzLFxuICAgIGFkanVzdG1lbnRzID0gX3JlZiRhZGp1c3RtZW50cyA9PT0gdm9pZCAwID8gMCA6IF9yZWYkYWRqdXN0bWVudHMsXG4gICAgYmVoYXZpb3IgPSBfcmVmLmJlaGF2aW9yO1xuICB2YXIgdG9PZmZzZXQgPSBvZmZzZXQgKyBhZGp1c3RtZW50cztcbiAgKF9pbnN0YW5jZSRzY3JvbGxFbGVtZSA9IGluc3RhbmNlLnNjcm9sbEVsZW1lbnQpID09IG51bGwgfHwgX2luc3RhbmNlJHNjcm9sbEVsZW1lLnNjcm9sbFRvID09IG51bGwgfHwgX2luc3RhbmNlJHNjcm9sbEVsZW1lLnNjcm9sbFRvKChfaW5zdGFuY2Ukc2Nyb2xsRWxlbWUyID0ge30sIF9pbnN0YW5jZSRzY3JvbGxFbGVtZTJbaW5zdGFuY2Uub3B0aW9ucy5ob3Jpem9udGFsID8gJ2xlZnQnIDogJ3RvcCddID0gdG9PZmZzZXQsIF9pbnN0YW5jZSRzY3JvbGxFbGVtZTIuYmVoYXZpb3IgPSBiZWhhdmlvciwgX2luc3RhbmNlJHNjcm9sbEVsZW1lMikpO1xufTtcbnZhciBlbGVtZW50U2Nyb2xsID0gZnVuY3Rpb24gZWxlbWVudFNjcm9sbChvZmZzZXQsIF9yZWYyLCBpbnN0YW5jZSkge1xuICB2YXIgX2luc3RhbmNlJHNjcm9sbEVsZW1lMywgX2luc3RhbmNlJHNjcm9sbEVsZW1lNDtcbiAgdmFyIF9yZWYyJGFkanVzdG1lbnRzID0gX3JlZjIuYWRqdXN0bWVudHMsXG4gICAgYWRqdXN0bWVudHMgPSBfcmVmMiRhZGp1c3RtZW50cyA9PT0gdm9pZCAwID8gMCA6IF9yZWYyJGFkanVzdG1lbnRzLFxuICAgIGJlaGF2aW9yID0gX3JlZjIuYmVoYXZpb3I7XG4gIHZhciB0b09mZnNldCA9IG9mZnNldCArIGFkanVzdG1lbnRzO1xuICAoX2luc3RhbmNlJHNjcm9sbEVsZW1lMyA9IGluc3RhbmNlLnNjcm9sbEVsZW1lbnQpID09IG51bGwgfHwgX2luc3RhbmNlJHNjcm9sbEVsZW1lMy5zY3JvbGxUbyA9PSBudWxsIHx8IF9pbnN0YW5jZSRzY3JvbGxFbGVtZTMuc2Nyb2xsVG8oKF9pbnN0YW5jZSRzY3JvbGxFbGVtZTQgPSB7fSwgX2luc3RhbmNlJHNjcm9sbEVsZW1lNFtpbnN0YW5jZS5vcHRpb25zLmhvcml6b250YWwgPyAnbGVmdCcgOiAndG9wJ10gPSB0b09mZnNldCwgX2luc3RhbmNlJHNjcm9sbEVsZW1lNC5iZWhhdmlvciA9IGJlaGF2aW9yLCBfaW5zdGFuY2Ukc2Nyb2xsRWxlbWU0KSk7XG59O1xudmFyIFZpcnR1YWxpemVyID0gZnVuY3Rpb24gVmlydHVhbGl6ZXIoX29wdHMpIHtcbiAgdmFyIF90aGlzID0gdGhpcztcbiAgdGhpcy51bnN1YnMgPSBbXTtcbiAgdGhpcy5zY3JvbGxFbGVtZW50ID0gbnVsbDtcbiAgdGhpcy5pc1Njcm9sbGluZyA9IGZhbHNlO1xuICB0aGlzLmlzU2Nyb2xsaW5nVGltZW91dElkID0gbnVsbDtcbiAgdGhpcy5zY3JvbGxUb0luZGV4VGltZW91dElkID0gbnVsbDtcbiAgdGhpcy5tZWFzdXJlbWVudHNDYWNoZSA9IFtdO1xuICB0aGlzLml0ZW1TaXplQ2FjaGUgPSBuZXcgTWFwKCk7XG4gIHRoaXMucGVuZGluZ01lYXN1cmVkQ2FjaGVJbmRleGVzID0gW107XG4gIHRoaXMuc2Nyb2xsRGlyZWN0aW9uID0gbnVsbDtcbiAgdGhpcy5zY3JvbGxBZGp1c3RtZW50cyA9IDA7XG4gIHRoaXMubWVhc3VyZUVsZW1lbnRDYWNoZSA9IG5ldyBNYXAoKTtcbiAgdGhpcy5vYnNlcnZlciA9IGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgX3JvID0gbnVsbDtcbiAgICB2YXIgZ2V0ID0gZnVuY3Rpb24gZ2V0KCkge1xuICAgICAgaWYgKF9ybykge1xuICAgICAgICByZXR1cm4gX3JvO1xuICAgICAgfSBlbHNlIGlmICh0eXBlb2YgUmVzaXplT2JzZXJ2ZXIgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgIHJldHVybiBfcm8gPSBuZXcgUmVzaXplT2JzZXJ2ZXIoZnVuY3Rpb24gKGVudHJpZXMpIHtcbiAgICAgICAgICBlbnRyaWVzLmZvckVhY2goZnVuY3Rpb24gKGVudHJ5KSB7XG4gICAgICAgICAgICBfdGhpcy5fbWVhc3VyZUVsZW1lbnQoZW50cnkudGFyZ2V0LCBlbnRyeSk7XG4gICAgICAgICAgfSk7XG4gICAgICAgIH0pO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICB9XG4gICAgfTtcbiAgICByZXR1cm4ge1xuICAgICAgZGlzY29ubmVjdDogZnVuY3Rpb24gZGlzY29ubmVjdCgpIHtcbiAgICAgICAgdmFyIF9nZXQ7XG4gICAgICAgIHJldHVybiAoX2dldCA9IGdldCgpKSA9PSBudWxsID8gdm9pZCAwIDogX2dldC5kaXNjb25uZWN0KCk7XG4gICAgICB9LFxuICAgICAgb2JzZXJ2ZTogZnVuY3Rpb24gb2JzZXJ2ZSh0YXJnZXQpIHtcbiAgICAgICAgdmFyIF9nZXQyO1xuICAgICAgICByZXR1cm4gKF9nZXQyID0gZ2V0KCkpID09IG51bGwgPyB2b2lkIDAgOiBfZ2V0Mi5vYnNlcnZlKHRhcmdldCwge1xuICAgICAgICAgIGJveDogJ2JvcmRlci1ib3gnXG4gICAgICAgIH0pO1xuICAgICAgfSxcbiAgICAgIHVub2JzZXJ2ZTogZnVuY3Rpb24gdW5vYnNlcnZlKHRhcmdldCkge1xuICAgICAgICB2YXIgX2dldDM7XG4gICAgICAgIHJldHVybiAoX2dldDMgPSBnZXQoKSkgPT0gbnVsbCA/IHZvaWQgMCA6IF9nZXQzLnVub2JzZXJ2ZSh0YXJnZXQpO1xuICAgICAgfVxuICAgIH07XG4gIH0oKTtcbiAgdGhpcy5yYW5nZSA9IG51bGw7XG4gIHRoaXMuc2V0T3B0aW9ucyA9IGZ1bmN0aW9uIChvcHRzKSB7XG4gICAgT2JqZWN0LmVudHJpZXMob3B0cykuZm9yRWFjaChmdW5jdGlvbiAoX3JlZjMpIHtcbiAgICAgIHZhciBrZXkgPSBfcmVmM1swXSxcbiAgICAgICAgdmFsdWUgPSBfcmVmM1sxXTtcbiAgICAgIGlmICh0eXBlb2YgdmFsdWUgPT09ICd1bmRlZmluZWQnKSBkZWxldGUgb3B0c1trZXldO1xuICAgIH0pO1xuICAgIF90aGlzLm9wdGlvbnMgPSBfZXh0ZW5kcyh7XG4gICAgICBkZWJ1ZzogZmFsc2UsXG4gICAgICBpbml0aWFsT2Zmc2V0OiAwLFxuICAgICAgb3ZlcnNjYW46IDEsXG4gICAgICBwYWRkaW5nU3RhcnQ6IDAsXG4gICAgICBwYWRkaW5nRW5kOiAwLFxuICAgICAgc2Nyb2xsUGFkZGluZ1N0YXJ0OiAwLFxuICAgICAgc2Nyb2xsUGFkZGluZ0VuZDogMCxcbiAgICAgIGhvcml6b250YWw6IGZhbHNlLFxuICAgICAgZ2V0SXRlbUtleTogZGVmYXVsdEtleUV4dHJhY3RvcixcbiAgICAgIHJhbmdlRXh0cmFjdG9yOiBkZWZhdWx0UmFuZ2VFeHRyYWN0b3IsXG4gICAgICBvbkNoYW5nZTogZnVuY3Rpb24gb25DaGFuZ2UoKSB7fSxcbiAgICAgIG1lYXN1cmVFbGVtZW50OiBtZWFzdXJlRWxlbWVudCxcbiAgICAgIGluaXRpYWxSZWN0OiB7XG4gICAgICAgIHdpZHRoOiAwLFxuICAgICAgICBoZWlnaHQ6IDBcbiAgICAgIH0sXG4gICAgICBzY3JvbGxNYXJnaW46IDAsXG4gICAgICBzY3JvbGxpbmdEZWxheTogMTUwLFxuICAgICAgaW5kZXhBdHRyaWJ1dGU6ICdkYXRhLWluZGV4JyxcbiAgICAgIGluaXRpYWxNZWFzdXJlbWVudHNDYWNoZTogW10sXG4gICAgICBsYW5lczogMVxuICAgIH0sIG9wdHMpO1xuICB9O1xuICB0aGlzLm5vdGlmeSA9IGZ1bmN0aW9uIChzeW5jKSB7XG4gICAgX3RoaXMub3B0aW9ucy5vbkNoYW5nZSA9PSBudWxsIHx8IF90aGlzLm9wdGlvbnMub25DaGFuZ2UoX3RoaXMsIHN5bmMpO1xuICB9O1xuICB0aGlzLm1heWJlTm90aWZ5ID0gbWVtbyhmdW5jdGlvbiAoKSB7XG4gICAgX3RoaXMuY2FsY3VsYXRlUmFuZ2UoKTtcbiAgICByZXR1cm4gW190aGlzLmlzU2Nyb2xsaW5nLCBfdGhpcy5yYW5nZSA/IF90aGlzLnJhbmdlLnN0YXJ0SW5kZXggOiBudWxsLCBfdGhpcy5yYW5nZSA/IF90aGlzLnJhbmdlLmVuZEluZGV4IDogbnVsbF07XG4gIH0sIGZ1bmN0aW9uIChpc1Njcm9sbGluZykge1xuICAgIF90aGlzLm5vdGlmeShpc1Njcm9sbGluZyk7XG4gIH0sIHtcbiAgICBrZXk6IHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgJiYgJ21heWJlTm90aWZ5JyxcbiAgICBkZWJ1ZzogZnVuY3Rpb24gZGVidWcoKSB7XG4gICAgICByZXR1cm4gX3RoaXMub3B0aW9ucy5kZWJ1ZztcbiAgICB9LFxuICAgIGluaXRpYWxEZXBzOiBbdGhpcy5pc1Njcm9sbGluZywgdGhpcy5yYW5nZSA/IHRoaXMucmFuZ2Uuc3RhcnRJbmRleCA6IG51bGwsIHRoaXMucmFuZ2UgPyB0aGlzLnJhbmdlLmVuZEluZGV4IDogbnVsbF1cbiAgfSk7XG4gIHRoaXMuY2xlYW51cCA9IGZ1bmN0aW9uICgpIHtcbiAgICBfdGhpcy51bnN1YnMuZmlsdGVyKEJvb2xlYW4pLmZvckVhY2goZnVuY3Rpb24gKGQpIHtcbiAgICAgIHJldHVybiBkKCk7XG4gICAgfSk7XG4gICAgX3RoaXMudW5zdWJzID0gW107XG4gICAgX3RoaXMuc2Nyb2xsRWxlbWVudCA9IG51bGw7XG4gIH07XG4gIHRoaXMuX2RpZE1vdW50ID0gZnVuY3Rpb24gKCkge1xuICAgIF90aGlzLm1lYXN1cmVFbGVtZW50Q2FjaGUuZm9yRWFjaChfdGhpcy5vYnNlcnZlci5vYnNlcnZlKTtcbiAgICByZXR1cm4gZnVuY3Rpb24gKCkge1xuICAgICAgX3RoaXMub2JzZXJ2ZXIuZGlzY29ubmVjdCgpO1xuICAgICAgX3RoaXMuY2xlYW51cCgpO1xuICAgIH07XG4gIH07XG4gIHRoaXMuX3dpbGxVcGRhdGUgPSBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIHNjcm9sbEVsZW1lbnQgPSBfdGhpcy5vcHRpb25zLmdldFNjcm9sbEVsZW1lbnQoKTtcbiAgICBpZiAoX3RoaXMuc2Nyb2xsRWxlbWVudCAhPT0gc2Nyb2xsRWxlbWVudCkge1xuICAgICAgX3RoaXMuY2xlYW51cCgpO1xuICAgICAgX3RoaXMuc2Nyb2xsRWxlbWVudCA9IHNjcm9sbEVsZW1lbnQ7XG4gICAgICBfdGhpcy5fc2Nyb2xsVG9PZmZzZXQoX3RoaXMuc2Nyb2xsT2Zmc2V0LCB7XG4gICAgICAgIGFkanVzdG1lbnRzOiB1bmRlZmluZWQsXG4gICAgICAgIGJlaGF2aW9yOiB1bmRlZmluZWRcbiAgICAgIH0pO1xuICAgICAgX3RoaXMudW5zdWJzLnB1c2goX3RoaXMub3B0aW9ucy5vYnNlcnZlRWxlbWVudFJlY3QoX3RoaXMsIGZ1bmN0aW9uIChyZWN0KSB7XG4gICAgICAgIF90aGlzLnNjcm9sbFJlY3QgPSByZWN0O1xuICAgICAgICBfdGhpcy5tYXliZU5vdGlmeSgpO1xuICAgICAgfSkpO1xuICAgICAgX3RoaXMudW5zdWJzLnB1c2goX3RoaXMub3B0aW9ucy5vYnNlcnZlRWxlbWVudE9mZnNldChfdGhpcywgZnVuY3Rpb24gKG9mZnNldCkge1xuICAgICAgICBfdGhpcy5zY3JvbGxBZGp1c3RtZW50cyA9IDA7XG4gICAgICAgIGlmIChfdGhpcy5zY3JvbGxPZmZzZXQgPT09IG9mZnNldCkge1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBpZiAoX3RoaXMuaXNTY3JvbGxpbmdUaW1lb3V0SWQgIT09IG51bGwpIHtcbiAgICAgICAgICBjbGVhclRpbWVvdXQoX3RoaXMuaXNTY3JvbGxpbmdUaW1lb3V0SWQpO1xuICAgICAgICAgIF90aGlzLmlzU2Nyb2xsaW5nVGltZW91dElkID0gbnVsbDtcbiAgICAgICAgfVxuICAgICAgICBfdGhpcy5pc1Njcm9sbGluZyA9IHRydWU7XG4gICAgICAgIF90aGlzLnNjcm9sbERpcmVjdGlvbiA9IF90aGlzLnNjcm9sbE9mZnNldCA8IG9mZnNldCA/ICdmb3J3YXJkJyA6ICdiYWNrd2FyZCc7XG4gICAgICAgIF90aGlzLnNjcm9sbE9mZnNldCA9IG9mZnNldDtcbiAgICAgICAgX3RoaXMubWF5YmVOb3RpZnkoKTtcbiAgICAgICAgX3RoaXMuaXNTY3JvbGxpbmdUaW1lb3V0SWQgPSBzZXRUaW1lb3V0KGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICBfdGhpcy5pc1Njcm9sbGluZ1RpbWVvdXRJZCA9IG51bGw7XG4gICAgICAgICAgX3RoaXMuaXNTY3JvbGxpbmcgPSBmYWxzZTtcbiAgICAgICAgICBfdGhpcy5zY3JvbGxEaXJlY3Rpb24gPSBudWxsO1xuICAgICAgICAgIF90aGlzLm1heWJlTm90aWZ5KCk7XG4gICAgICAgIH0sIF90aGlzLm9wdGlvbnMuc2Nyb2xsaW5nRGVsYXkpO1xuICAgICAgfSkpO1xuICAgIH1cbiAgfTtcbiAgdGhpcy5nZXRTaXplID0gZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiBfdGhpcy5zY3JvbGxSZWN0W190aGlzLm9wdGlvbnMuaG9yaXpvbnRhbCA/ICd3aWR0aCcgOiAnaGVpZ2h0J107XG4gIH07XG4gIHRoaXMubWVtb09wdGlvbnMgPSBtZW1vKGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gW190aGlzLm9wdGlvbnMuY291bnQsIF90aGlzLm9wdGlvbnMucGFkZGluZ1N0YXJ0LCBfdGhpcy5vcHRpb25zLnNjcm9sbE1hcmdpbiwgX3RoaXMub3B0aW9ucy5nZXRJdGVtS2V5XTtcbiAgfSwgZnVuY3Rpb24gKGNvdW50LCBwYWRkaW5nU3RhcnQsIHNjcm9sbE1hcmdpbiwgZ2V0SXRlbUtleSkge1xuICAgIF90aGlzLnBlbmRpbmdNZWFzdXJlZENhY2hlSW5kZXhlcyA9IFtdO1xuICAgIHJldHVybiB7XG4gICAgICBjb3VudDogY291bnQsXG4gICAgICBwYWRkaW5nU3RhcnQ6IHBhZGRpbmdTdGFydCxcbiAgICAgIHNjcm9sbE1hcmdpbjogc2Nyb2xsTWFyZ2luLFxuICAgICAgZ2V0SXRlbUtleTogZ2V0SXRlbUtleVxuICAgIH07XG4gIH0sIHtcbiAgICBrZXk6IGZhbHNlXG4gIH0pO1xuICB0aGlzLmdldEZ1cnRoZXN0TWVhc3VyZW1lbnQgPSBmdW5jdGlvbiAobWVhc3VyZW1lbnRzLCBpbmRleCkge1xuICAgIHZhciBmdXJ0aGVzdE1lYXN1cmVtZW50c0ZvdW5kID0gbmV3IE1hcCgpO1xuICAgIHZhciBmdXJ0aGVzdE1lYXN1cmVtZW50cyA9IG5ldyBNYXAoKTtcbiAgICBmb3IgKHZhciBtID0gaW5kZXggLSAxOyBtID49IDA7IG0tLSkge1xuICAgICAgdmFyIG1lYXN1cmVtZW50ID0gbWVhc3VyZW1lbnRzW21dO1xuICAgICAgaWYgKGZ1cnRoZXN0TWVhc3VyZW1lbnRzRm91bmQuaGFzKG1lYXN1cmVtZW50LmxhbmUpKSB7XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfVxuICAgICAgdmFyIHByZXZpb3VzRnVydGhlc3RNZWFzdXJlbWVudCA9IGZ1cnRoZXN0TWVhc3VyZW1lbnRzLmdldChtZWFzdXJlbWVudC5sYW5lKTtcbiAgICAgIGlmIChwcmV2aW91c0Z1cnRoZXN0TWVhc3VyZW1lbnQgPT0gbnVsbCB8fCBtZWFzdXJlbWVudC5lbmQgPiBwcmV2aW91c0Z1cnRoZXN0TWVhc3VyZW1lbnQuZW5kKSB7XG4gICAgICAgIGZ1cnRoZXN0TWVhc3VyZW1lbnRzLnNldChtZWFzdXJlbWVudC5sYW5lLCBtZWFzdXJlbWVudCk7XG4gICAgICB9IGVsc2UgaWYgKG1lYXN1cmVtZW50LmVuZCA8IHByZXZpb3VzRnVydGhlc3RNZWFzdXJlbWVudC5lbmQpIHtcbiAgICAgICAgZnVydGhlc3RNZWFzdXJlbWVudHNGb3VuZC5zZXQobWVhc3VyZW1lbnQubGFuZSwgdHJ1ZSk7XG4gICAgICB9XG4gICAgICBpZiAoZnVydGhlc3RNZWFzdXJlbWVudHNGb3VuZC5zaXplID09PSBfdGhpcy5vcHRpb25zLmxhbmVzKSB7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gZnVydGhlc3RNZWFzdXJlbWVudHMuc2l6ZSA9PT0gX3RoaXMub3B0aW9ucy5sYW5lcyA/IEFycmF5LmZyb20oZnVydGhlc3RNZWFzdXJlbWVudHMudmFsdWVzKCkpLnNvcnQoZnVuY3Rpb24gKGEsIGIpIHtcbiAgICAgIHJldHVybiBhLmVuZCAtIGIuZW5kO1xuICAgIH0pWzBdIDogdW5kZWZpbmVkO1xuICB9O1xuICB0aGlzLmdldE1lYXN1cmVtZW50cyA9IG1lbW8oZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiBbX3RoaXMubWVtb09wdGlvbnMoKSwgX3RoaXMuaXRlbVNpemVDYWNoZV07XG4gIH0sIGZ1bmN0aW9uIChfcmVmNCwgaXRlbVNpemVDYWNoZSkge1xuICAgIHZhciBjb3VudCA9IF9yZWY0LmNvdW50LFxuICAgICAgcGFkZGluZ1N0YXJ0ID0gX3JlZjQucGFkZGluZ1N0YXJ0LFxuICAgICAgc2Nyb2xsTWFyZ2luID0gX3JlZjQuc2Nyb2xsTWFyZ2luLFxuICAgICAgZ2V0SXRlbUtleSA9IF9yZWY0LmdldEl0ZW1LZXk7XG4gICAgdmFyIG1pbiA9IF90aGlzLnBlbmRpbmdNZWFzdXJlZENhY2hlSW5kZXhlcy5sZW5ndGggPiAwID8gTWF0aC5taW4uYXBwbHkoTWF0aCwgX3RoaXMucGVuZGluZ01lYXN1cmVkQ2FjaGVJbmRleGVzKSA6IDA7XG4gICAgX3RoaXMucGVuZGluZ01lYXN1cmVkQ2FjaGVJbmRleGVzID0gW107XG4gICAgdmFyIG1lYXN1cmVtZW50cyA9IF90aGlzLm1lYXN1cmVtZW50c0NhY2hlLnNsaWNlKDAsIG1pbik7XG4gICAgZm9yICh2YXIgX2kyID0gbWluOyBfaTIgPCBjb3VudDsgX2kyKyspIHtcbiAgICAgIHZhciBrZXkgPSBnZXRJdGVtS2V5KF9pMik7XG4gICAgICB2YXIgZnVydGhlc3RNZWFzdXJlbWVudCA9IF90aGlzLm9wdGlvbnMubGFuZXMgPT09IDEgPyBtZWFzdXJlbWVudHNbX2kyIC0gMV0gOiBfdGhpcy5nZXRGdXJ0aGVzdE1lYXN1cmVtZW50KG1lYXN1cmVtZW50cywgX2kyKTtcbiAgICAgIHZhciBzdGFydCA9IGZ1cnRoZXN0TWVhc3VyZW1lbnQgPyBmdXJ0aGVzdE1lYXN1cmVtZW50LmVuZCA6IHBhZGRpbmdTdGFydCArIHNjcm9sbE1hcmdpbjtcbiAgICAgIHZhciBtZWFzdXJlZFNpemUgPSBpdGVtU2l6ZUNhY2hlLmdldChrZXkpO1xuICAgICAgdmFyIHNpemUgPSB0eXBlb2YgbWVhc3VyZWRTaXplID09PSAnbnVtYmVyJyA/IG1lYXN1cmVkU2l6ZSA6IF90aGlzLm9wdGlvbnMuZXN0aW1hdGVTaXplKF9pMik7XG4gICAgICB2YXIgZW5kID0gc3RhcnQgKyBzaXplO1xuICAgICAgdmFyIGxhbmUgPSBmdXJ0aGVzdE1lYXN1cmVtZW50ID8gZnVydGhlc3RNZWFzdXJlbWVudC5sYW5lIDogX2kyICUgX3RoaXMub3B0aW9ucy5sYW5lcztcbiAgICAgIG1lYXN1cmVtZW50c1tfaTJdID0ge1xuICAgICAgICBpbmRleDogX2kyLFxuICAgICAgICBzdGFydDogc3RhcnQsXG4gICAgICAgIHNpemU6IHNpemUsXG4gICAgICAgIGVuZDogZW5kLFxuICAgICAgICBrZXk6IGtleSxcbiAgICAgICAgbGFuZTogbGFuZVxuICAgICAgfTtcbiAgICB9XG4gICAgX3RoaXMubWVhc3VyZW1lbnRzQ2FjaGUgPSBtZWFzdXJlbWVudHM7XG4gICAgcmV0dXJuIG1lYXN1cmVtZW50cztcbiAgfSwge1xuICAgIGtleTogcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyAmJiAnZ2V0TWVhc3VyZW1lbnRzJyxcbiAgICBkZWJ1ZzogZnVuY3Rpb24gZGVidWcoKSB7XG4gICAgICByZXR1cm4gX3RoaXMub3B0aW9ucy5kZWJ1ZztcbiAgICB9XG4gIH0pO1xuICB0aGlzLmNhbGN1bGF0ZVJhbmdlID0gbWVtbyhmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIFtfdGhpcy5nZXRNZWFzdXJlbWVudHMoKSwgX3RoaXMuZ2V0U2l6ZSgpLCBfdGhpcy5zY3JvbGxPZmZzZXRdO1xuICB9LCBmdW5jdGlvbiAobWVhc3VyZW1lbnRzLCBvdXRlclNpemUsIHNjcm9sbE9mZnNldCkge1xuICAgIHJldHVybiBfdGhpcy5yYW5nZSA9IG1lYXN1cmVtZW50cy5sZW5ndGggPiAwICYmIG91dGVyU2l6ZSA+IDAgPyBjYWxjdWxhdGVSYW5nZSh7XG4gICAgICBtZWFzdXJlbWVudHM6IG1lYXN1cmVtZW50cyxcbiAgICAgIG91dGVyU2l6ZTogb3V0ZXJTaXplLFxuICAgICAgc2Nyb2xsT2Zmc2V0OiBzY3JvbGxPZmZzZXRcbiAgICB9KSA6IG51bGw7XG4gIH0sIHtcbiAgICBrZXk6IHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgJiYgJ2NhbGN1bGF0ZVJhbmdlJyxcbiAgICBkZWJ1ZzogZnVuY3Rpb24gZGVidWcoKSB7XG4gICAgICByZXR1cm4gX3RoaXMub3B0aW9ucy5kZWJ1ZztcbiAgICB9XG4gIH0pO1xuICB0aGlzLmdldEluZGV4ZXMgPSBtZW1vKGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gW190aGlzLm9wdGlvbnMucmFuZ2VFeHRyYWN0b3IsIF90aGlzLmNhbGN1bGF0ZVJhbmdlKCksIF90aGlzLm9wdGlvbnMub3ZlcnNjYW4sIF90aGlzLm9wdGlvbnMuY291bnRdO1xuICB9LCBmdW5jdGlvbiAocmFuZ2VFeHRyYWN0b3IsIHJhbmdlLCBvdmVyc2NhbiwgY291bnQpIHtcbiAgICByZXR1cm4gcmFuZ2UgPT09IG51bGwgPyBbXSA6IHJhbmdlRXh0cmFjdG9yKF9leHRlbmRzKHt9LCByYW5nZSwge1xuICAgICAgb3ZlcnNjYW46IG92ZXJzY2FuLFxuICAgICAgY291bnQ6IGNvdW50XG4gICAgfSkpO1xuICB9LCB7XG4gICAga2V5OiBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nICYmICdnZXRJbmRleGVzJyxcbiAgICBkZWJ1ZzogZnVuY3Rpb24gZGVidWcoKSB7XG4gICAgICByZXR1cm4gX3RoaXMub3B0aW9ucy5kZWJ1ZztcbiAgICB9XG4gIH0pO1xuICB0aGlzLmluZGV4RnJvbUVsZW1lbnQgPSBmdW5jdGlvbiAobm9kZSkge1xuICAgIHZhciBhdHRyaWJ1dGVOYW1lID0gX3RoaXMub3B0aW9ucy5pbmRleEF0dHJpYnV0ZTtcbiAgICB2YXIgaW5kZXhTdHIgPSBub2RlLmdldEF0dHJpYnV0ZShhdHRyaWJ1dGVOYW1lKTtcbiAgICBpZiAoIWluZGV4U3RyKSB7XG4gICAgICBjb25zb2xlLndhcm4oXCJNaXNzaW5nIGF0dHJpYnV0ZSBuYW1lICdcIiArIGF0dHJpYnV0ZU5hbWUgKyBcIj17aW5kZXh9JyBvbiBtZWFzdXJlZCBlbGVtZW50LlwiKTtcbiAgICAgIHJldHVybiAtMTtcbiAgICB9XG4gICAgcmV0dXJuIHBhcnNlSW50KGluZGV4U3RyLCAxMCk7XG4gIH07XG4gIHRoaXMuX21lYXN1cmVFbGVtZW50ID0gZnVuY3Rpb24gKG5vZGUsIGVudHJ5KSB7XG4gICAgdmFyIGl0ZW0gPSBfdGhpcy5tZWFzdXJlbWVudHNDYWNoZVtfdGhpcy5pbmRleEZyb21FbGVtZW50KG5vZGUpXTtcbiAgICBpZiAoIWl0ZW0gfHwgIW5vZGUuaXNDb25uZWN0ZWQpIHtcbiAgICAgIF90aGlzLm1lYXN1cmVFbGVtZW50Q2FjaGUuZm9yRWFjaChmdW5jdGlvbiAoY2FjaGVkLCBrZXkpIHtcbiAgICAgICAgaWYgKGNhY2hlZCA9PT0gbm9kZSkge1xuICAgICAgICAgIF90aGlzLm9ic2VydmVyLnVub2JzZXJ2ZShub2RlKTtcbiAgICAgICAgICBfdGhpcy5tZWFzdXJlRWxlbWVudENhY2hlW1wiZGVsZXRlXCJdKGtleSk7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICB2YXIgcHJldk5vZGUgPSBfdGhpcy5tZWFzdXJlRWxlbWVudENhY2hlLmdldChpdGVtLmtleSk7XG4gICAgaWYgKHByZXZOb2RlICE9PSBub2RlKSB7XG4gICAgICBpZiAocHJldk5vZGUpIHtcbiAgICAgICAgX3RoaXMub2JzZXJ2ZXIudW5vYnNlcnZlKHByZXZOb2RlKTtcbiAgICAgIH1cbiAgICAgIF90aGlzLm9ic2VydmVyLm9ic2VydmUobm9kZSk7XG4gICAgICBfdGhpcy5tZWFzdXJlRWxlbWVudENhY2hlLnNldChpdGVtLmtleSwgbm9kZSk7XG4gICAgfVxuICAgIHZhciBtZWFzdXJlZEl0ZW1TaXplID0gX3RoaXMub3B0aW9ucy5tZWFzdXJlRWxlbWVudChub2RlLCBlbnRyeSwgX3RoaXMpO1xuICAgIF90aGlzLnJlc2l6ZUl0ZW0oaXRlbSwgbWVhc3VyZWRJdGVtU2l6ZSk7XG4gIH07XG4gIHRoaXMucmVzaXplSXRlbSA9IGZ1bmN0aW9uIChpdGVtLCBzaXplKSB7XG4gICAgdmFyIF90aGlzJGl0ZW1TaXplQ2FjaGUkZztcbiAgICB2YXIgaXRlbVNpemUgPSAoX3RoaXMkaXRlbVNpemVDYWNoZSRnID0gX3RoaXMuaXRlbVNpemVDYWNoZS5nZXQoaXRlbS5rZXkpKSAhPSBudWxsID8gX3RoaXMkaXRlbVNpemVDYWNoZSRnIDogaXRlbS5zaXplO1xuICAgIHZhciBkZWx0YSA9IHNpemUgLSBpdGVtU2l6ZTtcbiAgICBpZiAoZGVsdGEgIT09IDApIHtcbiAgICAgIGlmIChpdGVtLnN0YXJ0IDwgX3RoaXMuc2Nyb2xsT2Zmc2V0KSB7XG4gICAgICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nICYmIF90aGlzLm9wdGlvbnMuZGVidWcpIHtcbiAgICAgICAgICBjb25zb2xlLmluZm8oJ2NvcnJlY3Rpb24nLCBkZWx0YSk7XG4gICAgICAgIH1cbiAgICAgICAgX3RoaXMuX3Njcm9sbFRvT2Zmc2V0KF90aGlzLnNjcm9sbE9mZnNldCwge1xuICAgICAgICAgIGFkanVzdG1lbnRzOiBfdGhpcy5zY3JvbGxBZGp1c3RtZW50cyArPSBkZWx0YSxcbiAgICAgICAgICBiZWhhdmlvcjogdW5kZWZpbmVkXG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgICAgX3RoaXMucGVuZGluZ01lYXN1cmVkQ2FjaGVJbmRleGVzLnB1c2goaXRlbS5pbmRleCk7XG4gICAgICBfdGhpcy5pdGVtU2l6ZUNhY2hlID0gbmV3IE1hcChfdGhpcy5pdGVtU2l6ZUNhY2hlLnNldChpdGVtLmtleSwgc2l6ZSkpO1xuICAgICAgX3RoaXMubm90aWZ5KGZhbHNlKTtcbiAgICB9XG4gIH07XG4gIHRoaXMubWVhc3VyZUVsZW1lbnQgPSBmdW5jdGlvbiAobm9kZSkge1xuICAgIGlmICghbm9kZSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBfdGhpcy5fbWVhc3VyZUVsZW1lbnQobm9kZSwgdW5kZWZpbmVkKTtcbiAgfTtcbiAgdGhpcy5nZXRWaXJ0dWFsSXRlbXMgPSBtZW1vKGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gW190aGlzLmdldEluZGV4ZXMoKSwgX3RoaXMuZ2V0TWVhc3VyZW1lbnRzKCldO1xuICB9LCBmdW5jdGlvbiAoaW5kZXhlcywgbWVhc3VyZW1lbnRzKSB7XG4gICAgdmFyIHZpcnR1YWxJdGVtcyA9IFtdO1xuICAgIGZvciAodmFyIGsgPSAwLCBsZW4gPSBpbmRleGVzLmxlbmd0aDsgayA8IGxlbjsgaysrKSB7XG4gICAgICB2YXIgX2kzID0gaW5kZXhlc1trXTtcbiAgICAgIHZhciBtZWFzdXJlbWVudCA9IG1lYXN1cmVtZW50c1tfaTNdO1xuICAgICAgdmlydHVhbEl0ZW1zLnB1c2gobWVhc3VyZW1lbnQpO1xuICAgIH1cbiAgICByZXR1cm4gdmlydHVhbEl0ZW1zO1xuICB9LCB7XG4gICAga2V5OiBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nICYmICdnZXRJbmRleGVzJyxcbiAgICBkZWJ1ZzogZnVuY3Rpb24gZGVidWcoKSB7XG4gICAgICByZXR1cm4gX3RoaXMub3B0aW9ucy5kZWJ1ZztcbiAgICB9XG4gIH0pO1xuICB0aGlzLmdldFZpcnR1YWxJdGVtRm9yT2Zmc2V0ID0gZnVuY3Rpb24gKG9mZnNldCkge1xuICAgIHZhciBtZWFzdXJlbWVudHMgPSBfdGhpcy5nZXRNZWFzdXJlbWVudHMoKTtcbiAgICByZXR1cm4gbm90VW5kZWZpbmVkKG1lYXN1cmVtZW50c1tmaW5kTmVhcmVzdEJpbmFyeVNlYXJjaCgwLCBtZWFzdXJlbWVudHMubGVuZ3RoIC0gMSwgZnVuY3Rpb24gKGluZGV4KSB7XG4gICAgICByZXR1cm4gbm90VW5kZWZpbmVkKG1lYXN1cmVtZW50c1tpbmRleF0pLnN0YXJ0O1xuICAgIH0sIG9mZnNldCldKTtcbiAgfTtcbiAgdGhpcy5nZXRPZmZzZXRGb3JBbGlnbm1lbnQgPSBmdW5jdGlvbiAodG9PZmZzZXQsIGFsaWduKSB7XG4gICAgdmFyIHNpemUgPSBfdGhpcy5nZXRTaXplKCk7XG4gICAgaWYgKGFsaWduID09PSAnYXV0bycpIHtcbiAgICAgIGlmICh0b09mZnNldCA8PSBfdGhpcy5zY3JvbGxPZmZzZXQpIHtcbiAgICAgICAgYWxpZ24gPSAnc3RhcnQnO1xuICAgICAgfSBlbHNlIGlmICh0b09mZnNldCA+PSBfdGhpcy5zY3JvbGxPZmZzZXQgKyBzaXplKSB7XG4gICAgICAgIGFsaWduID0gJ2VuZCc7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBhbGlnbiA9ICdzdGFydCc7XG4gICAgICB9XG4gICAgfVxuICAgIGlmIChhbGlnbiA9PT0gJ3N0YXJ0Jykge1xuICAgICAgdG9PZmZzZXQgPSB0b09mZnNldDtcbiAgICB9IGVsc2UgaWYgKGFsaWduID09PSAnZW5kJykge1xuICAgICAgdG9PZmZzZXQgPSB0b09mZnNldCAtIHNpemU7XG4gICAgfSBlbHNlIGlmIChhbGlnbiA9PT0gJ2NlbnRlcicpIHtcbiAgICAgIHRvT2Zmc2V0ID0gdG9PZmZzZXQgLSBzaXplIC8gMjtcbiAgICB9XG4gICAgdmFyIHNjcm9sbFNpemVQcm9wID0gX3RoaXMub3B0aW9ucy5ob3Jpem9udGFsID8gJ3Njcm9sbFdpZHRoJyA6ICdzY3JvbGxIZWlnaHQnO1xuICAgIHZhciBzY3JvbGxTaXplID0gX3RoaXMuc2Nyb2xsRWxlbWVudCA/ICdkb2N1bWVudCcgaW4gX3RoaXMuc2Nyb2xsRWxlbWVudCA/IF90aGlzLnNjcm9sbEVsZW1lbnQuZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50W3Njcm9sbFNpemVQcm9wXSA6IF90aGlzLnNjcm9sbEVsZW1lbnRbc2Nyb2xsU2l6ZVByb3BdIDogMDtcbiAgICB2YXIgbWF4T2Zmc2V0ID0gc2Nyb2xsU2l6ZSAtIF90aGlzLmdldFNpemUoKTtcbiAgICByZXR1cm4gTWF0aC5tYXgoTWF0aC5taW4obWF4T2Zmc2V0LCB0b09mZnNldCksIDApO1xuICB9O1xuICB0aGlzLmdldE9mZnNldEZvckluZGV4ID0gZnVuY3Rpb24gKGluZGV4LCBhbGlnbikge1xuICAgIGlmIChhbGlnbiA9PT0gdm9pZCAwKSB7XG4gICAgICBhbGlnbiA9ICdhdXRvJztcbiAgICB9XG4gICAgaW5kZXggPSBNYXRoLm1heCgwLCBNYXRoLm1pbihpbmRleCwgX3RoaXMub3B0aW9ucy5jb3VudCAtIDEpKTtcbiAgICB2YXIgbWVhc3VyZW1lbnQgPSBub3RVbmRlZmluZWQoX3RoaXMuZ2V0TWVhc3VyZW1lbnRzKClbaW5kZXhdKTtcbiAgICBpZiAoYWxpZ24gPT09ICdhdXRvJykge1xuICAgICAgaWYgKG1lYXN1cmVtZW50LmVuZCA+PSBfdGhpcy5zY3JvbGxPZmZzZXQgKyBfdGhpcy5nZXRTaXplKCkgLSBfdGhpcy5vcHRpb25zLnNjcm9sbFBhZGRpbmdFbmQpIHtcbiAgICAgICAgYWxpZ24gPSAnZW5kJztcbiAgICAgIH0gZWxzZSBpZiAobWVhc3VyZW1lbnQuc3RhcnQgPD0gX3RoaXMuc2Nyb2xsT2Zmc2V0ICsgX3RoaXMub3B0aW9ucy5zY3JvbGxQYWRkaW5nU3RhcnQpIHtcbiAgICAgICAgYWxpZ24gPSAnc3RhcnQnO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIFtfdGhpcy5zY3JvbGxPZmZzZXQsIGFsaWduXTtcbiAgICAgIH1cbiAgICB9XG4gICAgdmFyIHRvT2Zmc2V0ID0gYWxpZ24gPT09ICdlbmQnID8gbWVhc3VyZW1lbnQuZW5kICsgX3RoaXMub3B0aW9ucy5zY3JvbGxQYWRkaW5nRW5kIDogbWVhc3VyZW1lbnQuc3RhcnQgLSBfdGhpcy5vcHRpb25zLnNjcm9sbFBhZGRpbmdTdGFydDtcbiAgICByZXR1cm4gW190aGlzLmdldE9mZnNldEZvckFsaWdubWVudCh0b09mZnNldCwgYWxpZ24pLCBhbGlnbl07XG4gIH07XG4gIHRoaXMuaXNEeW5hbWljTW9kZSA9IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gX3RoaXMubWVhc3VyZUVsZW1lbnRDYWNoZS5zaXplID4gMDtcbiAgfTtcbiAgdGhpcy5jYW5jZWxTY3JvbGxUb0luZGV4ID0gZnVuY3Rpb24gKCkge1xuICAgIGlmIChfdGhpcy5zY3JvbGxUb0luZGV4VGltZW91dElkICE9PSBudWxsKSB7XG4gICAgICBjbGVhclRpbWVvdXQoX3RoaXMuc2Nyb2xsVG9JbmRleFRpbWVvdXRJZCk7XG4gICAgICBfdGhpcy5zY3JvbGxUb0luZGV4VGltZW91dElkID0gbnVsbDtcbiAgICB9XG4gIH07XG4gIHRoaXMuc2Nyb2xsVG9PZmZzZXQgPSBmdW5jdGlvbiAodG9PZmZzZXQsIF90ZW1wKSB7XG4gICAgdmFyIF9yZWY1ID0gX3RlbXAgPT09IHZvaWQgMCA/IHt9IDogX3RlbXAsXG4gICAgICBfcmVmNSRhbGlnbiA9IF9yZWY1LmFsaWduLFxuICAgICAgYWxpZ24gPSBfcmVmNSRhbGlnbiA9PT0gdm9pZCAwID8gJ3N0YXJ0JyA6IF9yZWY1JGFsaWduLFxuICAgICAgYmVoYXZpb3IgPSBfcmVmNS5iZWhhdmlvcjtcbiAgICBfdGhpcy5jYW5jZWxTY3JvbGxUb0luZGV4KCk7XG4gICAgaWYgKGJlaGF2aW9yID09PSAnc21vb3RoJyAmJiBfdGhpcy5pc0R5bmFtaWNNb2RlKCkpIHtcbiAgICAgIGNvbnNvbGUud2FybignVGhlIGBzbW9vdGhgIHNjcm9sbCBiZWhhdmlvciBpcyBub3QgZnVsbHkgc3VwcG9ydGVkIHdpdGggZHluYW1pYyBzaXplLicpO1xuICAgIH1cbiAgICBfdGhpcy5fc2Nyb2xsVG9PZmZzZXQoX3RoaXMuZ2V0T2Zmc2V0Rm9yQWxpZ25tZW50KHRvT2Zmc2V0LCBhbGlnbiksIHtcbiAgICAgIGFkanVzdG1lbnRzOiB1bmRlZmluZWQsXG4gICAgICBiZWhhdmlvcjogYmVoYXZpb3JcbiAgICB9KTtcbiAgfTtcbiAgdGhpcy5zY3JvbGxUb0luZGV4ID0gZnVuY3Rpb24gKGluZGV4LCBfdGVtcDIpIHtcbiAgICB2YXIgX3JlZjYgPSBfdGVtcDIgPT09IHZvaWQgMCA/IHt9IDogX3RlbXAyLFxuICAgICAgX3JlZjYkYWxpZ24gPSBfcmVmNi5hbGlnbixcbiAgICAgIGluaXRpYWxBbGlnbiA9IF9yZWY2JGFsaWduID09PSB2b2lkIDAgPyAnYXV0bycgOiBfcmVmNiRhbGlnbixcbiAgICAgIGJlaGF2aW9yID0gX3JlZjYuYmVoYXZpb3I7XG4gICAgaW5kZXggPSBNYXRoLm1heCgwLCBNYXRoLm1pbihpbmRleCwgX3RoaXMub3B0aW9ucy5jb3VudCAtIDEpKTtcbiAgICBfdGhpcy5jYW5jZWxTY3JvbGxUb0luZGV4KCk7XG4gICAgaWYgKGJlaGF2aW9yID09PSAnc21vb3RoJyAmJiBfdGhpcy5pc0R5bmFtaWNNb2RlKCkpIHtcbiAgICAgIGNvbnNvbGUud2FybignVGhlIGBzbW9vdGhgIHNjcm9sbCBiZWhhdmlvciBpcyBub3QgZnVsbHkgc3VwcG9ydGVkIHdpdGggZHluYW1pYyBzaXplLicpO1xuICAgIH1cbiAgICB2YXIgX3RoaXMkZ2V0T2Zmc2V0Rm9ySW5kID0gX3RoaXMuZ2V0T2Zmc2V0Rm9ySW5kZXgoaW5kZXgsIGluaXRpYWxBbGlnbiksXG4gICAgICB0b09mZnNldCA9IF90aGlzJGdldE9mZnNldEZvckluZFswXSxcbiAgICAgIGFsaWduID0gX3RoaXMkZ2V0T2Zmc2V0Rm9ySW5kWzFdO1xuICAgIF90aGlzLl9zY3JvbGxUb09mZnNldCh0b09mZnNldCwge1xuICAgICAgYWRqdXN0bWVudHM6IHVuZGVmaW5lZCxcbiAgICAgIGJlaGF2aW9yOiBiZWhhdmlvclxuICAgIH0pO1xuICAgIGlmIChiZWhhdmlvciAhPT0gJ3Ntb290aCcgJiYgX3RoaXMuaXNEeW5hbWljTW9kZSgpKSB7XG4gICAgICBfdGhpcy5zY3JvbGxUb0luZGV4VGltZW91dElkID0gc2V0VGltZW91dChmdW5jdGlvbiAoKSB7XG4gICAgICAgIF90aGlzLnNjcm9sbFRvSW5kZXhUaW1lb3V0SWQgPSBudWxsO1xuICAgICAgICB2YXIgZWxlbWVudEluRE9NID0gX3RoaXMubWVhc3VyZUVsZW1lbnRDYWNoZS5oYXMoX3RoaXMub3B0aW9ucy5nZXRJdGVtS2V5KGluZGV4KSk7XG4gICAgICAgIGlmIChlbGVtZW50SW5ET00pIHtcbiAgICAgICAgICB2YXIgX3RoaXMkZ2V0T2Zmc2V0Rm9ySW5kMiA9IF90aGlzLmdldE9mZnNldEZvckluZGV4KGluZGV4LCBhbGlnbiksXG4gICAgICAgICAgICBfdG9PZmZzZXQgPSBfdGhpcyRnZXRPZmZzZXRGb3JJbmQyWzBdO1xuICAgICAgICAgIGlmICghYXBwcm94RXF1YWwoX3RvT2Zmc2V0LCBfdGhpcy5zY3JvbGxPZmZzZXQpKSB7XG4gICAgICAgICAgICBfdGhpcy5zY3JvbGxUb0luZGV4KGluZGV4LCB7XG4gICAgICAgICAgICAgIGFsaWduOiBhbGlnbixcbiAgICAgICAgICAgICAgYmVoYXZpb3I6IGJlaGF2aW9yXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgX3RoaXMuc2Nyb2xsVG9JbmRleChpbmRleCwge1xuICAgICAgICAgICAgYWxpZ246IGFsaWduLFxuICAgICAgICAgICAgYmVoYXZpb3I6IGJlaGF2aW9yXG4gICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgIH1cbiAgfTtcbiAgdGhpcy5zY3JvbGxCeSA9IGZ1bmN0aW9uIChkZWx0YSwgX3RlbXAzKSB7XG4gICAgdmFyIF9yZWY3ID0gX3RlbXAzID09PSB2b2lkIDAgPyB7fSA6IF90ZW1wMyxcbiAgICAgIGJlaGF2aW9yID0gX3JlZjcuYmVoYXZpb3I7XG4gICAgX3RoaXMuY2FuY2VsU2Nyb2xsVG9JbmRleCgpO1xuICAgIGlmIChiZWhhdmlvciA9PT0gJ3Ntb290aCcgJiYgX3RoaXMuaXNEeW5hbWljTW9kZSgpKSB7XG4gICAgICBjb25zb2xlLndhcm4oJ1RoZSBgc21vb3RoYCBzY3JvbGwgYmVoYXZpb3IgaXMgbm90IGZ1bGx5IHN1cHBvcnRlZCB3aXRoIGR5bmFtaWMgc2l6ZS4nKTtcbiAgICB9XG4gICAgX3RoaXMuX3Njcm9sbFRvT2Zmc2V0KF90aGlzLnNjcm9sbE9mZnNldCArIGRlbHRhLCB7XG4gICAgICBhZGp1c3RtZW50czogdW5kZWZpbmVkLFxuICAgICAgYmVoYXZpb3I6IGJlaGF2aW9yXG4gICAgfSk7XG4gIH07XG4gIHRoaXMuZ2V0VG90YWxTaXplID0gZnVuY3Rpb24gKCkge1xuICAgIHZhciBfdGhpcyRnZXRNZWFzdXJlbWVudHM7XG4gICAgcmV0dXJuICgoKF90aGlzJGdldE1lYXN1cmVtZW50cyA9IF90aGlzLmdldE1lYXN1cmVtZW50cygpW190aGlzLm9wdGlvbnMuY291bnQgLSAxXSkgPT0gbnVsbCA/IHZvaWQgMCA6IF90aGlzJGdldE1lYXN1cmVtZW50cy5lbmQpIHx8IF90aGlzLm9wdGlvbnMucGFkZGluZ1N0YXJ0KSAtIF90aGlzLm9wdGlvbnMuc2Nyb2xsTWFyZ2luICsgX3RoaXMub3B0aW9ucy5wYWRkaW5nRW5kO1xuICB9O1xuICB0aGlzLl9zY3JvbGxUb09mZnNldCA9IGZ1bmN0aW9uIChvZmZzZXQsIF9yZWY4KSB7XG4gICAgdmFyIGFkanVzdG1lbnRzID0gX3JlZjguYWRqdXN0bWVudHMsXG4gICAgICBiZWhhdmlvciA9IF9yZWY4LmJlaGF2aW9yO1xuICAgIF90aGlzLm9wdGlvbnMuc2Nyb2xsVG9GbihvZmZzZXQsIHtcbiAgICAgIGJlaGF2aW9yOiBiZWhhdmlvcixcbiAgICAgIGFkanVzdG1lbnRzOiBhZGp1c3RtZW50c1xuICAgIH0sIF90aGlzKTtcbiAgfTtcbiAgdGhpcy5tZWFzdXJlID0gZnVuY3Rpb24gKCkge1xuICAgIF90aGlzLml0ZW1TaXplQ2FjaGUgPSBuZXcgTWFwKCk7XG4gICAgX3RoaXMubm90aWZ5KGZhbHNlKTtcbiAgfTtcbiAgdGhpcy5zZXRPcHRpb25zKF9vcHRzKTtcbiAgdGhpcy5zY3JvbGxSZWN0ID0gdGhpcy5vcHRpb25zLmluaXRpYWxSZWN0O1xuICB0aGlzLnNjcm9sbE9mZnNldCA9IHRoaXMub3B0aW9ucy5pbml0aWFsT2Zmc2V0O1xuICB0aGlzLm1lYXN1cmVtZW50c0NhY2hlID0gdGhpcy5vcHRpb25zLmluaXRpYWxNZWFzdXJlbWVudHNDYWNoZTtcbiAgdGhpcy5tZWFzdXJlbWVudHNDYWNoZS5mb3JFYWNoKGZ1bmN0aW9uIChpdGVtKSB7XG4gICAgX3RoaXMuaXRlbVNpemVDYWNoZS5zZXQoaXRlbS5rZXksIGl0ZW0uc2l6ZSk7XG4gIH0pO1xuICB0aGlzLm1heWJlTm90aWZ5KCk7XG59O1xudmFyIGZpbmROZWFyZXN0QmluYXJ5U2VhcmNoID0gZnVuY3Rpb24gZmluZE5lYXJlc3RCaW5hcnlTZWFyY2gobG93LCBoaWdoLCBnZXRDdXJyZW50VmFsdWUsIHZhbHVlKSB7XG4gIHdoaWxlIChsb3cgPD0gaGlnaCkge1xuICAgIHZhciBtaWRkbGUgPSAobG93ICsgaGlnaCkgLyAyIHwgMDtcbiAgICB2YXIgY3VycmVudFZhbHVlID0gZ2V0Q3VycmVudFZhbHVlKG1pZGRsZSk7XG4gICAgaWYgKGN1cnJlbnRWYWx1ZSA8IHZhbHVlKSB7XG4gICAgICBsb3cgPSBtaWRkbGUgKyAxO1xuICAgIH0gZWxzZSBpZiAoY3VycmVudFZhbHVlID4gdmFsdWUpIHtcbiAgICAgIGhpZ2ggPSBtaWRkbGUgLSAxO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gbWlkZGxlO1xuICAgIH1cbiAgfVxuICBpZiAobG93ID4gMCkge1xuICAgIHJldHVybiBsb3cgLSAxO1xuICB9IGVsc2Uge1xuICAgIHJldHVybiAwO1xuICB9XG59O1xuZnVuY3Rpb24gY2FsY3VsYXRlUmFuZ2UoX3JlZjkpIHtcbiAgdmFyIG1lYXN1cmVtZW50cyA9IF9yZWY5Lm1lYXN1cmVtZW50cyxcbiAgICBvdXRlclNpemUgPSBfcmVmOS5vdXRlclNpemUsXG4gICAgc2Nyb2xsT2Zmc2V0ID0gX3JlZjkuc2Nyb2xsT2Zmc2V0O1xuICB2YXIgY291bnQgPSBtZWFzdXJlbWVudHMubGVuZ3RoIC0gMTtcbiAgdmFyIGdldE9mZnNldCA9IGZ1bmN0aW9uIGdldE9mZnNldChpbmRleCkge1xuICAgIHJldHVybiBtZWFzdXJlbWVudHNbaW5kZXhdLnN0YXJ0O1xuICB9O1xuICB2YXIgc3RhcnRJbmRleCA9IGZpbmROZWFyZXN0QmluYXJ5U2VhcmNoKDAsIGNvdW50LCBnZXRPZmZzZXQsIHNjcm9sbE9mZnNldCk7XG4gIHZhciBlbmRJbmRleCA9IHN0YXJ0SW5kZXg7XG4gIHdoaWxlIChlbmRJbmRleCA8IGNvdW50ICYmIG1lYXN1cmVtZW50c1tlbmRJbmRleF0uZW5kIDwgc2Nyb2xsT2Zmc2V0ICsgb3V0ZXJTaXplKSB7XG4gICAgZW5kSW5kZXgrKztcbiAgfVxuICByZXR1cm4ge1xuICAgIHN0YXJ0SW5kZXg6IHN0YXJ0SW5kZXgsXG4gICAgZW5kSW5kZXg6IGVuZEluZGV4XG4gIH07XG59XG5cbmV4cG9ydCB7IFZpcnR1YWxpemVyLCBkZWZhdWx0S2V5RXh0cmFjdG9yLCBkZWZhdWx0UmFuZ2VFeHRyYWN0b3IsIGVsZW1lbnRTY3JvbGwsIG1lYXN1cmVFbGVtZW50LCBvYnNlcnZlRWxlbWVudE9mZnNldCwgb2JzZXJ2ZUVsZW1lbnRSZWN0LCBvYnNlcnZlV2luZG93T2Zmc2V0LCBvYnNlcnZlV2luZG93UmVjdCwgd2luZG93U2Nyb2xsIH07XG4vLyMgc291cmNlTWFwcGluZ1VSTD1pbmRleC5tanMubWFwXG4iXSwibmFtZXMiOlsiZXh0ZW5kcyIsIl9leHRlbmRzIiwibWVtbyIsIm5vdFVuZGVmaW5lZCIsImFwcHJveEVxdWFsIiwiZGVmYXVsdEtleUV4dHJhY3RvciIsImluZGV4IiwiZGVmYXVsdFJhbmdlRXh0cmFjdG9yIiwicmFuZ2UiLCJzdGFydCIsIk1hdGgiLCJtYXgiLCJzdGFydEluZGV4Iiwib3ZlcnNjYW4iLCJlbmQiLCJtaW4iLCJlbmRJbmRleCIsImNvdW50IiwiYXJyIiwiX2kiLCJwdXNoIiwib2JzZXJ2ZUVsZW1lbnRSZWN0IiwiaW5zdGFuY2UiLCJjYiIsImVsZW1lbnQiLCJzY3JvbGxFbGVtZW50IiwiaGFuZGxlciIsInJlY3QiLCJ3aWR0aCIsImhlaWdodCIsInJvdW5kIiwiZ2V0Qm91bmRpbmdDbGllbnRSZWN0Iiwib2JzZXJ2ZXIiLCJSZXNpemVPYnNlcnZlciIsImVudHJpZXMiLCJlbnRyeSIsImJvcmRlckJveFNpemUiLCJib3giLCJpbmxpbmVTaXplIiwiYmxvY2tTaXplIiwib2JzZXJ2ZSIsInVub2JzZXJ2ZSIsIm9ic2VydmVXaW5kb3dSZWN0IiwiaW5uZXJXaWR0aCIsImlubmVySGVpZ2h0IiwiYWRkRXZlbnRMaXN0ZW5lciIsInBhc3NpdmUiLCJyZW1vdmVFdmVudExpc3RlbmVyIiwib2JzZXJ2ZUVsZW1lbnRPZmZzZXQiLCJvcHRpb25zIiwiaG9yaXpvbnRhbCIsIm9ic2VydmVXaW5kb3dPZmZzZXQiLCJtZWFzdXJlRWxlbWVudCIsInNpemUiLCJ3aW5kb3dTY3JvbGwiLCJvZmZzZXQiLCJfcmVmIiwiX2luc3RhbmNlJHNjcm9sbEVsZW1lIiwiX2luc3RhbmNlJHNjcm9sbEVsZW1lMiIsIl9yZWYkYWRqdXN0bWVudHMiLCJhZGp1c3RtZW50cyIsImJlaGF2aW9yIiwidG9PZmZzZXQiLCJzY3JvbGxUbyIsImVsZW1lbnRTY3JvbGwiLCJfcmVmMiIsIl9pbnN0YW5jZSRzY3JvbGxFbGVtZTMiLCJfaW5zdGFuY2Ukc2Nyb2xsRWxlbWU0IiwiX3JlZjIkYWRqdXN0bWVudHMiLCJWaXJ0dWFsaXplciIsIl9vcHRzIiwiX3RoaXMiLCJ1bnN1YnMiLCJpc1Njcm9sbGluZyIsImlzU2Nyb2xsaW5nVGltZW91dElkIiwic2Nyb2xsVG9JbmRleFRpbWVvdXRJZCIsIm1lYXN1cmVtZW50c0NhY2hlIiwiaXRlbVNpemVDYWNoZSIsIk1hcCIsInBlbmRpbmdNZWFzdXJlZENhY2hlSW5kZXhlcyIsInNjcm9sbERpcmVjdGlvbiIsInNjcm9sbEFkanVzdG1lbnRzIiwibWVhc3VyZUVsZW1lbnRDYWNoZSIsIl9ybyIsImdldCIsImZvckVhY2giLCJfbWVhc3VyZUVsZW1lbnQiLCJ0YXJnZXQiLCJkaXNjb25uZWN0IiwiX2dldCIsIl9nZXQyIiwiX2dldDMiLCJzZXRPcHRpb25zIiwib3B0cyIsIk9iamVjdCIsIl9yZWYzIiwia2V5IiwidmFsdWUiLCJkZWJ1ZyIsImluaXRpYWxPZmZzZXQiLCJwYWRkaW5nU3RhcnQiLCJwYWRkaW5nRW5kIiwic2Nyb2xsUGFkZGluZ1N0YXJ0Iiwic2Nyb2xsUGFkZGluZ0VuZCIsImdldEl0ZW1LZXkiLCJyYW5nZUV4dHJhY3RvciIsIm9uQ2hhbmdlIiwiaW5pdGlhbFJlY3QiLCJzY3JvbGxNYXJnaW4iLCJzY3JvbGxpbmdEZWxheSIsImluZGV4QXR0cmlidXRlIiwiaW5pdGlhbE1lYXN1cmVtZW50c0NhY2hlIiwibGFuZXMiLCJub3RpZnkiLCJzeW5jIiwibWF5YmVOb3RpZnkiLCJjYWxjdWxhdGVSYW5nZSIsInByb2Nlc3MiLCJpbml0aWFsRGVwcyIsImNsZWFudXAiLCJmaWx0ZXIiLCJCb29sZWFuIiwiZCIsIl9kaWRNb3VudCIsIl93aWxsVXBkYXRlIiwiZ2V0U2Nyb2xsRWxlbWVudCIsIl9zY3JvbGxUb09mZnNldCIsInNjcm9sbE9mZnNldCIsInVuZGVmaW5lZCIsInNjcm9sbFJlY3QiLCJjbGVhclRpbWVvdXQiLCJzZXRUaW1lb3V0IiwiZ2V0U2l6ZSIsIm1lbW9PcHRpb25zIiwiZ2V0RnVydGhlc3RNZWFzdXJlbWVudCIsIm1lYXN1cmVtZW50cyIsImZ1cnRoZXN0TWVhc3VyZW1lbnRzRm91bmQiLCJmdXJ0aGVzdE1lYXN1cmVtZW50cyIsIm0iLCJtZWFzdXJlbWVudCIsImhhcyIsImxhbmUiLCJwcmV2aW91c0Z1cnRoZXN0TWVhc3VyZW1lbnQiLCJzZXQiLCJBcnJheSIsImZyb20iLCJ2YWx1ZXMiLCJzb3J0IiwiYSIsImIiLCJnZXRNZWFzdXJlbWVudHMiLCJfcmVmNCIsImxlbmd0aCIsImFwcGx5Iiwic2xpY2UiLCJfaTIiLCJmdXJ0aGVzdE1lYXN1cmVtZW50IiwibWVhc3VyZWRTaXplIiwiZXN0aW1hdGVTaXplIiwib3V0ZXJTaXplIiwiZ2V0SW5kZXhlcyIsImluZGV4RnJvbUVsZW1lbnQiLCJub2RlIiwiYXR0cmlidXRlTmFtZSIsImluZGV4U3RyIiwiZ2V0QXR0cmlidXRlIiwiY29uc29sZSIsIndhcm4iLCJwYXJzZUludCIsIml0ZW0iLCJpc0Nvbm5lY3RlZCIsImNhY2hlZCIsInByZXZOb2RlIiwibWVhc3VyZWRJdGVtU2l6ZSIsInJlc2l6ZUl0ZW0iLCJfdGhpcyRpdGVtU2l6ZUNhY2hlJGciLCJpdGVtU2l6ZSIsImRlbHRhIiwiaW5mbyIsImdldFZpcnR1YWxJdGVtcyIsImluZGV4ZXMiLCJ2aXJ0dWFsSXRlbXMiLCJrIiwibGVuIiwiX2kzIiwiZ2V0VmlydHVhbEl0ZW1Gb3JPZmZzZXQiLCJmaW5kTmVhcmVzdEJpbmFyeVNlYXJjaCIsImdldE9mZnNldEZvckFsaWdubWVudCIsImFsaWduIiwic2Nyb2xsU2l6ZVByb3AiLCJzY3JvbGxTaXplIiwiZG9jdW1lbnQiLCJkb2N1bWVudEVsZW1lbnQiLCJtYXhPZmZzZXQiLCJnZXRPZmZzZXRGb3JJbmRleCIsImlzRHluYW1pY01vZGUiLCJjYW5jZWxTY3JvbGxUb0luZGV4Iiwic2Nyb2xsVG9PZmZzZXQiLCJfdGVtcCIsIl9yZWY1IiwiX3JlZjUkYWxpZ24iLCJzY3JvbGxUb0luZGV4IiwiX3RlbXAyIiwiX3JlZjYiLCJfcmVmNiRhbGlnbiIsImluaXRpYWxBbGlnbiIsIl90aGlzJGdldE9mZnNldEZvckluZCIsImVsZW1lbnRJbkRPTSIsIl90aGlzJGdldE9mZnNldEZvckluZDIiLCJfdG9PZmZzZXQiLCJzY3JvbGxCeSIsIl90ZW1wMyIsIl9yZWY3IiwiZ2V0VG90YWxTaXplIiwiX3RoaXMkZ2V0TWVhc3VyZW1lbnRzIiwiX3JlZjgiLCJzY3JvbGxUb0ZuIiwibWVhc3VyZSIsImxvdyIsImhpZ2giLCJnZXRDdXJyZW50VmFsdWUiLCJtaWRkbGUiLCJjdXJyZW50VmFsdWUiLCJfcmVmOSIsImdldE9mZnNldCJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@tanstack/virtual-core/build/lib/index.mjs\n");

/***/ }),

/***/ "(ssr)/./node_modules/@tanstack/virtual-core/build/lib/utils.mjs":
/*!*****************************************************************!*\
  !*** ./node_modules/@tanstack/virtual-core/build/lib/utils.mjs ***!
  \*****************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   approxEqual: () => (/* binding */ approxEqual),\n/* harmony export */   memo: () => (/* binding */ memo),\n/* harmony export */   notUndefined: () => (/* binding */ notUndefined)\n/* harmony export */ });\n/**\n * virtual-core\n *\n * Copyright (c) TanStack\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE.md file in the root directory of this source tree.\n *\n * @license MIT\n */ function memo(getDeps, fn, opts) {\n    var _opts$initialDeps;\n    var deps = (_opts$initialDeps = opts.initialDeps) != null ? _opts$initialDeps : [];\n    var result;\n    return function() {\n        var depTime;\n        if (opts.key && opts.debug != null && opts.debug()) depTime = Date.now();\n        var newDeps = getDeps();\n        var depsChanged = newDeps.length !== deps.length || newDeps.some(function(dep, index) {\n            return deps[index] !== dep;\n        });\n        if (!depsChanged) {\n            return result;\n        }\n        deps = newDeps;\n        var resultTime;\n        if (opts.key && opts.debug != null && opts.debug()) resultTime = Date.now();\n        result = fn.apply(void 0, newDeps);\n        if (opts.key && opts.debug != null && opts.debug()) {\n            var depEndTime = Math.round((Date.now() - depTime) * 100) / 100;\n            var resultEndTime = Math.round((Date.now() - resultTime) * 100) / 100;\n            var resultFpsPercentage = resultEndTime / 16;\n            var pad = function pad(str, num) {\n                str = String(str);\n                while(str.length < num){\n                    str = \" \" + str;\n                }\n                return str;\n            };\n            console.info(\"%c⏱ \" + pad(resultEndTime, 5) + \" /\" + pad(depEndTime, 5) + \" ms\", \"\\n            font-size: .6rem;\\n            font-weight: bold;\\n            color: hsl(\" + Math.max(0, Math.min(120 - 120 * resultFpsPercentage, 120)) + \"deg 100% 31%);\", opts == null ? void 0 : opts.key);\n        }\n        opts == null || opts.onChange == null || opts.onChange(result);\n        return result;\n    };\n}\nfunction notUndefined(value, msg) {\n    if (value === undefined) {\n        throw new Error(\"Unexpected undefined\" + (msg ? \": \" + msg : \"\"));\n    } else {\n        return value;\n    }\n}\nvar approxEqual = function approxEqual(a, b) {\n    return Math.abs(a - b) < 1;\n};\n //# sourceMappingURL=utils.mjs.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQHRhbnN0YWNrL3ZpcnR1YWwtY29yZS9idWlsZC9saWIvdXRpbHMubWpzIiwibWFwcGluZ3MiOiI7Ozs7OztBQUFBOzs7Ozs7Ozs7Q0FTQyxHQUNELFNBQVNBLEtBQUtDLE9BQU8sRUFBRUMsRUFBRSxFQUFFQyxJQUFJO0lBQzdCLElBQUlDO0lBQ0osSUFBSUMsT0FBTyxDQUFDRCxvQkFBb0JELEtBQUtHLFdBQVcsS0FBSyxPQUFPRixvQkFBb0IsRUFBRTtJQUNsRixJQUFJRztJQUNKLE9BQU87UUFDTCxJQUFJQztRQUNKLElBQUlMLEtBQUtNLEdBQUcsSUFBSU4sS0FBS08sS0FBSyxJQUFJLFFBQVFQLEtBQUtPLEtBQUssSUFBSUYsVUFBVUcsS0FBS0MsR0FBRztRQUN0RSxJQUFJQyxVQUFVWjtRQUNkLElBQUlhLGNBQWNELFFBQVFFLE1BQU0sS0FBS1YsS0FBS1UsTUFBTSxJQUFJRixRQUFRRyxJQUFJLENBQUMsU0FBVUMsR0FBRyxFQUFFQyxLQUFLO1lBQ25GLE9BQU9iLElBQUksQ0FBQ2EsTUFBTSxLQUFLRDtRQUN6QjtRQUNBLElBQUksQ0FBQ0gsYUFBYTtZQUNoQixPQUFPUDtRQUNUO1FBQ0FGLE9BQU9RO1FBQ1AsSUFBSU07UUFDSixJQUFJaEIsS0FBS00sR0FBRyxJQUFJTixLQUFLTyxLQUFLLElBQUksUUFBUVAsS0FBS08sS0FBSyxJQUFJUyxhQUFhUixLQUFLQyxHQUFHO1FBQ3pFTCxTQUFTTCxHQUFHa0IsS0FBSyxDQUFDLEtBQUssR0FBR1A7UUFDMUIsSUFBSVYsS0FBS00sR0FBRyxJQUFJTixLQUFLTyxLQUFLLElBQUksUUFBUVAsS0FBS08sS0FBSyxJQUFJO1lBQ2xELElBQUlXLGFBQWFDLEtBQUtDLEtBQUssQ0FBQyxDQUFDWixLQUFLQyxHQUFHLEtBQUtKLE9BQU0sSUFBSyxPQUFPO1lBQzVELElBQUlnQixnQkFBZ0JGLEtBQUtDLEtBQUssQ0FBQyxDQUFDWixLQUFLQyxHQUFHLEtBQUtPLFVBQVMsSUFBSyxPQUFPO1lBQ2xFLElBQUlNLHNCQUFzQkQsZ0JBQWdCO1lBQzFDLElBQUlFLE1BQU0sU0FBU0EsSUFBSUMsR0FBRyxFQUFFQyxHQUFHO2dCQUM3QkQsTUFBTUUsT0FBT0Y7Z0JBQ2IsTUFBT0EsSUFBSVosTUFBTSxHQUFHYSxJQUFLO29CQUN2QkQsTUFBTSxNQUFNQTtnQkFDZDtnQkFDQSxPQUFPQTtZQUNUO1lBQ0FHLFFBQVFDLElBQUksQ0FBQyxTQUFjTCxJQUFJRixlQUFlLEtBQUssT0FBT0UsSUFBSUwsWUFBWSxLQUFLLE9BQU8sNkZBQTZGQyxLQUFLVSxHQUFHLENBQUMsR0FBR1YsS0FBS1csR0FBRyxDQUFDLE1BQU0sTUFBTVIscUJBQXFCLFFBQVEsa0JBQWtCdEIsUUFBUSxPQUFPLEtBQUssSUFBSUEsS0FBS00sR0FBRztRQUNyUztRQUNBTixRQUFRLFFBQVFBLEtBQUsrQixRQUFRLElBQUksUUFBUS9CLEtBQUsrQixRQUFRLENBQUMzQjtRQUN2RCxPQUFPQTtJQUNUO0FBQ0Y7QUFDQSxTQUFTNEIsYUFBYUMsS0FBSyxFQUFFQyxHQUFHO0lBQzlCLElBQUlELFVBQVVFLFdBQVc7UUFDdkIsTUFBTSxJQUFJQyxNQUFNLHlCQUEwQkYsQ0FBQUEsTUFBTSxPQUFPQSxNQUFNLEVBQUM7SUFDaEUsT0FBTztRQUNMLE9BQU9EO0lBQ1Q7QUFDRjtBQUNBLElBQUlJLGNBQWMsU0FBU0EsWUFBWUMsQ0FBQyxFQUFFQyxDQUFDO0lBQ3pDLE9BQU9wQixLQUFLcUIsR0FBRyxDQUFDRixJQUFJQyxLQUFLO0FBQzNCO0FBRTJDLENBQzNDLGtDQUFrQyIsInNvdXJjZXMiOlsid2VicGFjazovL3Zpc2lvbi8uL25vZGVfbW9kdWxlcy9AdGFuc3RhY2svdmlydHVhbC1jb3JlL2J1aWxkL2xpYi91dGlscy5tanM/OWMwYiJdLCJzb3VyY2VzQ29udGVudCI6WyIvKipcbiAqIHZpcnR1YWwtY29yZVxuICpcbiAqIENvcHlyaWdodCAoYykgVGFuU3RhY2tcbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UubWQgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS5cbiAqXG4gKiBAbGljZW5zZSBNSVRcbiAqL1xuZnVuY3Rpb24gbWVtbyhnZXREZXBzLCBmbiwgb3B0cykge1xuICB2YXIgX29wdHMkaW5pdGlhbERlcHM7XG4gIHZhciBkZXBzID0gKF9vcHRzJGluaXRpYWxEZXBzID0gb3B0cy5pbml0aWFsRGVwcykgIT0gbnVsbCA/IF9vcHRzJGluaXRpYWxEZXBzIDogW107XG4gIHZhciByZXN1bHQ7XG4gIHJldHVybiBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIGRlcFRpbWU7XG4gICAgaWYgKG9wdHMua2V5ICYmIG9wdHMuZGVidWcgIT0gbnVsbCAmJiBvcHRzLmRlYnVnKCkpIGRlcFRpbWUgPSBEYXRlLm5vdygpO1xuICAgIHZhciBuZXdEZXBzID0gZ2V0RGVwcygpO1xuICAgIHZhciBkZXBzQ2hhbmdlZCA9IG5ld0RlcHMubGVuZ3RoICE9PSBkZXBzLmxlbmd0aCB8fCBuZXdEZXBzLnNvbWUoZnVuY3Rpb24gKGRlcCwgaW5kZXgpIHtcbiAgICAgIHJldHVybiBkZXBzW2luZGV4XSAhPT0gZGVwO1xuICAgIH0pO1xuICAgIGlmICghZGVwc0NoYW5nZWQpIHtcbiAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuICAgIGRlcHMgPSBuZXdEZXBzO1xuICAgIHZhciByZXN1bHRUaW1lO1xuICAgIGlmIChvcHRzLmtleSAmJiBvcHRzLmRlYnVnICE9IG51bGwgJiYgb3B0cy5kZWJ1ZygpKSByZXN1bHRUaW1lID0gRGF0ZS5ub3coKTtcbiAgICByZXN1bHQgPSBmbi5hcHBseSh2b2lkIDAsIG5ld0RlcHMpO1xuICAgIGlmIChvcHRzLmtleSAmJiBvcHRzLmRlYnVnICE9IG51bGwgJiYgb3B0cy5kZWJ1ZygpKSB7XG4gICAgICB2YXIgZGVwRW5kVGltZSA9IE1hdGgucm91bmQoKERhdGUubm93KCkgLSBkZXBUaW1lKSAqIDEwMCkgLyAxMDA7XG4gICAgICB2YXIgcmVzdWx0RW5kVGltZSA9IE1hdGgucm91bmQoKERhdGUubm93KCkgLSByZXN1bHRUaW1lKSAqIDEwMCkgLyAxMDA7XG4gICAgICB2YXIgcmVzdWx0RnBzUGVyY2VudGFnZSA9IHJlc3VsdEVuZFRpbWUgLyAxNjtcbiAgICAgIHZhciBwYWQgPSBmdW5jdGlvbiBwYWQoc3RyLCBudW0pIHtcbiAgICAgICAgc3RyID0gU3RyaW5nKHN0cik7XG4gICAgICAgIHdoaWxlIChzdHIubGVuZ3RoIDwgbnVtKSB7XG4gICAgICAgICAgc3RyID0gJyAnICsgc3RyO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBzdHI7XG4gICAgICB9O1xuICAgICAgY29uc29sZS5pbmZvKFwiJWNcXHUyM0YxIFwiICsgcGFkKHJlc3VsdEVuZFRpbWUsIDUpICsgXCIgL1wiICsgcGFkKGRlcEVuZFRpbWUsIDUpICsgXCIgbXNcIiwgXCJcXG4gICAgICAgICAgICBmb250LXNpemU6IC42cmVtO1xcbiAgICAgICAgICAgIGZvbnQtd2VpZ2h0OiBib2xkO1xcbiAgICAgICAgICAgIGNvbG9yOiBoc2woXCIgKyBNYXRoLm1heCgwLCBNYXRoLm1pbigxMjAgLSAxMjAgKiByZXN1bHRGcHNQZXJjZW50YWdlLCAxMjApKSArIFwiZGVnIDEwMCUgMzElKTtcIiwgb3B0cyA9PSBudWxsID8gdm9pZCAwIDogb3B0cy5rZXkpO1xuICAgIH1cbiAgICBvcHRzID09IG51bGwgfHwgb3B0cy5vbkNoYW5nZSA9PSBudWxsIHx8IG9wdHMub25DaGFuZ2UocmVzdWx0KTtcbiAgICByZXR1cm4gcmVzdWx0O1xuICB9O1xufVxuZnVuY3Rpb24gbm90VW5kZWZpbmVkKHZhbHVlLCBtc2cpIHtcbiAgaWYgKHZhbHVlID09PSB1bmRlZmluZWQpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoXCJVbmV4cGVjdGVkIHVuZGVmaW5lZFwiICsgKG1zZyA/IFwiOiBcIiArIG1zZyA6ICcnKSk7XG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIHZhbHVlO1xuICB9XG59XG52YXIgYXBwcm94RXF1YWwgPSBmdW5jdGlvbiBhcHByb3hFcXVhbChhLCBiKSB7XG4gIHJldHVybiBNYXRoLmFicyhhIC0gYikgPCAxO1xufTtcblxuZXhwb3J0IHsgYXBwcm94RXF1YWwsIG1lbW8sIG5vdFVuZGVmaW5lZCB9O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9dXRpbHMubWpzLm1hcFxuIl0sIm5hbWVzIjpbIm1lbW8iLCJnZXREZXBzIiwiZm4iLCJvcHRzIiwiX29wdHMkaW5pdGlhbERlcHMiLCJkZXBzIiwiaW5pdGlhbERlcHMiLCJyZXN1bHQiLCJkZXBUaW1lIiwia2V5IiwiZGVidWciLCJEYXRlIiwibm93IiwibmV3RGVwcyIsImRlcHNDaGFuZ2VkIiwibGVuZ3RoIiwic29tZSIsImRlcCIsImluZGV4IiwicmVzdWx0VGltZSIsImFwcGx5IiwiZGVwRW5kVGltZSIsIk1hdGgiLCJyb3VuZCIsInJlc3VsdEVuZFRpbWUiLCJyZXN1bHRGcHNQZXJjZW50YWdlIiwicGFkIiwic3RyIiwibnVtIiwiU3RyaW5nIiwiY29uc29sZSIsImluZm8iLCJtYXgiLCJtaW4iLCJvbkNoYW5nZSIsIm5vdFVuZGVmaW5lZCIsInZhbHVlIiwibXNnIiwidW5kZWZpbmVkIiwiRXJyb3IiLCJhcHByb3hFcXVhbCIsImEiLCJiIiwiYWJzIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@tanstack/virtual-core/build/lib/utils.mjs\n");

/***/ })

};
;